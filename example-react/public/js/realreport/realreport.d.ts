/// <reference types="node" />
/** 
* RealReport v1.4.1
* commit cfce98e

* Copyright (C) 2013-2022 WooriTech Inc.
	https://real-report.com
* All Rights Reserved.
*/

/** 
* RealReport Core v1.4.1
* Copyright (C) 2013-2022 WooriTech Inc.
* All Rights Reserved.
* commit e90b28d0b4dcc8900f90b18868af46c321368e38
*/


declare const enum Cursor$1 {
    DEFAULT = "default",
    AUTO = "auto",
    POINTER = "pointer",
    WAIT = "wait",
    MOVE = "move",
    COL_RESIZE = "col-resize",
    ROW_RESIZE = "row-resize",
    CROSSHAIR = "crosshair",
    HORZ_RESIZE = "ew-resize",
    VERT_RESIZE = "ns-resize",
    NESW_RESIZE = "nesw-resize",
    NWSE_RESIZE = "nwse-resize",
    NO_DROP = "no-drop",
    NOT_ALLOWED = "not-allowed"
}
declare enum Align {
    LEFT = "left",
    CENTER = "center",
    RIGHT = "right"
}
declare enum VerticalAlign {
    TOP = "top",
    MIDDLE = "middle",
    BOTTOM = "bottom"
}
declare enum PrintUnit {
    PIXEL = "px",
    POINT = "pt",
    INCH = "in",
    CENTCH = "cm",
    MILLI = "mm"
}
declare type ValueString = string | number;
declare type Styles = {
    [key: string]: string;
};
/**
 * 상수로 다룬다.
 */
declare class Dimension {
    static HTMLDPI: number;
    static create(str: any): Dimension;
    static createDimensions(str: string): Dimension[];
    static equals(d1: Dimension, d2: Dimension): boolean;
    private _unit;
    private _value;
    private _fixed;
    constructor(value: ValueString);
    get fixed(): boolean;
    get unit(): PrintUnit;
    get value(): number;
    clone(): Dimension;
    equals(other: any): boolean;
    toString(): string;
    getValue(): any;
    getPixel(domain: number): number;
    getFixedPixel(): number;
    $_getPixel(): number;
}
/**
 * 상수로 다룬다.
 */
declare class DimensionCollection {
    static readonly Empty: DimensionCollection;
    private _dims;
    private _values;
    private _relative;
    private _fixed;
    private _dirty;
    constructor(str: string);
    get count(): number;
    get relative(): boolean;
    get(index: number): Dimension;
    set(index: number, dim: Dimension): void;
    /**
     * '%' 이면 domain에서 fixed 크기들을 제외한 크기에 대한 상대 크기.
     * '%'의 전체 함이 100을 넘으면 100으로 scaling한다.
     * 절대크기는 그 크기대로.
     * NaN이거나 설정하지 않은 크기는 위의 크기들을 제외한 나머지 크기의 균등분으로
     * 최소 min으로 설정된다.
     * 전체 합이 domain보다 크거나 작을 수 있다.
     */
    getSizes(count: number, domain: number, minSize: Dimension, truncate?: boolean): number[];
    getSize(index: number, domain: number): number;
    changeSize(count: number, index: number, delta: number, domain: number, minWidth: Dimension): void;
    private $_refresh;
    private $_init;
}
declare enum PageBreakMode {
    NONE = "none",
    BEFORE = "before",
    AFTER = "after",
    BOTH = "both"
}
declare enum ResizeDirection {
    LEFT = "left",
    RIGHT = "right",
    TOP = "top",
    BOTTOM = "bottom",
    TOP_LEFT = "topLeft",
    BOTTOM_RIGHT = "bottomRight",
    TOP_RIGHT = "topRight",
    BOTTOM_LEFT = "bottomLeft"
}
declare namespace ResizeDirection {
    function isLeft(dir: ResizeDirection): boolean;
    function isTop(dir: ResizeDirection): boolean;
    function isEdge(dir: ResizeDirection): boolean;
    function isIn(dir: ResizeDirection, ...dirs: ResizeDirection[]): boolean;
}
/**
 * Find options
 */
interface FindOptions {
    caseSensitive?: boolean;
    wholeWord?: boolean;
    regularExpression?: boolean;
    inSelection?: boolean;
}

declare type ConfigObject$1 = {
    [key: string]: any;
};
/** @internal */
declare abstract class Base$1 {
    private $_hash;
    private $_disposed;
    private $_disposing;
    constructor();
    dispose(): null;
    protected _doDispose(): void;
    get disposing(): boolean;
    get hash(): number;
    get shash(): string;
    isMe(hash: number): boolean;
    private $_getters;
    /**
     * true를 리턴하면 assign()이 호출되지 않는다.
     */
    protected doAssignSimple(source: any): boolean;
    assignFrom(source: any): void;
    extend(source: ConfigObject$1): void;
    toProxy(): ConfigObject$1;
    assignProps(target: object, props: string[], all?: boolean): object;
    toString(): string;
}

interface IEventAware {
    addListener(listener: object): IEventAware;
    removeListener(listener: object): IEventAware;
}
/** @internal */
declare class EventAware$1 extends Base$1 implements IEventAware {
    private _listeners;
    constructor();
    protected _doDispose(): void;
    get listenerCount(): number;
    addListener(listener: object): IEventAware;
    removeListener(listener: object): IEventAware;
    isListener(listener: any): boolean;
    clearListener(): void;
    fireEvent(event: string, ...args: any): void;
    fireConfirmEvent(event: string, ...args: any): boolean;
    fireMessageEvent(event: string, ...args: any): string;
    fireObjectEvent(event: string, ...args: any): any;
}

interface IPoint {
    x: number;
    y: number;
}
interface IRect extends IPoint {
    width: number;
    height: number;
}
/** @internal */
declare class Rectangle$1 implements IRect {
    x: number;
    y: number;
    width: number;
    height: number;
    static Temp: Rectangle$1;
    static create(x: number, y: number, width: number, height: number): Rectangle$1;
    constructor(x?: number, y?: number, width?: number, height?: number);
    /** left */
    get left(): number;
    set left(value: number);
    /** right */
    get right(): number;
    set right(value: number);
    /** top */
    get top(): number;
    set top(value: number);
    /** bottom */
    get bottom(): number;
    set bottom(value: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Rectangle$1;
    getInner(): Rectangle$1;
    equals(r: Rectangle$1): boolean;
    leftBy(delta: number): Rectangle$1;
    rightBy(delta: number): Rectangle$1;
    topBy(delta: number): Rectangle$1;
    bottomBy(delta: number): Rectangle$1;
    shrink(dx: number, dy: number): Rectangle$1;
    expand(dx: number, dy: number): Rectangle$1;
    contains(x: number, y: number): boolean;
    setEmpty(): Rectangle$1;
    move(x?: number, y?: number): Rectangle$1;
    set(x: number, y: number, width: number, height: number): Rectangle$1;
    setWidth(value: number): Rectangle$1;
    copy(r: Rectangle$1): Rectangle$1;
    copyHorz(r: Rectangle$1): Rectangle$1;
    copyVert(r: Rectangle$1): Rectangle$1;
    inflate(left?: number, top?: number, right?: number, bottom?: number): Rectangle$1;
    translate(dx: number, dy: number): Rectangle$1;
    round(): Rectangle$1;
    union(r: Rectangle$1): Rectangle$1;
    normalize(): Rectangle$1;
    intersects(r: Rectangle$1): boolean;
    toString(): string;
}

/** @internal */
declare class Point$1 {
    x: number;
    y: number;
    static empty(): Point$1;
    static create(x?: number, y?: number): Point$1;
    constructor(x?: number, y?: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Point$1;
    equals(sz: Point$1): boolean;
    setEmpty(): Point$1;
    set(x: number, y: number): Point$1;
    round(): Point$1;
    toString(): string;
}

/** @internal */
interface UIToolOwner {
}
/** @internal */
declare class UITool extends Base$1 {
    private _owner;
    private _name;
    private _previous;
    private _dragTracker;
    private _clickX;
    private _clickY;
    private _pointerX;
    private _pointerY;
    private _pointerEventTarget;
    protected _lastTouch: number;
    constructor(owner: UIToolOwner, name: string);
    protected _doDispose(): void;
    /** owner */
    get owner(): UIToolOwner;
    /** name */
    get name(): string;
    /** previous */
    get previous(): UITool;
    /** dragTracker */
    get dragTracker(): UIDragTracker;
    set dragTracker(value: UIDragTracker);
    /** dragging */
    get dragging(): boolean;
    /** pointerX */
    get pointerX(): number;
    /** pointerY */
    get pointerY(): number;
    activate(previous: UITool): void;
    deactivate(): void;
    keyDown(event: KeyboardEvent): boolean;
    keyUp(event: KeyboardEvent): boolean;
    keyPress(event: KeyboardEvent): boolean;
    pointerDown(event: PointerEvent): boolean;
    dragFrom(event: PointerEvent, tracker: UIDragTracker): void;
    dropFrom(event: PointerEvent, tracker: UIDragTracker): void;
    pointerMove(event: PointerEvent): void;
    pointerUp(event: PointerEvent): void;
    pointerEnter(event: PointerEvent): void;
    pointerLeave(event: PointerEvent): void;
    pointerOver(event: PointerEvent): void;
    pointerOutside(): void;
    mouseWheel(event: MouseEvent): boolean;
    contextMenu(event: PointerEvent): boolean;
    click(event: PointerEvent): void;
    dblclick(event: PointerEvent): void;
    setFocus(target?: HTMLElement): void;
    focusLeave(event: Event): void;
    protected get pointerEventTarget(): HTMLElement;
    protected ispointerEventTarget(elt: UIElement): boolean;
    protected _doActivated(previous: UITool): void;
    protected _doDeactivated(): void;
    protected _doKeyDown(event: KeyboardEvent): boolean;
    protected _doKeyUp(event: KeyboardEvent): boolean;
    protected _doKeyPress(event: KeyboardEvent): boolean;
    /**
     * true 리턴하면 preventDefault 호출.
     */
    protected _doPointerDown(event: PointerEvent | TouchEvent): boolean;
    protected _doPointerMove(event: PointerEvent | TouchEvent): void;
    /** 그리드 밖에서도 호출된다. */
    protected _doPointerUp(event: PointerEvent | TouchEvent): void;
    protected _doPointerEnter(event: PointerEvent): void;
    protected _doPointerLeave(event: PointerEvent): void;
    protected _doPointerOver(event: PointerEvent): void;
    protected _doPointerOutside(): void;
    protected _doMouseWheel(event: MouseEvent): boolean;
    protected _doContextMenu(event: PointerEvent): boolean;
    /** 그리드 밖에서 마우스를 놓으면 호출되지 않는다. */
    protected _doClick(event: PointerEvent): void;
    protected _doDblClick(event: PointerEvent): void;
    protected _doSetFocus(target?: HTMLElement): void;
    protected _doFocusLeave(event: Event): void;
    protected _getUIDragTracker(request: UIEditRequest, x: number, y: number): UIDragTracker;
    protected _startDragTracker(event: PointerEvent, x: number, y: number, shift: boolean, alt: boolean): void;
    protected _stopDragTracker(event: PointerEvent, x: number, y: number, canceled: boolean): void;
    protected _doDragTrackerStarted(UIDragTracker: UIDragTracker): void;
    protected _doDragTrackerFinished(UIDragTracker: UIDragTracker, canceled: boolean): void;
}
/** @internal */
declare abstract class UIEditRequest extends Base$1 {
    constructor();
    /** cursor */
    get cursor(): Cursor$1;
    /** source */
    get source(): any;
    /** selectable */
    get selectable(): boolean;
    /** dblClickable */
    get dblClickable(): boolean;
}
/** @internal */
declare class UIDragTracker extends Base$1 {
    private _container;
    private _name;
    private _active;
    private _completed;
    private _dragging;
    private _startX;
    private _startY;
    private _currentX;
    private _currentY;
    constructor(container: UIContainer, name: string);
    /** container */
    get container(): UIContainer;
    /** name */
    get name(): string;
    /** active */
    get active(): boolean;
    /** dragging */
    get dragging(): boolean;
    /** startWhenCreated */
    get startWhenCreated(): boolean;
    /** completed */
    get completed(): boolean;
    /**
     * linkable proprerty.
     * 다른 그리드에서 진행 가능한 tracker.
     */
    get linkable(): boolean;
    activate(): void;
    deactivate(): void;
    start(event: PointerEvent, eventTarget: HTMLElement, x: number, y: number, shift: boolean, alt: boolean): boolean;
    drag(eventTarget: HTMLElement, x: number, y: number): boolean;
    cancel(event: PointerEvent): void;
    drop(event: PointerEvent, eventTarget: HTMLElement, x: number, y: number): void;
    getRequest(): UIEditRequest;
    getNextRequest(x: number, y: number): UIEditRequest;
    protected get startX(): number;
    protected get startY(): number;
    protected get currentX(): number;
    protected get currentY(): number;
    protected _showFeedback(x: number, y: number): void;
    protected _moveFeedback(x: number, y: number): void;
    protected _hideFeedback(): void;
    protected _doActivate(): void;
    protected _doDeactivate(): void;
    protected _doStart(event: PointerEvent, eventTarget: HTMLElement, x: number, y: number, shfit: boolean, alt: boolean): boolean;
    protected _doDrag(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCanceled(x: number, y: number): void;
    protected _canAccept(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCompleted(eventTarget: HTMLElement, x: number, y: number): void;
    protected _doEnded(event: PointerEvent): void;
}

declare class UIElement extends EventAware$1 {
    userData: any;
    private _parent;
    private _dom;
    private _elements;
    constructor(doc: Document, className: string, elementType?: string);
    get dom(): HTMLElement;
    /** parent */
    get parent(): UIElement;
    /** container */
    get container(): UIContainer;
    /** x */
    get x(): number;
    set x(value: number);
    /** y */
    get y(): number;
    set y(value: number);
    /** width */
    get width(): number;
    /** height */
    get height(): number;
    isDom(dom: Element): boolean;
    setClassName(className: string): void;
    setHint(title: string): void;
    setStyle(style: string, value: string): void;
    clearStyle(style: string): void;
    setStyles(styles: object): void;
    setImportantStyle(style: string, value: any): void;
    getBounds(): IRect;
    setBounds(x: number, y: number, width: number, height: number): void;
    setRect(r: IRect): void;
    move(x: number, y: number): UIElement;
    setXP(x: number): void;
    setYP(y: number): void;
    clear(): void;
    addChild(child: UIElement): boolean;
    removeChild(child: UIElement): boolean;
    removeLast(): UIElement;
    containerToLocal(x?: number, y?: number): {
        x: number;
        y: number;
    };
    setText(text: string): void;
    hide(): void;
    show(style?: string): void;
    setRotation(rotation: number): void;
    protected _addChild(child: UIElement): void;
    protected _removeChild(child: UIElement): boolean;
    protected _prepareDom(doc: Document, dom: HTMLElement): void;
}
/** @internal */
declare abstract class UIContainer extends EventAware$1 {
    private _activeTool;
    private _containerDiv;
    private _layoutNeeded;
    private _defaultTool;
    private _defaultCursor;
    private _eventHandlers;
    private _eventNodes;
    private _doc;
    private _root;
    private _requestTimer;
    private _containerRender;
    private _saveDisplay;
    constructor(containerId: string | HTMLDivElement);
    protected _doDispose(): void;
    /** Document */
    get doc(): Document;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** activeTool */
    get activeTool(): UITool;
    set activeTool(value: UITool);
    /** defaultTool */
    get defaultTool(): UITool;
    /** width */
    get width(): number;
    /** height */
    get height(): number;
    getBound(): Rectangle$1;
    getHtml(): string;
    setCursor(cursor?: string): void;
    contains(dom: any): boolean;
    protected abstract _getCssSelector(): string;
    private prepareContainer;
    protected _addElement(element: UIElement): void;
    protected _prepareChildren(doc: Document, dom: HTMLElement): void;
    protected _createDefaultTool(): UITool;
    isLayoutNeeded(): boolean;
    invalidateLayout(): void;
    updateNow(): void;
    protected _render(timestamp: number): void;
    private $$_render;
    protected _doLayout(doc: Document, bounds: Rectangle$1): void;
    protected _doPrepareRender(bounds: Rectangle$1): void;
    protected _doRenderHtml(bounds: Rectangle$1): void;
    _registerEventHandlers(container: HTMLElement): void;
    $_addListener(node: any, event: any, handler: any, capture: any): void;
    $_removeListener(node: any, event: any): void;
    $_removeListenerAll(node?: HTMLElement): void;
    private _unloadHandler;
    private _resizeHandler;
    protected _doResized(event: Event): void;
    protected _isEnabled(): boolean;
    private _keyDownHandler;
    private _keyUpHandler;
    private _keyPressHandler;
    eventToContainer(event: any): Point$1;
    private toOffset;
    private _clickHandler;
    private _dblclickHandler;
    private $_getHtmlElement;
    private _pointerDownHandler;
    private _pointerMoveHandler;
    private _pointerUpHandler;
    private _pointerEnterHandler;
    private _pointerLeaveHandler;
    private _pointerOverHandler;
    private _contextMenuHander;
    private _wheelHandler;
    private _focusHandler;
    private _blurHandler;
    private _selectstartHandler;
    private _focusinHandler;
    private _globalPointerDownHandler;
    private _focusoutHandler;
    private _focusHandlerFireFox;
}

/** @internal */
interface VisualToolOwner$1 {
    findElementAt(x: number, y: number, hitTesting: boolean, blockLayer: boolean): VisualElement$1;
    findElementOf(dom: HTMLElement): VisualElement$1;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
}
/** @internal */
declare class VisualTool$1 extends Base$1 {
    private _owner;
    private _name;
    private _previous;
    private _dragTracker;
    private _clickX;
    private _clickY;
    private _mouseX;
    private _mouseY;
    private _mouseEventTarget;
    protected _lastTouch: number;
    constructor(owner: VisualToolOwner$1, name?: string);
    protected _doDispose(): void;
    /** owner */
    get owner(): VisualToolOwner$1;
    /** name */
    get name(): string;
    /** previous */
    get previous(): VisualTool$1;
    /** dragTracker */
    get dragTracker(): DragTracker$1;
    set dragTracker(value: DragTracker$1);
    /** dragging */
    get dragging(): boolean;
    /** mouseX */
    get mouseX(): number;
    /** mouseY */
    get mouseY(): number;
    get mouseEventTarget(): HTMLElement;
    findElementAt(x: number, y: number, hitTesting: boolean, blockLayer?: boolean): VisualElement$1;
    findElementOf(dom: HTMLElement): VisualElement$1;
    activate(previous: VisualTool$1): void;
    deactivate(): void;
    keyDown(event: KeyboardEvent): boolean;
    keyUp(event: KeyboardEvent): boolean;
    keyPress(event: KeyboardEvent): boolean;
    mouseDown(event: MouseEvent | TouchEvent): boolean;
    dragFrom(event: MouseEvent, tracker: DragTracker$1): void;
    dropFrom(event: MouseEvent, tracker: DragTracker$1): void;
    mouseMove(event: MouseEvent | TouchEvent): void;
    mouseUp(event: MouseEvent | TouchEvent): void;
    mouseEnter(event: MouseEvent): void;
    mouseLeave(event: MouseEvent): void;
    mouseOver(event: MouseEvent): void;
    mouseOutside(): void;
    mouseWheel(event: MouseEvent): boolean;
    contextMenu(event: MouseEvent): boolean;
    click(event: MouseEvent): void;
    dblclick(event: MouseEvent): void;
    setFocus(target?: HTMLElement): void;
    focusLeave(event: Event): void;
    dragStart(event: MouseEvent): void;
    dragEnd(event: MouseEvent): void;
    dragEnter(event: MouseEvent): void;
    dragOver(event: MouseEvent): void;
    dragLeave(event: MouseEvent): void;
    dragDrop(event: MouseEvent): void;
    protected isMouseEventTarget(elt: VisualElement$1): boolean;
    protected _doActivated(previous: VisualTool$1): void;
    protected _doDeactivated(): void;
    protected _doKeyDown(event: KeyboardEvent): boolean;
    protected _doKeyUp(event: KeyboardEvent): boolean;
    protected _doKeyPress(event: KeyboardEvent): boolean;
    /**
     * true 리턴하면 preventDefault 호출.
     */
    protected _doMouseDown(event: MouseEvent | TouchEvent): boolean;
    protected _doMouseMove(event: MouseEvent | TouchEvent): void;
    /** 그리드 밖에서도 호출된다. */
    protected _doMouseUp(event: MouseEvent | TouchEvent): void;
    protected _doMouseEnter(event: MouseEvent): void;
    protected _doMouseLeave(event: MouseEvent): void;
    protected _doMouseOver(event: MouseEvent): void;
    protected _doMouseOutside(): void;
    protected _doMouseWheel(event: MouseEvent): boolean;
    protected _doContextMenu(event: MouseEvent): boolean;
    /** 그리드 밖에서 마우스를 놓으면 호출되지 않는다. */
    protected _doClick(event: MouseEvent): void;
    protected _doDblClick(event: MouseEvent): void;
    protected _doSetFocus(target?: HTMLElement): void;
    protected _doFocusLeave(event: Event): void;
    protected _doDragStart(event: MouseEvent): void;
    protected _doDragEnd(event: MouseEvent): void;
    protected _doDragEnter(event: MouseEvent): void;
    protected _doDragOver(event: MouseEvent): void;
    protected _doDragLeave(event: MouseEvent): void;
    protected _doDragDrop(event: MouseEvent): void;
    protected _getDragTracker(request: EditRequest$1, x: number, y: number): DragTracker$1;
    protected _startDragTracker(x: number, y: number, shift: boolean, alt: boolean): void;
    protected _stopDragTracker(x: number, y: number, canceled: boolean): void;
    protected _doDragTrackerStarted(dragTracker: DragTracker$1): void;
    protected _doDragTrackerFinished(dragTracker: DragTracker$1, canceled: boolean): void;
    protected _findTableCell(source?: HTMLElement): HTMLTableCellElement;
    protected _doTouchStart(event: TouchEvent): void;
    protected _doTouchMove(event: TouchEvent): void;
    protected _doTouchEnd(evnet: TouchEvent): void;
    protected _doTouchCancel(evnet: TouchEvent): void;
}
/** @internal */
declare abstract class EditRequest$1 extends Base$1 {
    constructor();
    /** cursor */
    get cursor(): Cursor$1;
    /** source */
    get source(): any;
    /** selectable */
    get selectable(): boolean;
    /** dblClickable */
    get dblClickable(): boolean;
}
/** @internal */
declare class DragTracker$1 extends Base$1 {
    private _container;
    private _name;
    private _active;
    private _completed;
    private _dragging;
    private _startX;
    private _startY;
    private _currentX;
    private _currentY;
    constructor(container: VisualContainer$1, name: string);
    /** container */
    get container(): VisualContainer$1;
    /** name */
    get name(): string;
    /** active */
    get active(): boolean;
    /** dragging */
    get dragging(): boolean;
    /** startWhenCreated */
    get startWhenCreated(): boolean;
    /** completed */
    get completed(): boolean;
    /**
     * linkable proprerty.
     * 다른 그리드에서 진행 가능한 tracker.
     */
    get linkable(): boolean;
    get cursor(): string;
    activate(): void;
    deactivate(): void;
    start(eventTarget: HTMLElement, x: number, y: number, shift: boolean, alt: boolean): boolean;
    drag(eventTarget: HTMLElement, x: number, y: number): boolean;
    cancel(): void;
    drop(eventTarget: HTMLElement, x: number, y: number): void;
    end(): void;
    getRequest(): EditRequest$1;
    getNextRequest(x: number, y: number): EditRequest$1;
    protected get startX(): number;
    protected get startY(): number;
    protected get currentX(): number;
    protected get currentY(): number;
    protected _showFeedback(x: number, y: number): void;
    protected _moveFeedback(x: number, y: number): void;
    protected _hideFeedback(): void;
    protected _doActivate(): void;
    protected _doDeactivate(): void;
    protected _doStart(eventTarget: HTMLElement, x: number, y: number, shfit: boolean, alt: boolean): boolean;
    protected _doDrag(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCanceled(x: number, y: number): void;
    protected _canAccept(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCompleted(eventTarget: HTMLElement, x: number, y: number): void;
    protected _doEnded(): void;
}

/** @internal */
declare abstract class VisualContainer$1 extends EventAware$1 implements VisualToolOwner$1 {
    static readonly FEEDBACK_ZINDEX = 1000;
    private static $_Containers;
    static $_mouseContainer: number;
    getMouseContainer(): VisualContainer$1;
    private static $_ActiveGrid;
    static getActiveGrid(): any;
    static setActiveGrid(hash: number): void;
    static clearContainer(hash: number): void;
    static disposeStatic(): void;
    private _disabled;
    private _activeTool;
    private _containerDiv;
    private _containerDom;
    private _measurer;
    private _textMeasurer;
    private _checkMeasurer;
    private _checkRect;
    private _updateRequested;
    private _layoutNeeded;
    private _invalidated;
    private _scrolling;
    private _defaultTool;
    private _captured;
    private _focusing;
    private _focusingTarget;
    private _hovered;
    private _currentX;
    private _currentY;
    private _rendered;
    private _defaultCursor;
    private _drawing;
    private _offsetX;
    private _offsetY;
    private _rootElement;
    private _feedbackElement;
    private _printRoot;
    private _eventHandlers;
    private _eventNodes;
    private _contextMenu;
    private _containerRender;
    private _scrollTool;
    private _cursor;
    private _testWidth;
    private _testHeight;
    private _requestTimer;
    private _doc;
    private _saveDisplay;
    private $_testing;
    constructor(containerId: string | HTMLDivElement);
    protected _doDispose(): void;
    /** document */
    get doc(): Document;
    /** dom */
    get dom(): HTMLElement;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** disabled */
    get disabled(): boolean;
    set disabled(value: boolean);
    /** printing */
    get printing(): boolean;
    /** activeTool */
    get activeTool(): VisualTool$1;
    set activeTool(value: VisualTool$1);
    /** defaultTool */
    get defaultTool(): VisualTool$1;
    /** measurer */
    protected get measurer(): HTMLElement;
    /** width */
    get width(): number;
    /** height */
    get height(): number;
    get scrollHeight(): number;
    get scrollTop(): number;
    protected get scrolling(): boolean;
    findElementAt(x: number, y: number, hitTesting: boolean, blockLayer: boolean): VisualElement$1;
    findElementOf(dom: Element): VisualElement$1;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
    setCursor(cursor: string): void;
    setFocus(): void;
    updateNow(): void;
    toScreen(r: Rectangle$1): Rectangle$1;
    pointToScreen(x: number, y: number): {
        x: number;
        y: number;
    };
    getBound(): Rectangle$1;
    getHtml(): string;
    addElement(element: VisualElement$1): boolean;
    removeElement(element: VisualElement$1): boolean;
    addFeedback(element: UIElement | HTMLElement): boolean;
    addFeedbacks(...elements: UIElement[]): void;
    removeFeedback(element: UIElement | HTMLElement): boolean;
    removeFeedbacks(...elements: UIElement[]): void;
    resetSize(callback?: any): void;
    measureText(style: string, text: string): number;
    private $_refreshCheckMeasurer;
    measureCheckWidth(): number;
    measureCheckHeight(): number;
    contains(target: any): boolean;
    getDomPosition(elt: HTMLElement | VisualElement$1, rotated?: boolean): IRect;
    private $_offsetDomPosition;
    getBoundingRect(element: VisualElement$1): Rectangle$1;
    private $_setTesting;
    protected get _isTesting(): boolean;
    protected _doDisabledChanged(): void;
    private $_prepareContainer;
    protected _doPrepareContainer(dom: HTMLElement): void;
    protected _createRootElement(doc: Document): VisualElement$1;
    protected _createDefaultTool(): VisualTool$1;
    isLayoutNeeded(): boolean;
    invalidateLayout(scrolling?: boolean): void;
    invalidate(force: boolean): void;
    invalidateElement(element: VisualElement$1): void;
    invalidateElements(force?: boolean): void;
    refresh(): void;
    protected _render(timestamp: number): void;
    private $$_render;
    protected _layoutChildren(bounds: Rectangle$1): void;
    protected _doLayout(bounds: Rectangle$1): void;
    protected _doAfterRender(): void;
    protected _doPrepareRender(bounds: Rectangle$1): void;
    protected _doRenderHtml(bounds: Rectangle$1): void;
    protected _doDrawContainer(bounds: Rectangle$1): void;
    protected _drawElement(element: VisualElement$1): void;
    private _validateChildren;
    _registerEventHandlers(container: HTMLElement): void;
    $_addListener(node: any, event: any, handler: any, capture: any): void;
    $_removeListener(node: any, event: any): void;
    $_removeListenerAll(node?: HTMLElement): void;
    private _unloadHandler;
    private _resizeHandler;
    protected _doResized(event: Event): void;
    protected _isEnabled(): boolean;
    private _keyDownHandler;
    private _keyUpHandler;
    private _keyPressHandler;
    eventToContainer(event: any): Point$1;
    private toOffset;
    private toOffsetTouch;
    private _clickHandler;
    private _dblclickHandler;
    private $_getHtmlElement;
    protected _isAutoFocus(): boolean;
    private _mouseDownHandler;
    private _mouseMoveHandler;
    private _mouseUpHandler;
    private _mouseEnterHandler;
    private _mouseLeaveHandler;
    private _mouseOverHandler;
    /**
     * - 드래그 하는동안은 MouseMove가 발생하지 않기 때문에 Start End를 제외하고 타겟을 직접 넣어준다.
     * @param event
     */
    private _dragStartHandler;
    private _dragEndHandler;
    private _dragOverHandler;
    private _dragEnterHandler;
    private _dragLeaveHandler;
    private _dragDropHandler;
    private _contextMenuHander;
    private _wheelHandler;
    private _focusHandler;
    private _blurHandler;
    private _selectstartHandler;
    private _focusinHandler;
    private _globalMouseDownHandler;
    private _focusoutHandler;
    private _focusHandlerFireFox;
}

declare type VisualElementCallback = (element: VisualElement$1, dom: HTMLElement) => void;
/** @internal */
declare abstract class VisualElement$1 extends EventAware$1 {
    private static readonly Testing;
    private _positionable;
    private _x;
    private _y;
    private _width;
    private _height;
    private _visible;
    private _styleName;
    private _name;
    private _parent;
    private _elements;
    private _dom;
    private _dirty;
    private _hovered;
    private _className;
    private _nodraw;
    constructor(doc: Document, name?: string, callback?: VisualElementCallback);
    protected _doDispose(): void;
    /** positionable */
    get positionable(): boolean;
    set positionable(value: boolean);
    /** name */
    get name(): string;
    /** styleName */
    get styleName(): string;
    set styleName(value: string);
    /** container */
    get container(): VisualContainer$1;
    /** parent */
    get parent(): VisualElement$1;
    /** elements */
    get elements(): VisualElement$1[];
    /** childCount */
    get childCount(): number;
    /** isSingleton */
    get isSingleton(): boolean;
    /** x */
    get x(): number;
    set x(value: number);
    /** y */
    get y(): number;
    set y(value: number);
    /** width */
    get width(): number;
    set width(value: number);
    /** height */
    get height(): number;
    set height(value: number);
    /** right */
    get right(): number;
    /** bottom */
    get bottom(): number;
    /** position */
    get position(): Point$1;
    /** bounds */
    get bounds(): Rectangle$1;
    /** clientRect */
    get clientRect(): Rectangle$1;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** findable */
    get findable(): boolean;
    /** hovered */
    get hovered(): boolean;
    set hovered(value: boolean);
    /** isLayer */
    get isLayer(): boolean;
    /**
     * blockable
     * true이면 isLayer일 때도 findElementAt에서 hit test될 수 있다.
     */
    get blockable(): boolean;
    /** mouseX */
    get mouseX(): number;
    /** mouseY */
    get mouseY(): number;
    /** dom */
    get dom(): HTMLElement;
    /** doc */
    get doc(): Document;
    /** style */
    protected get style(): CSSStyleDeclaration;
    /** offsetWidth */
    get offsetWidth(): number;
    /** offsetHeight */
    get offsetHeight(): number;
    /** offsetSize */
    get offsetSize(): {
        width: number;
        height: number;
    };
    get printable(): boolean;
    isDom(dom: Element): boolean;
    containsDom(dom: Element): boolean;
    containsClass(className: string): boolean;
    canHover(): boolean;
    getChildren(): VisualElement$1[];
    getChild(index: number): VisualElement$1;
    indexOf(element: VisualElement$1): number;
    get firstChild(): VisualElement$1;
    contains(element: VisualElement$1): boolean;
    getAncestor(cls: any): VisualElement$1;
    addDom(dom: HTMLElement): void;
    addChild(child: VisualElement$1): boolean;
    protected _getParentDom(): HTMLElement;
    insertChild(index: number, child: VisualElement$1): boolean;
    removeChild(child: VisualElement$1): boolean;
    removeChildAt(index: number): VisualElement$1;
    removeLast(): VisualElement$1;
    clear(): boolean;
    hideAll(): void;
    invalidate(force?: boolean, invalidateChildren?: boolean): void;
    validate(): void;
    invalidateLayout(): void;
    getBounds(r?: Rectangle$1): Rectangle$1;
    getClientRect(r?: Rectangle$1): Rectangle$1;
    containsInBounds(x: number, y: number): boolean;
    containsInClient(x: number, y: number): boolean;
    parentToElement(parent: VisualElement$1, x: number, y: number): Point$1;
    translateBy(descendant: VisualElement$1, r?: Rectangle$1): Rectangle$1;
    topBy(parent: VisualElement$1, top: number): number;
    boundsBy(parent: VisualElement$1, r?: Rectangle$1): Rectangle$1;
    boundsByContainer(r?: Rectangle$1): Rectangle$1;
    pointByContainer(x: number, y: number): Point$1;
    containerToElement(x: number, y: number): Point$1;
    boundsByScreen(r?: Rectangle$1): Rectangle$1;
    offsetFrom(elt: VisualElement$1): Point$1;
    hitTest(x: number, y: number): boolean;
    findChildAt(x: number, y: number, hitTesting: boolean, blockLayer: boolean): VisualElement$1;
    findChildOf(dom: Element): VisualElement$1;
    move(x: number, y: number, draw?: boolean): void;
    moveBy(dx: number, dy: number, draw?: boolean): void;
    resize(width: number, height: number, draw?: boolean): void;
    resizeBy(dw: number, dh: number, draw?: boolean): void;
    setBounds(x: number, y: number, width: number, height: number): VisualElement$1;
    setBoundsI(x: number, y: number, width: number, height: number): VisualElement$1;
    setRect(r: IRect): VisualElement$1;
    setRectI(r: IRect): VisualElement$1;
    getBoundingRect(): any;
    draw(): void;
    drawRecursive(): void;
    resetSizeStyle(): void;
    getHtml(): string;
    setImportantStyle(style: string, value: any): void;
    isAncestorOf(child: VisualElement$1): boolean;
    isAncestorDomOf(child: HTMLElement, checkThis?: boolean): boolean;
    findDescendantOf(dom: HTMLElement): VisualElement$1;
    setStyles(styles: any): void;
    get scrollTop(): number;
    get scrollLeft(): number;
    scrollDom(x: number, y: number): void;
    setHint(title: string): void;
    setRotation(rotation: number): void;
    protected _isTesting(): boolean;
    protected _getElements(): VisualElement$1[];
    protected _createDom(doc: Document): HTMLElement;
    protected _getCssSelector(): string;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _addEventListeners(dom: HTMLElement): void;
    protected _removeEventListeners(dom: HTMLElement): void;
    private $_attached;
    protected _doAttached(parent: VisualElement$1): void;
    private $_detached;
    protected _doDetached(parent: VisualElement$1): void;
    protected _isEmptySize(): boolean;
    protected _setSizeStyle(css: CSSStyleDeclaration): void;
    setPrintStyles(): void;
    protected _getCssDisplay(): string;
    resetStyleName(): void;
    protected _setClassName(dom: HTMLElement): void;
    replaceDom(dom: HTMLElement): void;
    cloneNode(): Node;
    applyBounds(): void;
    protected _beforeDraw(dom: HTMLElement): void;
    protected _doDraw(dom: HTMLElement): void;
    protected _afterDraw(dom: HTMLElement): void;
    protected _hoverChanged(): void;
    protected _visibleChanged(): void;
    private sizeChanged;
    protected _doSizeChanged(): void;
}
/** @internal */
declare class LayerElement$1 extends VisualElement$1 {
    get isLayer(): boolean;
    protected _doDraw(element: HTMLElement): void;
}

/**
 * Property 모델 구성 요소.
 */
declare abstract class PropertyItem extends Base$1 {
    private _prop;
    private _group;
    constructor(prop: IPropInfo);
    get group(): PropertyGroup;
    get prop(): IPropInfo;
    get name(): string;
    get label(): string;
    get domain(): any[];
    get parent(): any;
    isVisible(source: IPropertySource): boolean;
    isReadOnly(source: IPropertySource): boolean;
    getValue(source: IPropertySource): any;
    setValue(source: IPropertySource, value: any): void;
    setValues(sources: IPropertySource[], value: any): void;
    hasColor(): boolean;
}
declare class PropertyGroup extends Base$1 {
    private _label;
    private _items;
    private _pool;
    source: IPropertySource;
    constructor(label: string);
    get label(): string;
    get count(): number;
    get(index: number): PropertyItem;
    borrow(info: IPropInfo): PropertyItem;
    add(item: PropertyItem): void;
    clear(): void;
}
/**
 * Value property base.
 */
declare abstract class ValueProperty extends PropertyItem {
    private _defaultValue;
    constructor(prop: IPropInfo);
    /**
     * 기본값.
     */
    get defaultValue(): any;
    set defaultValue(value: any);
}
/**
 * String property.
 */
declare class StringProperty extends ValueProperty {
    static readonly $_ctor: string;
    constructor(prop: IPropInfo);
}
/**
 * 참조 항목 list를 갖는 property.
 */
declare class ListableProperty extends StringProperty {
    static readonly $_ctor: string;
    constructor(prop: IPropInfo);
}

/**
 */
declare class PageItemContainer extends BoundedContainer {
    static readonly $_ctor: string;
    private _label;
    constructor(name: string, label: string);
    get outlineLabel(): string;
    get isArray(): boolean;
    canResize(dir: ResizeDirection): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}

declare enum BoxItemsAlign {
    START = "start",
    MIDDLE = "middle",
    END = "end"
}
declare abstract class BoxContainer extends ReportGroupItem {
    static readonly PROP_ITEMS_ALIGN = "itemsAlign";
    static readonly PROP_ITEM_GAP = "itemGap";
    static readonly PROP_OVERFLOW = "overflow";
    static readonly PROPINFOS: IPropInfo[];
    static readonly STYLE_PROPS: string[];
    private _itemsAlign;
    private _itemGap;
    private _overflow;
    private _itemGapDim;
    constructor(name: string);
    /**
     */
    get itemsAlign(): BoxItemsAlign;
    set itemsAlign(value: BoxItemsAlign);
    /**
     */
    get itemGap(): string | number;
    set itemGap(value: string | number);
    /**
     * true로 설정되면 자식이 넘칠 수 있다.
     * 특히, table을 자식으로 갖는 경우 true로 설정해야 우측 끝이 표시되는 경우가 있을 수 있다.
     */
    get overflow(): boolean;
    set overflow(value: boolean);
    getItemGap(domain: number): number;
    /**
     * @internal
     * ReportPage에서 bodyItems를 통해 호출한다.
     */
    loadProps(src: any): void;
    protected _datable(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    canAlign(child: ReportItem): boolean;
    canAdoptDragSource(source: any): boolean;
}
/**
 * 수직으로 자식 item들을 배치한다.
 * Html flex box를 활용한다.
 */
declare class ColumnBoxContainer extends BoxContainer {
    static readonly CHILD_PROPS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Column Box";
    private _child_left;
    private _child_right;
    constructor(name: string);
    /**
     * left
     */
    getLeftOf(item: ReportItem): number | string;
    setLeftOf(item: ReportItem, value: number | string): void;
    /**
     * right
     */
    getRightOf(item: ReportItem): number | string;
    setRightOf(item: ReportItem, value: number | string): void;
    getSaveType(): string;
    get outlineLabel(): string;
    get pathLabel(): string;
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoadChild(child: ReportItem, src: any): void;
    canAlignTo(item: ReportPageItem, to: string): boolean;
    canResizeChild(item: ReportItem, dir: ResizeDirection): boolean;
}

/**
 * Edit command base.
 * 편집 행위 외에 다른 로직이 포함되지 않도록 한다.
 */
declare abstract class EditCommand$1 extends Base$1 {
    private _name;
    private _id;
    private _time;
    constructor(name: string);
    protected _doDispose(): void;
    /** name */
    get name(): string;
    /** id */
    get id(): number;
    /** time */
    get time(): Date;
    /** displayLabel */
    get displayLabel(): string;
    /** description */
    get description(): string;
    abstract get source(): any;
    abstract undo(): void;
    abstract redo(redoing: boolean): any;
    run(): any;
}
/**
 * Edit command stack owner spec.
 */
interface IEditCommandStackOwner {
    editCommandStackChanged(stack: EditCommandStack$1, cmd: EditCommand$1, undoable: boolean, redoable: boolean): void;
    editCommandStackDirtyChanged(stack: EditCommandStack$1): void;
}
/**
 * Edit command stack.
 * 커맨드는 반드시 이 객체를 통해서 실행되거나 undo 되어야 한다.
 */
declare class EditCommandStack$1 extends EventAware$1 {
    private _owner;
    private _commands;
    private _current;
    private _closed;
    private _undoing;
    private _redoing;
    constructor(owner: IEditCommandStackOwner);
    protected _doDispose(): void;
    /** owner */
    get owner(): IEditCommandStackOwner;
    /** length */
    get length(): number;
    /** current */
    get current(): number;
    /** empty */
    get empty(): boolean;
    /** canUndo */
    get canUndo(): boolean;
    /** canRedo */
    get canRedo(): boolean;
    /** undoing */
    get undoing(): boolean;
    /** redoing */
    get redoing(): boolean;
    /** dirty */
    get dirty(): boolean;
    get(index: number): EditCommand$1;
    undo(): boolean;
    redo(redoing?: boolean): boolean;
    execute(command: EditCommand$1): boolean;
    flush(): void;
    /**
     * 현 위치를 marking한다. dirty는 마지막 marking 시점과 다른 경우 true가 된다.
     */
    close(): void;
    getHistory(all?: boolean): EditCommand$1[];
    protected _changed(oldCurrent: number, cmd: EditCommand$1): void;
    private $_shrink;
}

/**
 * 리포트 페이지 모델. 하나 이상의 section들로 구성된다.
 *
 * 1. band는 body의 최상위 항목으로만 추가될 수 있다. 즉, 다른 항목의 자식이 될 수 없다.
 */
declare class ReportPage extends ReportGroupItem implements IEventAware {
    static readonly ITEM_ADDED = "onPageItemAdded";
    static readonly ITEMS_ADDED = "onPageItemsAdded";
    static readonly ITEM_REMOVED = "onPageItemRemoved";
    static readonly ITEMS_REMOVED = "onPageItemsRemoved";
    static readonly ITEM_CHANGED = "onPageItemChanged";
    static readonly COLLECTION_CHANGED = "onPageCollectionChanged";
    static readonly $_ctor: string;
    private _report;
    private _events;
    private _nameMap;
    private _reportHeader;
    private _reportFooter;
    private _pageHeader;
    private _pageFooter;
    private _body;
    private _backItems;
    private _frontItems;
    private _sections;
    saveTag: string;
    private _loading;
    private _removing;
    constructor(report: Report);
    addListener(listener: object): IEventAware;
    removeListener(listener: object): IEventAware;
    /**
     * report
     */
    get report(): Report;
    /**
     * reportHeader
     */
    get reportHeader(): ReportHeader;
    /**
     * reportFooter
     */
    get reportFooter(): ReportFooter;
    /**
     * pageHeader
     */
    get pageHeader(): PageHeader;
    /**
     * pageFooter
     */
    get pageFooter(): PageFooter;
    /**
     * body
     */
    get body(): PageBody;
    get backContainer(): PageItemContainer;
    /**
     * backItems
     */
    get backItems(): ReportItem[];
    get frontContainer(): PageItemContainer;
    /**
     * frontItems
     */
    get frontItems(): ReportItem[];
    /**
     * loading
     */
    get loading(): boolean;
    getItem(name: string): ReportItem;
    removeItems(commands: EditCommandStack$1, items: ReportPageItem[]): number;
    search(key: string, options: FindOptions, results: FindResult[]): void;
    get outlineLabel(): string;
    get pathLabel(): string;
    get page(): ReportPage;
    canMove(): boolean;
    getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    canDelete(): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _ignoreItems(): boolean;
    protected _doSave(target: object): void;
    canResize(dir: ResizeDirection): boolean;
    getAllItems(root?: ReportGroupItem, all?: boolean): ReportItem[];
    collectInvalids(report: Report, invalids: {
        item: ReportItem;
        reason: string;
    }[]): void;
    private $_itemAdded;
    private $_addItem;
    private $_itemsAdded;
    private $_itemRemoved;
    private $_removeItem;
    private $_itemsRemoved;
    private $_itemChanged;
    private $_collectionChanged;
    /**
     * ReportItem.name에서 호출한다.
     */
    private $_nameChanged;
    /**
     * Report.onDesignDataManagerNameChanged에서 호출한다.
     */
    private $_dataNameChanged;
    /**
     * Report.onDesignDataManagerFieldNameChanged 호출한다.
     */
    private $_dataFieldNameChanged;
    protected _fireItemAdded(item: ReportPageItem, index: number, silent: boolean): void;
    protected _fireItemsAdded(items: ReportPageItem[], index: number): void;
    protected _fireItemRemoved(item: ReportPageItem, oldParent: ReportGroupItem): void;
    protected _fireItemsRemoved(items: ReportPageItem[]): void;
    protected _fireItemChanged(item: ReportPageItem, prop: string, value: any, oldValue: any): void;
    protected _fireCollectionChanged(collection: ReportItemCollection<any>): void;
}
/**
 * Report header/footer, Page header/footer를 제외한 리포트 페이지 영역.
 */
declare class PageBody extends PageSection {
    static readonly $_ctor: string;
    private _backItems;
    private _frontItems;
    private _bodyItems;
    constructor();
    /**
     * backItems
     */
    get backItems(): ReportItem[];
    get backItemsContainer(): PageItemContainer;
    /**
     * frontItems
     */
    get frontItems(): ReportItem[];
    get frontItemsContainer(): PageItemContainer;
    /**
     * items
     */
    get bodyItems(): ReportItem[];
    get itemsContainer(): ColumnBoxContainer;
    get outlineLabel(): string;
    canParentOf(itemType: string): boolean;
    canResize(dir: ResizeDirection): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _loadItems(loader: IReportLoader, src: any): void;
    protected _ignoreItems(): boolean;
    protected _doSave(target: object): void;
    canRemove(item: ReportItem): boolean;
}

interface ISize {
    width: number;
    height: number;
}
/** @internal */
declare class Size$1 implements ISize {
    width: number;
    height: number;
    static readonly EMPTY: Size$1;
    static empty(): Size$1;
    static create(w?: number, h?: number): Size$1;
    constructor(width?: number, height?: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Size$1;
    equals(sz: Size$1): boolean;
    setEmpty(): Size$1;
    set(width: number, height: number): Size$1;
    round(): Size$1;
    toString(): string;
}

/**
 * Asset item base.
 */
declare abstract class AssetItem {
    name: string;
    data: string;
    parent: AssetGroup;
    description: string;
    tag: any;
    constructor(name: string, data: string);
    get isGroup(): boolean;
    save(target: any): any;
    protected _parsetData(data: string): void;
    protected _doSave(target: any): void;
}
/**
 * Image data url.
 */
declare class ImageAsset extends AssetItem {
    protected _doSave(target: any): void;
}
/**
 * Svg xml.
 */
declare class SvgAsset extends AssetItem {
    protected _doSave(target: any): void;
}
/**
 * Color palette
 */
declare class ColorPaletteAsset extends AssetItem {
    protected _parsetData(data: string): void;
    protected _doSave(target: any): void;
}
/**
 * Chartist Theme
 */
declare class ChartistThemeAsset extends AssetItem {
    theme: object;
    protected _parsetData(data: string): void;
    protected _doSave(target: any): void;
}
/**
 * Highchart Theme
 */
declare class HighchartThemeAsset extends AssetItem {
    theme: object;
    protected _parsetData(data: string): void;
    protected _doSave(target: any): void;
}
/**
 * Asset folder.
 */
declare class AssetGroup extends AssetItem {
    path: string;
    items: AssetItem[];
    constructor(name: string);
    get count(): number;
    get(name: string): AssetItem;
    save(target: object[]): void;
    indexOf(item: AssetItem): number;
    get isGroup(): boolean;
    $_findItem(path: string, groupOnly?: boolean): AssetItem;
}
/**
 * Asset 관리자.
 * 모든 asset의 name은 경로와 상관없이 유일해야 한다.
 * {
 *  'folder path': [asset items,...],
 *  'folder path': [asset items,...]
 * }
 *
 * 리포트에 저장되는 asset들 외에 application에서 제공하는 asset들(stock assets)이
 * application asset view에 표시되도록 하고,
 * 그 asset들이 report에 추가되면 자동으로 report에도 추가한다.
 */
declare class AssetManager extends EventAware$1 {
    private _root;
    private _nameMap;
    constructor();
    protected _doDispose(): void;
    /** root */
    get root(): AssetGroup;
    load(src: any): void;
    private $_collectGroups;
    save(target: object): void;
    private $_checkPath;
    get(name: string): AssetItem;
    getImage(name: string): string;
    getSvg(name: string): string;
    getPalette(name: string): ColorPaletteAsset;
    getChartist(name: string): ChartistThemeAsset;
    getHighchart(name: string): HighchartThemeAsset;
    findGroup(path: string): AssetGroup;
    forceGroup(path: string): AssetGroup;
    addGroup(parent: string | AssetGroup, group: string): AssetGroup;
    removeGroup(group: string | AssetGroup): boolean;
    add(group: string | AssetGroup, item: AssetItem): void;
    remove(item: AssetItem): void;
    addImage(group: string | AssetGroup, name: string, imageData: string): ImageAsset;
    addSvg(group: string | AssetGroup, name: string, svgData: string): SvgAsset;
    addPalette(group: string | AssetGroup, name: string, paletteData: string): ColorPaletteAsset;
    addCharitst(group: string | AssetGroup, name: string, themeData: string): ChartistThemeAsset;
    addHighchart(group: string | AssetGroup, name: string, themeData: string): HighchartThemeAsset;
    getTree(root?: string): object;
    private $_parseTree;
    getValidName(prefix: string): string;
    isValidName(name: string): boolean;
    private $_findGroup;
    private $_addGroup;
    private $_removeGroup;
    private $_addItem;
    private $_removeItem;
    private $_addImage;
    private $_addSvg;
    private $_addPalette;
    private $_addChartist;
    private $_addHighchart;
}

/** @internal */
declare class DatetimeReader {
    static readonly Formats: string[];
    static readonly Default: DatetimeReader;
    static initialize(): void;
    private _format;
    private _type;
    private _parser;
    constructor(format: string);
    /** format */
    get format(): string;
    set format(value: string);
    /** amText */
    get amText(): string;
    set amText(value: string);
    /** pmText */
    get pmText(): string;
    set pmText(value: string);
    /** baseYear */
    get baseYear(): number;
    set baseYear(value: number);
    toDate(value: string): Date;
    private parse;
}

/**@internal */
declare abstract class ExpressionRuntime$1 extends Base$1 {
    constructor();
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): void;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capital: boolean): any;
    evaluateFunc(idKey: number, param: string): any;
}
/**@internal */
declare abstract class ExpressionNode$1 {
    constructor();
    get value(): any;
    get asLiteral(): any;
    prepareValue(): void;
    getLiteral(): ExpressionNode$1;
    isIdentifier(value: any): boolean;
    abstract evaluate(runtime: ExpressionRuntime$1): any;
    toString(): string;
}

/**@internal */
declare class FieldValueRuntime extends ExpressionRuntime$1 {
    private _data;
    private _fieldMap;
    private _row;
    constructor();
    protected _doDispose(): void;
    prepare(data: BandData): FieldValueRuntime;
    setRow(row: number): FieldValueRuntime;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
    evaluateFunc(idKey: number, param: string): any;
}

interface IBandDataField {
    fieldName: string;
    dataType?: "text" | "number" | "bool" | "datetime";
    expression?: string;
    format?: string;
    description?: string;
    sample?: any;
    dateReader?: DatetimeReader;
    width?: number;
}
interface IBandRowGroup {
    parent?: IBandRowGroup;
    level: number;
    row: number;
    count: number;
    trows?: number;
    value?: any;
    children: IBandRowGroup[];
}
interface IBandRowGroupFooter {
    group: IBandRowGroup;
}
interface IBandData extends IReportData {
    fieldCount: number;
    rowCount: number;
    getField(index: number): IBandDataField;
    getFields(): IBandDataField[];
    getFieldByName(fieldName: string): IBandDataField;
    containsField(fieldName: string): boolean;
    getRowValue(row: number, field: string | number): any;
    getFieldValues(field: string | number): any[];
    equalValues(row: number, fields: string[], values: any[]): boolean;
    equalRows(row1: number, row2: number, fields?: string[]): boolean;
    groupBy(fields: string[], rows: number[]): (number | IBandRowGroup | IBandRowGroupFooter)[];
}
declare abstract class BandData extends ReportData$1 {
    protected _fields: IBandDataField[];
    protected _fieldMap: any;
    protected _calcFieldRuntime: FieldValueRuntime;
    constructor(name: string, fields: IBandDataField[], dp: IReportDataProvider);
    get fields(): IBandDataField[];
    get fieldCount(): number;
    abstract get rowCount(): number;
    getFields(): IBandDataField[];
    getField(index: number): IBandDataField;
    getFieldByName(fieldName: string): IBandDataField;
    getFieldIndex(field: string): number;
    containsField(fieldName: string): boolean;
    indexOfField(field: IBandDataField): number;
    setField(index: number, field: IBandDataField): void;
    getSaveFields(): IBandDataField[];
    getNextFieldName(prefix?: string): string;
    getFieldNames(): string[];
    addField(index: number, field: IBandDataField): boolean;
    removeField(field: IBandDataField): boolean;
    abstract getRowValue(row: number, field: string | number): any;
    groupBy(fields: string[], subRows?: number[]): (number | IBandRowGroup | IBandRowGroupFooter)[];
    readValue(field: IBandDataField, value: any): any;
    readRow(row: any): any;
    dateToStr(field: IBandDataField, v: Date): string;
    abstract getFieldValues(field: string | number, rows?: number[]): any[];
    get isBand(): boolean;
    preparePrint(ctx: PrintContext, design: boolean): void;
    protected _readRows(): void;
    protected _prepareCalcField(fields: IBandDataField[], fieldMap: any, calcField: IBandDataField, index: number, node: ExpressionNode$1): void;
}
/**
 * {}들의 배열.
 * values는 리포트에 저장하지 않는다.
 * 필요하다면 application이 별도로 관리한다. (파일로 저장/로드)
 * (필드.sample로 최초 한 행을 생성하고, 추후 다른 tool로 관리할 수 있도록 한다.)
 */
declare class BandArrayData extends BandData implements IBandData {
    private _values;
    private _sampleCount;
    constructor(name: string, fields: IBandDataField[], values: any[], sampleCount?: number, dp?: IReportDataProvider);
    get rowCount(): number;
    getRowValues(row: number): any;
    getValue(path: string): any;
    getRowValue(row: number, field: string | number): any;
    getFieldValues(field: string | number, rows?: number[]): any[];
    equalValues(row: number, fields: string[], values: any[]): boolean;
    equalRows(row1: number, row2: number, fields?: string[]): boolean;
    findRows(values: object): number[];
    get sample(): any[];
    getValues(): any[];
    setValues(vals: any[]): void;
    getSaveType(): string;
    getSaveValues(): any;
    private $_cloneRow;
    private $_prepareSample;
    protected _readRows(): void;
    protected _prepareCalcField(fields: IBandDataField[], fieldMap: any, calcField: IBandDataField, index: number, node: ExpressionNode$1): void;
}

/**
 * Design-time data provider
 */
declare class DesignDataManager extends EventAware$1 implements IReportDataProvider {
    static readonly DATA_ADDED = "onDesignDataManagerDataAdded";
    static readonly DATA_REMOVED = "onDesignDataManagerDataRemoved";
    static readonly DATA_UPDATED = "onDesignDataManagerDataUpdated";
    static readonly NAME_CHANGED = "onDesignDataManagerNameChanged";
    static readonly FIELD_NAME_CHANGED = "onDesignDataManagerFieldNameChanged";
    private _commands;
    private _dataMap;
    private _contextData;
    constructor(commands: EditCommandStack$1);
    protected _doDispose(): void;
    get designTime(): boolean;
    preparePrint(ctx: PrintContext): void;
    getAll(): IReportData[];
    getNames(): string[];
    get(name: string): IReportData;
    getContextValue(path: string): any;
    /**
     * @param path data name + "." + data path
     */
    getValue(path: string, row: number): any;
    getValueAt(data: string, path: string, row: number): any;
    getFieldValues(data: string, field: string, rows?: number[]): any[];
    addData(data: IReportData): boolean;
    removeData(data: string | IReportData): IReportData;
    dataNameChanged(data: IReportData, oldName: string): void;
    fieldNameChanged?(data: IReportData, newName: string, oldName: string): void;
    load(source: any): DesignDataManager;
    save(target: object): void;
    getFieldIndex(data: string, field: string): number;
    updateField(data: BandData, index: number, field: IBandDataField): void;
    addField(data: BandData, index: number, field: IBandDataField): void;
    removeField(data: BandData, field: IBandDataField): void;
    renameData(data: IReportData, newName: string): void;
    private $_register;
    private $_unregister;
    private $_fireDataAdded;
    private $_fireDataRemoved;
    private $_fireDataUpdated;
}

/**
 * TableBase가 자동 생성한다.
 * 자식 하나만 가질 수 있다.
 */
declare abstract class TableCellItem extends CellGroup {
    constructor(item: ReportItem);
    /**
     * table
     */
    get table(): TableBase;
    /**
     * col
     */
    get col(): number;
    /**
     * row
     */
    get row(): number;
    canChangeChildProp(item: ReportPageItem, prop: string, value: any): boolean;
}
/**
 * Table 행 모델.
 */
declare class TableRow extends ReportItemCollectionItem {
    static readonly PROP_HEIGHT = "height";
    private static readonly styleProps;
    static readonly PROPINFOS: IPropInfo[];
    private _height;
    private _index;
    private _heightDim;
    constructor(collection: TableRowCollection, src?: any);
    getEditProps(): IPropInfo[];
    getCollectionLabel(): string;
    /** table */
    get table(): TableBase;
    /** index */
    get index(): number;
    /**
     * height
     */
    get height(): string | number;
    set height(value: string | number);
    getHeight(bounds: number): number;
    get itemType(): string;
    get page(): ReportPage;
    get displayPath(): string;
    get collection(): TableRowCollection;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    canRemoveFrom(): boolean;
    canSelectedWith(other: ISelectionSource): boolean;
    protected _getStyleProps(): string[];
    protected _doLoad(src: any): void;
    protected _doSave(target: any): any;
}
/**
 * Table row object collection.
 */
declare class TableRowCollection extends ReportItemCollection<TableRow> {
    private _table;
    private _rows;
    private _heights;
    constructor(table?: TableBase);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    getSaveType(): string;
    get owner(): ReportItem;
    /** table */
    get table(): TableBase;
    /** count */
    get count(): number;
    set count(value: number);
    get items(): ReportPageItem[];
    load(src: any, count: number): number;
    save(target: any): void;
    get(index: number): TableRow;
    /**
     * i1과 i2에 위치한 아이템과 그 사이에 포함된 아이템들을 순서대로 배열로 리턴한다.
     */
    getRange(i1: number, i2: number): TableRow[];
    indexOf(row: TableRow): number;
    getHeights(): DimensionCollection;
    /**
     * @internal
     */
    add(row: TableRow | ConfigObject$1, index?: number): TableRow;
    /**
     * @internal
     */
    remove(index: number): boolean;
    /**
     * @internal
     */
    move(index: number, count: number, newRow: number): void;
    /**
     * 아래쪽 이웃 행의 높이를 줄이거나 늘이면서 행의 높이를 변경한다.
     */
    adjustHeights(row: number, rowPoints: number[], newSize: number): any[];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    protected _doMoveItem(from: number, to: number): boolean;
    private $_add;
    private $_invalidateRows;
    private $_rowChanged;
}
declare type TableCellStyleCallback = (ctx: PrintContext, cell: TableCell$1, row: number) => {
    [key: string]: string | undefined;
};
/**
 * Table cell model. {@link TableCellCollection} 구성 요소로 포함된다.
 */
declare class TableCell$1 extends ReportItemCollectionItem {
    static readonly PROP_COL = "col";
    static readonly PROP_ROW = "row";
    static readonly PROP_COLSPAN = "colspan";
    static readonly PROP_ROWSPAN = "rowspan";
    static readonly PROP_APPLY_END_STYLES = "applyEndStyles";
    static readonly PROP_ON_GET_STYLES = "onGetStyles";
    static readonly PROP_STYLE_CALLBACK = "styleCallback";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _colspan;
    private _rowspan;
    private _applyEndStyles;
    private _styleCallback;
    private _onGetStyles;
    private _row;
    private _col;
    private _styleCallbackFunc;
    private _styleCallbackDelegate;
    constructor(collection: TableCellCollection, row: number, col: number, src?: any);
    /** @internal */
    get outlineLabel(): string;
    getEditProps(): IPropInfo[];
    get table(): TableBase;
    get row(): number;
    get col(): number;
    get height(): number;
    get width(): number;
    get bottom(): number;
    get right(): number;
    get isSingle(): boolean;
    /**
     * col span
     */
    get colspan(): number;
    set colspan(value: number);
    /**
     * row span
     */
    get rowspan(): number;
    set rowspan(value: number);
    /**
     * true면 span 됐을 때 마지막 셀에 해당하는 tableRowStyles, tableColumnStyles를 적용한다.
     */
    get applyEndStyles(): boolean;
    set applyEndStyles(value: boolean);
    /** styleCallback */
    get styleCallback(): TableCellStyleCallback;
    set styleCallback(value: TableCellStyleCallback);
    /** onGetStyles */
    get onGetStyles(): string;
    set onGetStyles(value: string);
    adoptDragSource(source: any): IDropResult;
    get itemType(): string;
    get collection(): TableCellCollection;
    get page(): ReportPage;
    get displayPath(): string;
    get marqueeParent(): ReportItem;
    protected _getStyleProps(): string[];
    setProps(src: any): void;
    canSelectedWith(other: ISelectionSource): boolean;
    protected _doLoad(src: any): void;
    protected _doSave(target: any): void;
}
declare class TableSelection implements ISelectionSource {
    selectItem: TableCell$1;
    cols: number;
    rows: number;
    private _cell;
    constructor(cell: TableCell$1, cols: number, rows: number);
    get table(): TableBase;
    get cell(): TableCell$1;
    get col(): number;
    get row(): number;
    get right(): number;
    get bottom(): number;
    canSelectedWith(other: ISelectionSource): boolean;
    contains(row: number, col: number): boolean;
    containsCell(cell: TableCell$1): boolean;
    isSingle(ignoreHiddens: boolean): boolean;
    getCells(ignoreHiddens: boolean): TableCell$1[];
    resizeTo(cell: TableCell$1): boolean;
    resizeBy(dx: number, dy: number): boolean;
    equals(cell: TableCell$1): boolean;
}
/**
 * @internal
 * 테이블 셀 모델인 TabelCell들의 집합.
 */
declare class TableCellCollection extends ReportItemCollection<TableCell$1> {
    private _table;
    private _cells;
    private _vcells;
    constructor(table?: TableBase);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    getSaveType(): string;
    isCollectionProp(): boolean;
    get owner(): ReportItem;
    /** table */
    get table(): TableBase;
    /** count */
    get count(): number;
    get items(): ReportPageItem[];
    /** rowCount */
    get rowCount(): number;
    /** colCount */
    get colCount(): number;
    getColCount(row: number): number;
    get(index: number): TableCell$1;
    getAt(row: number, col: number): TableCell$1;
    indexOf(item: TableCell$1): number;
    getRectangle(from: TableCell$1, to: TableCell$1): IRect;
    getRectangleCells(from: TableCell$1, to: TableCell$1, ignoreHiddens?: boolean): TableCell$1[];
    /**
     * table rowCount, colCount 변경 시 table에서도 호출한다.
     * rowCount, colCount가 줄어들어도 기존 cell들은 제거하지 않는다.
     */
    prepareCells(): void;
    load(src: any): void;
    save(target: any): void;
    resetVisibles(): void;
    /**
     * @internal
     * 모든 셀들의 속성들과 스타일값들을 저장한다.
     * restoreCells()로 복원시킬 수 있다.
     */
    saveCells(): any[][];
    /**
     * @internal
     * saveCells()로 저장된 모든 셀들의 속성들과 스타일값들로 재설정한다.
     * RemoveTableRowCommand 참조.
     */
    restoreCells(src: any[][]): void;
    /**
     * @internal
     * cell들은 남겨두고 row 이전 cell들의 span값들만 조정한다.
     * RemoveTableRowCommand 참조.
     */
    truncateRow(row: number): any[][];
    /**
     * @internal
     * cell들은 남겨두고 col 이전 cell들의 span값들만 조정한다.
     */
    truncateCol(col: number): any[][];
    removeRow(row: number): any[][];
    removeRows(row: number, count: number): any[][];
    addRow(row: number): any[][];
    removeCol(col: number): any[][];
    removeCols(col: number, count: number): any[][];
    addCol(col: number): any[][];
    private $_resetPositions;
    /**
     * 셀들에 설정된 스타일등을 유지하기 위해 cell 들의 위치를 변경 시킨다.
     * 병합된 셀을 분리해서 이동할 수 없다. 즉, span 상태는 변경되지 않는다.
     */
    moveRows(row: number, count: number, newRow: number): any;
    /**
     * 셀들에 설정된 스타일등을 유지하기 위해 cell 들의 위치를 변경 시킨다.
     * 병합된 셀을 분리해서 이동할 수 없다. 즉, span 상태는 변경되지 않는다.
     */
    moveCols(col: number, count: number, newCol: number): any;
    /**
     * 지정한 범위와 범위에 속한 기존 병합을 모두 포함하는 병합 범위 리턴.
     */
    getMergeBounds(r1: number, c1: number, r2: number, c2: number): TableBounds;
    mergeBoundsOf(sel: TableSelection): TableBounds;
    merge(r1: number, c1: number, r2: number, c2: number): any[][];
    mergeSelection(sel: TableSelection): any[][];
    unmerge(cell: TableCell$1): any[][];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    protected _doMoveItem(from: number, to: number): boolean;
    protected _createCell(row: number, col: number): TableCell$1;
}
declare type TableBounds = {
    r1: number;
    c1: number;
    r2: number;
    c2: number;
};
declare type TableCellSpan = {
    r: number;
    c: number;
    v: TableCell$1;
    m: TableCellItem;
};
/**
 * 자식 item들을 TableCellItem에 추가해서 배치한다.
 * 페이지를 넘어갈 수 없다.
 * // TODO: columns(컬럼 단위 정보, width, style...), rows(행 단위 정보, height, style...) 추가할 것!
 */
declare abstract class TableBase extends CellContainer {
    static readonly PROP_ROW_COUNT = "rowCount";
    static readonly PROP_MIN_ROW_HEIGHT = "minRowHeight";
    static readonly PROP_ROWS = "rows";
    static readonly PROP_TABLE_CELL_STYLES = "cellStyles";
    static readonly PROP_CELL_LAYOUT = "table_cell_layout";
    static readonly PROP_FIXED = "fixed";
    static readonly PROP_TABLE_COL = "col";
    static readonly PROP_TABLE_ROW = "row";
    static readonly PROPINFOS: IPropInfo[];
    static readonly TABLE_CHILD_PROPS: IPropInfo[];
    private static readonly TABLE_STYLES;
    private static readonly CELL_STYLES;
    private _rowCount;
    private _minRowHeight;
    onCellChanged: (item: ReportItem, prop: string, oldValue: any) => void;
    private _fixed;
    private _cellStyles;
    private _rows;
    private _cells;
    private _cellMap;
    private _spans;
    private _minRowHeightDim;
    private _focus;
    private _spanDirty;
    private _itemDirty;
    constructor(name: string);
    protected _createCells(): TableCellCollection;
    getSubStyleProps(prop: string): IPropInfo[];
    protected _getSubStyle(prop: string, style: string): any;
    protected _setSubStyle(prop: string, style: string, value: any): void;
    get outlineItems(): IOutlineSource[];
    /** colCount */
    abstract get colCount(): number;
    /** rowCount */
    get rowCount(): number;
    set rowCount(value: number);
    /** rows */
    get rows(): TableRowCollection;
    /** cells */
    get cells(): TableCellCollection;
    /**
     * minimum table row height
     */
    get minRowHeight(): string;
    set minRowHeight(value: string);
    /** cellStyles */
    get cellStyles(): Styles;
    set cellStyles(value: Styles);
    /**
     * true이면 내부 table element의 너비를 '100%'로 하지 않고,
     * colGroup 전체 너비로 설정한다.
     * 즉, 모든 컬럼들의 너비가 모두 고정인 경우, table의 너비가 부도 div 대신 컬럼 너비들의 합이 된다.
     */
    get fixed(): boolean;
    set fixed(value: boolean);
    abstract getCellWidths(): DimensionCollection;
    abstract getColumn(col: number): TableColumnBase;
    getRow(index: number): TableRow;
    getRowHeights(): DimensionCollection;
    getCell(row: number, col: number): TableCell$1;
    getCellItemAt(row: number, col: number): TableCellItem;
    getCellItem(cell: TableCell$1): TableCellItem;
    isHiddenAt(row: number, col: number): boolean;
    isHiddenCell(cell: TableCell$1): boolean;
    getHeadCell(cell: TableCell$1): TableCell$1;
    getLeftCol(cell: TableCell$1): number;
    getTopRow(cell: TableCell$1): number;
    getMinRowHeight(): number;
    getColItems(col: number, same?: boolean): ReportItem[];
    getRowItems(row: number, same?: boolean): ReportItem[];
    getRowItemsFrom(rowFrom: number): ReportItem[];
    getRectItems(r1: number, c1: number, r2: number, c2: number, exceptFirst?: boolean): ReportItem[];
    prepareLayout(): TableCellSpan[][];
    setFocus(focus: {
        col: number;
        row: number;
    }): void;
    /**
     * @internal
     * 이 함수를 통해 행을 삭제하면 undo할 수 없다.
     * 대신 {@link Report.removeItem}를 호출해야 한다.
     */
    removeRow(row: number | TableRow): void;
    /**
     * @internal
     * 이 함수를 통해 행을 추가하면 undo할 수 없다.
     * 대신 {@link Report.addTableRow}를 호출해야 한다.
     */
    addRow(index: number, row: TableRow): TableRow;
    /**
     * @internal
     * 옮기려는 행들에 범위를 벗어난 셀 병합이 존재하면 이동할 수 없다.
     * 옮기려는 위치에 병합된 셀의 끝이 아닌 것이 포함되면 그 자리로 이동시킬 수 없다.
     */
    canMoveRows(row: number, count: number, newRow: number, alert?: boolean): boolean;
    getNearestMovableRow(row: number, count: number, delta: number): number;
    moveRows(row: number, count: number, newRow: number, force?: boolean): boolean;
    /**
     * @internal
     * 옮기려는 컬럼셀들에 범위를 벗어난 셀 병합이 존재하면 이동할 수 없다.
     * 옮기려는 위치에 병합된 셀의 끝이 아닌 것이 포함되면 그 자리로 이동시킬 수 없다.
     */
    canMoveCols(col: number, count: number, newCol: number, alert?: boolean): boolean;
    getNearestMovableColumn(col: number, count: number, delta: number): number;
    /**
     * @internal
     * For debugging.
     */
    checkCounts(): void;
    getSelection(cell: TableCell$1): TableSelection;
    /**
     * 가장 상단의 item만 보존된다.
     */
    mergeCells(r1: number, c1: number, r2: number, c2: number): void;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: any): void;
    protected _doSaveItems(target: any[], items: ReportItem[]): void;
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _doLoadChild(child: ReportItem, src: any): void;
    protected abstract _createCell(item: ReportItem): TableCellItem;
    protected _prepareCellGroup(item: ReportItem): CellGroup;
    protected _unprepareCellGroup(item: ReportItem): CellGroup;
    protected _doItemAdded(item: ReportItem, index: number): void;
    protected _doItemRemoved(item: ReportItem, index: number): void;
    protected _doItemChanged(item: ReportItem, prop: string, value: any, oldValue: any): void;
    isAncestorOf(item: ReportPageItem): boolean;
    protected _createRows(): TableRowCollection;
    protected _spanChanged(cell: TableCell$1): void;
    protected _resetCells(): void;
    protected _removeCols(index: number, count: number): void;
    protected _addCols(col: number, count: number): void;
    protected _moveCols(col: number, count: number, newCol: number): void;
    protected _removeRows(index: number, count: number): void;
    protected _addRows(index: number, count: number): void;
    protected _moveRows(row: number, count: number, newRow: number): void;
    canChangeChildProp(item: ReportPageItem, prop: string, value: any): boolean;
    private $_rowChanged;
    private $_resetSpans;
    protected _addColumn(index: number): void;
    protected _removeColumn(col: number): void;
}
declare abstract class TableColumnBase extends ReportItemCollectionItem {
    static readonly PROP_WIDTH = "width";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _width;
    private _index;
    private _widthDim;
    constructor(collection: ReportItemCollection<any>, src?: any);
    getEditProps(): IPropInfo[];
    getCollectionLabel(): string;
    /** index */
    get index(): number;
    /**
     * width
     */
    get width(): ValueString;
    set width(value: ValueString);
    getWidth(bounds: number): number;
    get itemType(): string;
    get page(): ReportPage;
    canSelectedWith(other: ISelectionSource): boolean;
    protected _getStyleProps(): string[];
    protected _doLoad(src: any): void;
    protected _doSave(target: any): any;
    protected abstract _changed(prop: string, newValue: any, oldValue: any): void;
}
declare abstract class TableColumnCollectionBase<T extends ReportGroupItem, C extends TableColumnBase> extends ReportItemCollection<C> {
    private _owner;
    private _columns;
    private _widths;
    constructor(owner?: T);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    getSaveType(): string;
    /** owner */
    get owner(): T;
    /** count */
    get count(): number;
    set count(value: number);
    get items(): ReportPageItem[];
    /** columns */
    get columns(): C[];
    load(src: any, count: number): number;
    save(target: any): void;
    get(index: number): C;
    /**
     * i1과 i2에 위치한 아이템과 그 사이에 포함된 아이템들을 순서대로 배열로 리턴한다.
     */
    getRange(i1: number, i2: number): C[];
    indexOf(column: C): number;
    /**
     * 컬럼 너비들을 절대/상대 값으로 지정한다.
     * 지정하지 않은 컬럼 너비는 컬럼에 속한 셀들을 계산한 최대 너비로 설정된다.
     * 상대 너비는 '%'로 지정하고, 부모에서 절대 너비를 제외한 나머지 너비를 기준으로
     * 상대 너비를 모두 더한 값에 대한 비율로 설정된다.
     * 너비 합계가 부모 너비보다 클 수 있다.
     */
    getWidths(): DimensionCollection;
    add(column: C | ConfigObject$1, index?: number): C;
    /**
     * @internal
     */
    remove(index: number): boolean;
    /**
     * @internal
     */
    clear(): boolean;
    /**
     * @internal
     */
    move(index: number, count: number, newIndex: number): void;
    /**
     * 오른쪽 이웃 컬럼의 너비를 줄이거나 늘이면서 컬럼의 너비를 변경한다.
     */
    adjustWidths(col: number, colPoints: number[], newSize: number): any[];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    protected _doMoveItem(from: number, to: number): boolean;
    protected abstract _createColumn(src: any): C;
    private $_add;
    private $_resetColumns;
    private $_columnChanged;
}

/**@internal */
declare class DataBandSummaryRuntime extends ExpressionRuntime$1 {
    private _band;
    private _data;
    private _master;
    private _fieldMap;
    private _idxMap;
    private _masterFieldMap;
    private _masterIdxMap;
    private _group;
    private _rows;
    private _masterRow;
    private _rowCount;
    constructor(band: DataBand);
    protected _doDispose(): void;
    prepare(data: BandData, master: IBandData): DataBandSummaryRuntime;
    setGroup(group: IBandRowGroup): DataBandSummaryRuntime;
    setRows(rows: number[], masterRow?: number): DataBandSummaryRuntime;
    setRowCount(count: number): DataBandSummaryRuntime;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateFunc(idKey: number, param: string): any;
    private $_getRows;
}

/**
 * DataBand row group base.
 */
declare abstract class DataBandRowGroup extends ReportGroupItem {
    static readonly PROP_FIELD = "field";
    static readonly PROPINFOS: IPropInfo[];
    private _field;
    constructor(name: string);
    get outlineLabel(): string;
    canRemoveFrom(): boolean;
    getEditProps(): IPropInfo[];
    /** field */
    get field(): string;
    set field(value: string);
    get pathLabel(): string;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getPropDomain(prop: IPropInfo): any[];
}
/**
 * Data band base class.
 *
 * [제한 사항]
 * 1. detail band는 multi columns 불가. (TODO: master가 multi column이 아니면 가능하지 않을까?)
 */
declare abstract class DataBand extends ReportGroupItem {
    static readonly PROP_DATA_BAND_MASTER_FIELDS = "masterFields";
    static readonly PROP_DATA_BAND_KEY_FIELDS = "keyFields";
    static readonly PROP_DATA_BAND_ROWS_PER_MASTER = "rowsPerMaster";
    static readonly PROP_DATA_BAND_SECTION_COUNT = "sectionCount";
    static readonly PROP_DATA_BAND_SECTIONLAYOUT = "sectionLayout";
    static readonly PROP_DATA_BAND_SECTION_GAP = "sectionGap";
    static readonly PROP_DATA_BAND_MAX_ROW_COUNT = "maxRowCount";
    static readonly PROP_DATA_BAND_ROWS_PER_PAGE = "rowsPerPage";
    static readonly PROP_DATA_BAND_MAX_ROWS_PER_PAGE = "maxRowsPerPage";
    static readonly PROP_DATA_BAND_REPEAT_MASTER_ROW = "repeatMasterRow";
    static readonly PROP_DATA_BAND_REPEAT_DETAIL_HEADER = "repeatDetailHeader";
    static readonly PROP_DATA_BAND_REPEAT_DETAIL_FOOTER = "repeatDetailFooter";
    static readonly PROP_DATA_BAND_END_ROW_COUNT = "endRowCount";
    static readonly PROP_DATA_BAND_MAX_END_ROW_COUNT = "maxEndRowCount";
    static readonly PROP_DATA_BAND_END_ROW_MESSAGE = "endRowMessage";
    static readonly PROP_DATA_BAND_ALWAYS_HEADER = "alwaysHeader";
    static readonly PROPINFOS: IPropInfo[];
    private _sectionCount;
    private _sectionLayout;
    private _sectionGap;
    private _maxRowCount;
    private _rowsPerPage;
    private _maxRowsPerPage;
    private _endRowCount;
    private _maxEndRowCount;
    private _endRowMessage;
    private _masterFields;
    private _keyFields;
    private _rowsPerMaster;
    private _repeatMastreRow;
    private _repeatDetailHeader;
    private _repeatDetailFooter;
    private _alwaysHeader;
    private _detail;
    private _master;
    private _keyFlds;
    private _masterFlds;
    pageNo: number;
    prevHead: boolean;
    prevIndex: number;
    rowIndex: number;
    detailRows: number;
    masterValues: any;
    private _dataObj;
    private _designData;
    private _fieldSummary;
    private _summaryRuntime;
    constructor(name: string);
    get dataObj(): IBandData;
    get designData(): IBandData;
    /**
     * detail band.
     */
    get detail(): DataBandCollection;
    /**
     * detail band인가?
     */
    get isDetail(): boolean;
    /**
     * master band.
     */
    get master(): DataBand;
    /**
     * band level.
     * 최상위 band이면 0.
     */
    get bandLevel(): number;
    /**
     * section count
     */
    get sectionCount(): number;
    set sectionCount(value: number);
    /**
     * section layout
     */
    get sectionLayout(): BandSectionLayout;
    set sectionLayout(value: BandSectionLayout);
    /**
     * section gap
     */
    get sectionGap(): number;
    set sectionGap(value: number);
    /**
     * 최대 출력 행 수.
     * 0보다 큰 값으로 설정하면,
     * 디테일 밴드일 경우 해당 마스터 내에서 최대 행수이다.
     * rowsPerMaster로 표시할 디테일 행들을 설정하는 경우 이 속성을 지정할 필요가 없다(?)
     */
    get maxRowCount(): number;
    set maxRowCount(value: number);
    /**
     * 0보다 큰 값으로 설정하면,
     * 지정한 행 수만큼 최대 출력하고 다음 페이지로 넘어간다.
     * 또, 디테일인 경우 마스터행에 대한 디테일행들이 모두 출력되면 다음 페이지로 넘어간다.
     * 지정한 행 수만큼 한 페이지에 출력하지 못하면,
     * 다음 페이지에 나머지를 출력하고 페이지를 넘긴다.
     * 페이지 중단 없이 이어서 출력하려면 {@link maxRowsPerPage}로 설정한다.
     */
    get rowsPerPage(): number;
    set rowsPerPage(value: number);
    /**
     * 0보다 큰 값으로 설정하면,
     * 지정한 행 수만큼 최대 출력하고 다음 페이지로 넘어간다.
     * 또, 디테일인 경우 마스터행에 대한 디테일행들이 모두 출력되면 다음 페이지로 넘어간다.
     * 지정한 행 수만큼 한 페이지에 출력하지 못하면 중단하고
     * 다음 페이지에서 다음 행부터 다시 출력한다.
     * {@link rowsPerPage}가 0보다 큰 값으로 설정되면 이 속성은 무시된다.
     */
    get maxRowsPerPage(): number;
    set maxRowsPerPage(value: number);
    /**
     * 데이터행 수와 상관없이 마지막 페이지에 표시돼야 할 행수.
     * 0보다 큰 값으로 설정하면,
     * 실제 데이터행 이후 행은 빈 행으로 표시된다.
     * 마지막 페이지에 적용된다.
     * 마지막 페이지에 빈 행을 모두 출력할 수 없는 경우,
     * 다음 페이지에 나머지 빈 행을 출력하고 페이지를 넘긴다.
     * 페이지 중단 없이 남은 영역만 빈 행으로 채우려면 {@link maxEndRowCount}를 설정한다.
     *
     * 그룹 설정과 같이 적용할 수 없다. 즉, 그룹이 설정되면 이 속성은 무시된다.
     */
    get endRowCount(): number;
    set endRowCount(value: number);
    /**
     * 데이터행 수와 상관없이 마지막 페이지에 표시돼야 할 행수.
     * 0보다 큰 값으로 설정하면,
     * 실제 데이터행 이후 행은 빈 행으로 표시된다.
     * 마지막 페이지에 적용된다.
     * 마지막 페이지에 출력할 수 있는 만큼만 빈 행을 출력한다.
     * {@link endRowCount}가 0보다 큰 값으로 설정되면 이 속성은 무시된다.
     *
     * 그룹 설정과 같이 적용할 수 없다. 즉, 그룹이 설정되면 이 속성은 무시된다.
     */
    get maxEndRowCount(): number;
    set maxEndRowCount(value: number);
    /**
     * 실제 데이터행 수가 {@link endRowCount} 보다 적을 때,
     * 마자막 data 행 아래에 표시할 메시지.
     */
    get endRowMessage(): string;
    set endRowMessage(value: string);
    /**
     * keyFields에 대응하는 master band data의 필드 목록.
     * 지정하지 않으면 keyFields와 동일한 필드 목록이 사용된다.
     * 디테일밴드에 지정.
     */
    get masterFields(): string;
    set masterFields(value: string);
    /**
     * master band의 필드에 대응하는 필드 목록.
     * 이 필드들의 값이 master행의 값들과 동일한 행들이 master 행 다음에 출력된다.
     * 디테일밴드에 지정.
     */
    get keyFields(): string;
    set keyFields(value: string);
    /**
     * keyFields를 지정하지 않고, 0보다 큰 값으로 출력할 디테일 행수를 지정한다.
     * 이 밴드(master band) 행마다 출력해야할 최대 디테일 밴드 행 수.
     * keyFields가 지정되면 이 속성은 무시된다.
     * 디테일밴드에 지정.
     */
    get rowsPerMaster(): number;
    set rowsPerMaster(value: number);
    /**
     * 디테일이 페이지를 넘어가는 경우 매 페이지마다 마스터 행을 출력할 지 여부.
     * 마스터밴드에 지정.
     */
    get repeatMasterRow(): boolean;
    set repeatMasterRow(value: boolean);
    /**
     * 디테일이 페이지를 넘어가는 경우 이어지는 페이지들에 디테일밴드 header를 출력할 지 여부.
     * 디테일이 시작되는 페이지에는 이 속성과 관련 없이 출력된다.
     * 디테일밴드에 지정한다.
     */
    get repeatDetailHeader(): boolean;
    set repeatDetailHeader(value: boolean);
    /**
     * 디테일이 페이지를 넘어가는 경우 디테일 완료 이전 페이지들에 디테일밴드 footer를 출력할 지 여부.
     * 디테일이 완료되는 페이지에는 이 속성과 관련 없이 출력된다.
     * 디테일밴드에 지정한다.
     */
    get repeatDetailFooter(): boolean;
    set repeatDetailFooter(value: boolean);
    /**
     * true면 데이터행 없이 footer만 표시되는 경우에도 header를 표시한다.
     */
    get alwaysHeader(): boolean;
    set alwaysHeader(value: boolean);
    /**
     * summary runtime
     */
    get summaryRuntime(): DataBandSummaryRuntime;
    prepareIndices(ctx: PrintContext): void;
    protected abstract _doPrepareIndices(ctx: PrintContext): void;
    getColPoints(w: number, x?: number): number[];
    getColWidth(w: number): number;
    getValues(ctx: PrintContext, row: number, fields: string[]): any[];
    protected _selectRow(data: IBandData, row: number, idx: number): boolean;
    abstract getNextDetailRows(ctx: PrintContext): number[];
    protected _getNextDetailRows(ctx: PrintContext, from: number): number[];
    abstract skipDetailRows(ctx: PrintContext): void;
    protected _skipDetailRows(ctx: PrintContext, from: number): number;
    getRowsPerPage(): {
        rowsPerPage: number;
        breakRowsPerPage: boolean;
    };
    getEndRowCount(endMessage?: number): {
        endRowCount: number;
        stopEndRow: boolean;
    };
    getCount(field: string, count: number, rows?: number[]): number;
    getVCount(field: string, count: number, rows?: number[]): number;
    getSum(field: string, count: number, rows?: number[]): number;
    getMin(field: string, count: number, rows?: number[]): number;
    getMax(field: string, count: number, rows?: number[]): number;
    getAvg(field: string, count: number, rows?: number[]): number;
    abstract containsInSection(item: ReportItem): boolean;
    get designLevel(): number;
    get dataDominant(): boolean;
    protected _datable(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    canAddTo(group: ReportGroupItem): boolean;
    canResize(dir: ResizeDirection): boolean;
    canPageBreak(): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _doPreparePrint(ctx: PrintContext): void;
    clearSummary(): void;
    /**
     * @Test
     */
    testPrepare(data: IBandData): void;
    private $_getSummary;
    private $_calcSummary;
    private $_getVCount;
    private $_getSum;
    private $_getMin;
    private $_getMax;
}
/**
 */
declare class DataBandCollection extends ReportGroupItem {
    static readonly PROPINFOS: IPropInfo[];
    private _owner;
    private _label;
    constructor(owner: DataBand, label: string);
    /** owner */
    get owner(): DataBand;
    getSaveType(): string;
    get outlineLabel(): string;
    get designLevel(): number;
    get marqueeParent(): ReportItem;
    canAdd(item: ReportItem): boolean;
    canContainsBand(): boolean;
    protected _doItemAdded(item: ReportItem, index: number): void;
}

declare class TableBandColumn extends TableColumnBase {
    constructor(collection: TableBandColumnCollection, src?: any);
    getCollectionLabel(): string;
    /** band */
    get band(): TableBand;
    get displayPath(): string;
    get collection(): TableBandColumnCollection;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    canRemoveFrom(): boolean;
    protected _changed(prop: string, newValue: any, oldValue: any): void;
}
declare class TableBandColumnCollection extends TableColumnCollectionBase<TableBand, TableBandColumn> {
    constructor(band?: TableBand);
    /** band */
    get band(): TableBand;
    protected _createColumn(src: any): TableBandColumn;
}
/**
 * TableBand의 셀 모델.
 * span할 수 있다.
 * 자식 하나만 가질 수 있다.
 */
declare class TableBandCellItem extends TableCellItem {
    static readonly $_ctor: string;
    constructor(item: ReportItem);
}
/**
 * TableBand의 행 영역 모델.
 * TableBandCellItem들로 구성된다.
 * field item들은 TableBand에 설정된 file item 설정에 따라 자동으로 추가한다.(?)
 */
declare abstract class TableBandSection extends TableBase {
    static readonly PROP_LINES = "lines";
    static readonly STYLE_PROPS: string[];
    static readonly DEFAULT_ROWS = 1;
    private _band;
    /** @internal */
    removedCells: TableCell$1[];
    constructor(band: TableBand);
    /** band */
    get band(): TableBand;
    protected _getStyleProps(): string[];
    needDesignWidth(): boolean;
    needDesignHeight(): boolean;
    canResize(dir: ResizeDirection): boolean;
    get marqueeParent(): ReportItem;
    get colCount(): number;
    getColumn(col: number): TableColumnBase;
    getCellWidths(): DimensionCollection;
    protected _createCell(item: ReportItem): TableBandCellItem;
    isAncestorOf(item: ReportPageItem): boolean;
}
declare class TableBandHeader extends TableBandSection {
    static readonly PROP_TABLE_BAND_HEADER_REPEAT = "repeat";
    static readonly $_ctor: string;
    private _repeat;
    private _pageSection;
    constructor(band: TableBand, pageSection?: boolean);
    /** repeat */
    get repeat(): boolean;
    set repeat(value: boolean);
    get outlineLabel(): string;
    get pathLabel(): string;
}
declare class TableBandFooter extends TableBandSection {
    static readonly PROP_ATTACH_TO_BODY = "attachToBody";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    private _attachToBody;
    private _pageSection;
    constructor(band: TableBand, pageSection?: boolean);
    /**
     * true면 multi column 모드일 때 마지막 컬럼의 마지막 행에 붙여서 출력하고,
     * false면 모든 컬럼의 가장 아래쪽에 붙여서 출력한다.
     *
     * @default false
     */
    get attachToBody(): boolean;
    set attachToBody(value: boolean);
    get outlineLabel(): string;
    get pathLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * Data row template in table band.
 * 하나 이상의 table row로 구성할 수 있다.
 */
declare class TableBandDataRow extends TableBandSection {
    static readonly PROP_EQUAL_BLANK = "equalBlank";
    static readonly PROP_BLANK_FIELDS = "blankFields";
    static readonly PROP_MERGED_IN_GROUP = "mergedInGroup";
    static readonly CHILD_PROPS: IPropInfo[];
    static readonly $_ctor: string;
    private _blankItems;
    masterRow: number;
    get blankItems(): ReportItem[];
    canBlank(item: ReportItem, row: number): boolean;
    getMergedColumns(): number[];
    getMergedCells(): TableCell$1[];
    get outlineLabel(): string;
    get pathLabel(): string;
    get dataDominant(): boolean;
    get isDataRowContainer(): boolean;
    protected _createCells(): TableCellCollection;
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _doLoadChild(child: ReportItem, src: any): void;
    protected _doPreparePrint(ctx: PrintContext): void;
    private $_collectBlankItems;
}
declare class TableBandRowGroupSection extends TableBase {
    static readonly STYLE_PROPS: string[];
    static readonly DEFAULT_ROWS = 1;
    private _group;
    /** @internal */
    removedCells: TableCell$1[];
    constructor(group: TableBandRowGroup, name: string);
    /** group */
    get group(): TableBandRowGroup;
    /** band */
    get band(): TableBand;
    protected _getStyleProps(): string[];
    needDesignHeight(): boolean;
    needDesignWidth(): boolean;
    canResize(dir: ResizeDirection): boolean;
    get marqueeParent(): ReportItem;
    get colCount(): number;
    getColumn(col: number): TableColumnBase;
    getCellWidths(): DimensionCollection;
    protected _createCell(item: ReportItem): TableCellItem;
    isAncestorOf(item: ReportPageItem): boolean;
}
declare class TableBandRowGroupHeader extends TableBandRowGroupSection {
    static readonly $_ctor: string;
    constructor(group: TableBandRowGroup);
    get outlineLabel(): string;
    get pathLabel(): string;
}
declare class TableBandRowGroupFooter extends TableBandRowGroupSection {
    static readonly PROP_MERGED = "merged";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    private _merged;
    constructor(group: TableBandRowGroup);
    /**
     * True면 병합 컬럼에 포함되는 셀은 병합 데이터셀에 포함시킨다.
     */
    get merged(): boolean;
    set merged(value: boolean);
    get outlineLabel(): string;
    get pathLabel(): string;
    getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
declare class TableBandRowGroup extends DataBandRowGroup {
    static readonly PROPINFOS: IPropInfo[];
    private _merged;
    private _collection;
    private _header;
    private _footer;
    constructor(collection: TableBandRowGroupCollection);
    get outlineParent(): IOutlineSource;
    get marqueeParent(): ReportItem;
    getEditProps(): IPropInfo[];
    getCollectionLabel(): string;
    /** header */
    get header(): TableBandRowGroupHeader;
    /** footer */
    get footer(): TableBandRowGroupFooter;
    /** band */
    get band(): TableBand;
    get page(): ReportPage;
    get report(): Report;
    get collection(): TableBandRowGroupCollection;
    get dataParent(): ReportGroupItem;
    get outlineLabel(): string;
    get displayPath(): string;
    protected _ignoreItems(): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _changed(prop: string, newValue: any, oldValue: any): void;
}
declare class TableBandRowGroupCollection extends ReportItemCollection<TableBandRowGroup> {
    private _band;
    private _groups;
    constructor(band?: TableBand);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    getSaveType(): string;
    get owner(): ReportItem;
    /** band */
    get band(): TableBand;
    /** count */
    get count(): number;
    get items(): ReportPageItem[];
    get visibleCount(): number;
    /** groups */
    get groups(): TableBandRowGroup[];
    load(loader: IReportLoader, src: any): void;
    save(target: any): void;
    get(index: number): TableBandRowGroup;
    indexOf(group: TableBandRowGroup): number;
    add(group: TableBandRowGroup | ConfigObject$1, index?: number): TableBandRowGroup;
    addAll(groups: (TableBandRowGroup | ConfigObject$1)[], index?: number): boolean;
    removeAt(index: number): boolean;
    remove(group: TableBandRowGroup): boolean;
    clear(): boolean;
    getValidGroups(data: IBandData): TableBandRowGroup[];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    isAncestorOf(item: ReportPageItem): boolean;
    protected _doMoveItem(from: number, to: number): boolean;
    private $_add;
    private $_invalidateGroups;
    private $_groupChanged;
}
/**
 * 페이지를 넘어갈 수 있다.
 * 한 row는 페이지를 넘어갈 수 없다.
 * header/footer와 row의 컬럼 너비를 반드시 맞춰야 하거나 컬럼 line을 표시해야 할 경우 사용.
 * header/footer/pageFooter 각 컬럼의 너비는 row의 컬럼 너비를 자동으로 따라간다.
 * design-time에는 section마다 별도의 table로 표시되지만 printing 시에는 하나의 table element로 구현한다.
 */
declare class TableBand extends DataBand {
    static readonly PROP_COL_COUNT = "colCount";
    static readonly PROP_COLUMNS = "columns";
    static readonly PROP_GROUPS = "groups";
    static readonly PROPINFOS: IPropInfo[];
    static readonly DEFAULT_COL_COUNT = 5;
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Table Band";
    private _colCount;
    private _columns;
    private _groups;
    private _header;
    private _footer;
    private _dataRow;
    private _tables;
    private _pr;
    private _tr;
    private _lastTrs;
    constructor(name: string);
    get outlineItems(): IOutlineSource[];
    /** cols */
    get colCount(): number;
    set colCount(value: number);
    /** columns */
    get columns(): TableBandColumnCollection;
    /** groups */
    get groups(): TableBandRowGroupCollection;
    /** header */
    get header(): TableBandHeader;
    /** footer */
    get footer(): TableBandFooter;
    /** dataRow */
    get dataRow(): TableBandDataRow;
    /**
     * Current printing data row index.
     */
    get pr(): number;
    /**
     * Current printing table row index.
     */
    get tr(): number;
    /**
     * Last printing tr count.
     */
    get lastTrs(): number;
    getColumn(index: number): TableBandColumn;
    getGroup(index: number): TableBandRowGroup;
    /**
     * @internal
     */
    getTables(): TableBase[];
    removeColumn(col: number | TableBandColumn): void;
    addColumn(index: number, column: TableBandColumn): TableBandColumn;
    canMoveColumns(col: number, count: number, newCol: number, alert?: boolean): boolean;
    getNearestMovableColumn(col: number, count: number, delta: number): number;
    moveColumns(col: number, count: number, delta: number, force?: boolean): boolean;
    getCellWidths(): DimensionCollection;
    setPrinting(ctx: PrintContext, pr: number, trows?: number): void;
    getSaveType(): string;
    get outlineLabel(): string;
    get isBand(): boolean;
    protected _ignoreItems(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    isAncestorOf(item: ReportPageItem): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    private $_columnChanged;
    private $_groupChanged;
    protected _doPreparePrint(ctx: PrintContext): void;
    protected _doPrepareIndices(ctx: PrintContext): void;
    remove(item: ReportPageItem): void;
    getNextDetailRows(ctx: PrintContext): number[];
    skipDetailRows(ctx: PrintContext): void;
    containsInSection(item: ReportItem): boolean;
}

declare class TableColumn extends TableColumnBase {
    constructor(collection: TableColumnCollection, src?: any);
    /** table */
    get table(): TableContainer;
    get displayPath(): string;
    get collection(): TableColumnCollection;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    canRemoveFrom(): boolean;
    protected _changed(prop: string, newValue: any, oldValue: any): void;
}
declare class TableColumnCollection extends TableColumnCollectionBase<TableContainer, TableColumn> {
    constructor(table?: TableContainer);
    /** table */
    get table(): TableContainer;
    protected _createColumn(src: any): TableColumn;
}
/**
 * TableContainer가 자동 생성한다.
 * 자식 하나만 가질 수 있다.
 */
declare class TableContainerCellItem extends TableCellItem {
    static readonly $_ctor: string;
    constructor(item: ReportItem);
    get pathLabel(): string;
}
/**
 * 자식 item들을 TableCellItem에 추가해서 배치한다.
 * 페이지를 넘어갈 수 없다.
 */
declare class TableContainer extends TableBase {
    static readonly PROP_BASE_TABLE = "baseTable";
    static readonly PROP_COL_COUNT = "colCount";
    static readonly PROP_COLUMNS = "columns";
    static readonly PROPINFOS: IPropInfo[];
    static readonly DEFAULT_ROW_COUNT = 4;
    static readonly DEFAULT_COL_COUNT = 4;
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Table";
    private _baseTable;
    private _colCount;
    private _baseContainer;
    private _columns;
    constructor(name: string);
    changeColumnWidth(col: number, delta: number): void;
    getColumnWidth(col: number): ValueString;
    get outlineItems(): IOutlineSource[];
    /**
     * 기준 table의 name.
     * 기준 table의 cell 너비 설정을 따라간다.
     */
    get baseTable(): string;
    set baseTable(value: string);
    /** cols */
    get colCount(): number;
    set colCount(value: number);
    /** columns */
    get columns(): TableColumnCollection;
    getColumn(index: number): TableColumn;
    removeColumn(col: number | TableColumn): void;
    addColumn(index: number, column: TableColumn): TableColumn;
    canMoveColumns(col: number, count: number, newCol: number, alert?: boolean): boolean;
    moveColumns(col: number, count: number, newCol: number, force?: boolean): boolean;
    getSaveType(): string;
    get outlineLabel(): string;
    get pathLabel(): string;
    needDesignWidth(): boolean;
    needDesignHeight(): boolean;
    protected _datable(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doLoadChild(child: ReportItem, src: any): void;
    protected _doSave(target: object): void;
    protected _createCell(item: ReportItem): TableContainerCellItem;
    getCellWidths(): DimensionCollection;
    prepareLayout(): TableCellSpan[][];
    isAncestorOf(item: ReportPageItem): boolean;
    private $_columnChanged;
}

declare abstract class SimpleBandSection extends StackContainer {
    static readonly PROP_SIMPLE_BAND_SECTION_REPEAT = "repeat";
    static readonly PROPINFOS: IPropInfo[];
    static readonly PROP_FIELD = "field";
    private _repeat;
    private _child_field;
    private _band;
    constructor(band: SimpleBand);
    /** band */
    get band(): SimpleBand;
    /** repeat */
    get repeat(): boolean;
    set repeat(value: boolean);
    /**
     * field
     */
    getFieldOf(item: ReportItem): string;
    setFieldOf(item: ReportItem, value: string): void;
    get designLevel(): number;
    get marqueeParent(): ReportItem;
    canResize(dir: ResizeDirection): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _doLoadChild(child: ReportItem, src: any): void;
}
declare class SimpleBandHeader extends SimpleBandSection {
    static readonly $_ctor: string;
    constructor(band: SimpleBand);
    get outlineLabel(): string;
}
declare class SimpleBandFooter extends SimpleBandSection {
    static readonly PROP_ATTACH_TO_BODY = "attachToBody";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    private _attachToBody;
    /**
     * true면 multi column 모드일 때 마지막 컬럼의 마지막 행에 붙여서 출력하고,
     * false면 모든 컬럼의 가장 아래쪽에 붙여서 출력한다.
     *
     * @default false
     */
    get attachToBody(): boolean;
    set attachToBody(value: boolean);
    get outlineLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
declare class SimpleBandRow extends SimpleBandSection {
    static readonly PROP_EQUAL_BLANK = "equalBlank";
    static readonly PROP_BLANK_FIELDS = "blankFields";
    static readonly CHILD_PROPS: IPropInfo[];
    static readonly $_ctor: string;
    private _blankItems;
    masterRow: number;
    get blankItems(): ReportItem[];
    canBlank(item: ReportItem, row: number): boolean;
    get outlineLabel(): string;
    get dataDominant(): boolean;
    get isDataRowContainer(): boolean;
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _doLoadChild(child: ReportItem, src: any): void;
    protected _doPreparePrint(ctx: PrintContext): void;
}
declare abstract class SimpleBandRowGroupSection extends StackContainer {
    static readonly STYLE_PROPS: string[];
    private _group;
    constructor(group: SimpleBandRowGroup, name: string);
    /** group */
    get group(): SimpleBandRowGroup;
    /** band */
    get band(): SimpleBand;
}
declare class SimpleBandRowGroupHeader extends SimpleBandRowGroupSection {
    static readonly $_ctor: string;
    constructor(group: SimpleBandRowGroup);
    get outlineLabel(): string;
}
declare class SimpleBandRowGroupFooter extends SimpleBandRowGroupSection {
    static readonly $_ctor: string;
    constructor(group: SimpleBandRowGroup);
    get outlineLabel(): string;
}
declare class SimpleBandRowGroup extends DataBandRowGroup {
    static readonly PROPINFOS: IPropInfo[];
    private _collection;
    private _header;
    private _footer;
    constructor(collection: SimpleBandRowGroupCollection);
    get outlineParent(): IOutlineSource;
    get marqueeParent(): ReportItem;
    getEditProps(): IPropInfo[];
    /** header */
    get header(): SimpleBandRowGroupHeader;
    /** footer */
    get footer(): SimpleBandRowGroupFooter;
    /** band */
    get band(): SimpleBand;
    get page(): ReportPage;
    get report(): Report;
    get collection(): SimpleBandRowGroupCollection;
    get dataParent(): ReportGroupItem;
    protected _ignoreItems(): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _changed(prop: string, newValue: any, oldValue: any): void;
}
declare class SimpleBandRowGroupCollection extends ReportItemCollection<SimpleBandRowGroup> {
    private _band;
    private _groups;
    constructor(band?: SimpleBand);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    getSaveType(): string;
    canRemoveFrom(): boolean;
    canParentOf(itemType: string): boolean;
    get owner(): ReportItem;
    /** band */
    get band(): SimpleBand;
    /** count */
    get count(): number;
    get items(): ReportPageItem[];
    get visibleCount(): number;
    /** groups */
    get groups(): SimpleBandRowGroup[];
    load(loader: IReportLoader, src: any): void;
    save(target: any): void;
    get(index: number): SimpleBandRowGroup;
    indexOf(field: SimpleBandRowGroup): number;
    add(group: SimpleBandRowGroup | ConfigObject$1, index?: number): SimpleBandRowGroup;
    addAll(groups: (SimpleBandRowGroup | ConfigObject$1)[], index?: number): boolean;
    removeAt(index: number): boolean;
    remove(group: SimpleBandRowGroup): boolean;
    clear(): boolean;
    getValidGroups(data: IBandData): SimpleBandRowGroup[];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    isAncestorOf(item: ReportPageItem): boolean;
    protected _doMoveItem(from: number, to: number): boolean;
    private $_add;
    private $_invalidateGroups;
    private $_groupChanged;
}
/**
 * 페이지를 넘어갈 수 있다.
 * 한 row는 페이지를 넘어갈 수 없다.
 * 페이지를 넘어갈 수 있으므로 매 페이지마다 header나 footer를 표시할 필요가 있을 수 있다.
 */
declare class SimpleBand extends DataBand {
    static readonly PROP_SIMPLE_BAND_GROUPS = "groups";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Simple Band";
    private _groups;
    private _header;
    private _footer;
    private _dataRow;
    private _pr;
    constructor(name: string);
    get outlineItems(): IOutlineSource[];
    /** groups */
    get groups(): SimpleBandRowGroupCollection;
    /** header */
    get header(): SimpleBandHeader;
    /** footer */
    get footer(): SimpleBandFooter;
    /** dataRow */
    get dataRow(): SimpleBandRow;
    /**
     * Current printing data row
     */
    get pr(): number;
    setPrinting(ctx: PrintContext, row: number): void;
    getSaveType(): string;
    get outlineLabel(): string;
    get isBand(): boolean;
    protected _ignoreItems(): boolean;
    protected _getEditProps(): IPropInfo[];
    isAncestorOf(item: ReportPageItem): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    private $_groupChanged;
    protected _doPreparePrint(ctx: PrintContext): void;
    protected _doPrepareIndices(ctx: PrintContext): void;
    canRemove(item: ReportItem): boolean;
    getNextDetailRows(ctx: PrintContext): number[];
    skipDetailRows(ctx: PrintContext): void;
    containsInSection(item: ReportItem): boolean;
}

/**
 * Box container 내에서 아이템들 사이에 일정 크기의 자리를 차지하는 place holder 아이템.
 * 대개는 비어 있는 상태이지만, border 스타일을 이용해 수직/수평 선을 표시하는 용도로 사용할 수 있다.
 * 페이지를 넘어갈 수 없다.
 */
declare class SpaceItem extends ReportItem {
    static readonly PROP_SIZE = "size";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Space";
    private _size;
    private _sizeDim;
    constructor(name: string);
    /**
     * 높이나 너비.
     * RowBoxContainer 안에서는 너비.
     * ColumnBoxContainer 안에서는 높이.
     */
    get size(): ValueString;
    set size(value: ValueString);
    getSize(domain: number): number;
    getSaveType(): string;
    get outlineLabel(): string;
    protected _sizable(): boolean;
    protected _boundable(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    canAddTo(parent: ReportGroupItem): boolean;
}

interface IImageContainer {
    addImage(url: string): void;
    imageLoaded(url: string): void;
}
/** @internal */
declare class ReportElement extends VisualElement$1 {
    private static readonly Debugging;
    private _debugView;
    protected _modelWidth: number;
    protected _modelHeight: number;
    private _measuredWidth;
    private _measuredHeight;
    protected _printWidth: number;
    protected _printHeight: number;
    /** debuggin */
    get debugging(): boolean;
    /** debugName */
    get debugLabel(): string;
    /** guardLabel */
    get guardLabel(): string;
    /** measuredWidth */
    get measuredWidth(): number;
    /** measuredHeight */
    get measuredHeight(): number;
    /**
     * true면 measure() 시점이 아니라
     * layout() 시점에 parent의 크기를 기준으로 measure + layout을 동시 진행한다.
     */
    get lazyLayout(): boolean;
    get floating(): boolean;
    measure(ctx: PrintContext, hintWidth: number, hintHeight: number): Size$1;
    layoutContent(ctx: PrintContext): void;
    print(doc: Document, ctx: PrintContext, w?: number): number;
    findElement(modelName: string): ReportItemElement<ReportItem>;
    applyMeasure(): void;
    protected _debugBorder(): string;
    protected _debugColor(): string;
    protected _clearDesign(): void;
    protected _afterDraw(dom: HTMLElement): void;
    protected _debuggable(): boolean;
    protected _doPrepareMeasure(ctx: PrintContext, dom: HTMLElement): void;
    protected _doAfterMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number, sz: Size$1): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _doPrepareContent(ctx: PrintContext): void;
    protected _doLayoutContent(ctx: PrintContext): void;
    protected _doAfterLayout(ctx: PrintContext): void;
    protected _doSetStyles(model: ReportItem, dom: HTMLElement): void;
    protected _setStyles(model: ReportItem, styles: {
        [key: string]: string;
    }, css: CSSStyleDeclaration): void;
    protected _getModelWidth(model: ReportItem, width: number): number;
    protected _getModelHeight(model: ReportItem, height: number): number;
    protected _setModelSize(model: ReportItem, dom: HTMLElement, width: number, height: number, clear?: boolean): void;
    protected _doPrint(doc: Document, ctx: PrintContext): void;
}

/** @internal */
declare abstract class ReportItemElement<T extends ReportItem> extends ReportElement {
    protected _designView: HTMLDivElement;
    protected _bindMarker: HTMLSpanElement;
    private _model;
    protected _modelChanged: boolean;
    private _prevStyles;
    private _rotation;
    constructor(doc: Document, model?: T, name?: string);
    protected _doDispose(): void;
    /** model */
    get model(): T;
    set model(value: T);
    /** navigableParent */
    get navigableParent(): ReportGroupItemView;
    get modelParent(): ReportGroupItemView;
    get marqueeParent(): ReportItemView;
    get designable(): boolean;
    get editable(): boolean;
    get isSpace(): boolean;
    get isRelativeHeight(): boolean;
    get rotation(): number;
    setRotation(value: number): void;
    _clearDesign(): void;
    getEditText(): string;
    setEditText(report: Report, text: string): void;
    refreshPrintValues(ctx: PrintContext): void;
    get printable(): boolean;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _setBindMarker(visible?: boolean, system?: boolean): void;
    protected _doPrepareMeasure(ctx: PrintContext, dom: HTMLElement): void;
    private $_setRotation;
    protected _doAfterMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number, sz: Size$1): void;
    findElement(modelName: string): ReportItemElement<ReportItem>;
    findElementOf(dom: HTMLElement): ReportItemElement<ReportItem>;
    getPrintValue(ctx: PrintContext, m: ReportItem, defaultValue?: any): any;
    protected _doModelChanged(oldModel: T): void;
    protected _setX(dom: HTMLElement, x: number): void;
    protected _setY(dom: HTMLElement, y: number): void;
    protected _setPos(dom: HTMLElement, x: number, y: number): void;
    protected _runValueCallback(ctx: PrintContext, m: ReportItem, value: any): any;
}
declare type ReportItemView = ReportItemElement<ReportItem>;
/** @internal */
declare abstract class ReportGroupItemElement<T extends ReportGroupItem> extends ReportItemElement<T> {
    private _contentBox;
    private _floatings;
    private _padLeft;
    private _padRight;
    private _padTop;
    private _padBottom;
    private _borderApplied;
    measureFixed: boolean;
    constructor(doc: Document, model: T, name: string);
    protected _doDispose(): void;
    get navigable(): boolean;
    get lazyLayoutChildren(): boolean;
    isContentDom(dom: HTMLElement): boolean;
    findElement(modelName: string): ReportItemView;
    findElementOf(dom: HTMLElement): ReportItemView;
    getElementOf(model: ReportPageItem): ReportElement;
    indexOfElement(elt: ReportItemView): number;
    getLeaves(): ReportItemView[];
    getFirst(): ReportItemView;
    getLast(): ReportItemView;
    protected _getPrev(item: ReportItemView): ReportItemView;
    protected _getNext(item: ReportItemView): ReportItemView;
    getPrev(item: ReportItemView): ReportItemView;
    getNext(item: ReportItemView): ReportItemView;
    getLeft(item: ReportItemView): ReportItemView;
    getRight(item: ReportItemView): ReportItemView;
    getUpper(item: ReportItemView): ReportItemView;
    getLower(item: ReportItemView): ReportItemView;
    itemOfDom(dom: Element): ReportItem;
    setFixedSize(w: number): ReportGroupItemElement<ReportGroupItem>;
    isDom(dom: Element): boolean;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    replaceDom(dom: HTMLElement): void;
    refreshPrintValues(ctx: PrintContext): void;
    protected _getItemViews(): ReportItemView[];
    protected _getParentDom(): HTMLElement;
    protected _getItemsParent(): ReportElement;
    protected _needContentBox(): boolean;
    protected _needDesignBox(): boolean;
    protected _applyPaddings(dom: HTMLElement, sz: Size$1): void;
    protected _applyBorders(dom: HTMLElement, sz: Size$1): void;
    protected _isEmpty(): boolean;
    protected _isFocused(): boolean;
    protected _isItemFocused(item: ReportPageItem): boolean;
    protected _isItemSelected(item: ReportPageItem): boolean;
    protected _getFocusedItem(): ReportPageItem;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _doPrepareMeasure(ctx: PrintContext, dom: HTMLElement): void;
    protected _getDesignText(): string;
    protected _setDesignContent(empty: boolean, designView: HTMLDivElement): void;
    protected _doMeasureItem(ctx: PrintContext, index: number, elt: ReportElement, hintWidth: number, hintHeight: number): void;
    protected _createElement(report: ReportView, parent: ReportElement, item: ReportItem): ReportElement;
    protected _buildItems(ctx: PrintContext, report: ReportView, model: ReportGroupItem): void;
    protected _prepareChild(child: ReportElement): void;
    protected _doLayoutContent(ctx: PrintContext): void;
    layoutFloating(ctx: PrintContext): void;
    protected _layoutItem(ctx: PrintContext, child: ReportElement, model: ReportItem, x: number, y: number, width: number, height: number): void;
    protected _layoutChild(ctx: PrintContext, child: ReportElement, x: number, y: number, width: number, height: number): void;
    protected _layoutFloating(ctx: PrintContext, child: ReportElement, model: FloatingContainer): void;
    protected _doAfterLayout(ctx: PrintContext): void;
    protected _doPrint(doc: Document, ctx: PrintContext): void;
}
declare type ReportGroupItemView = ReportGroupItemElement<ReportGroupItem>;
interface ITable {
    colCount: number;
    columns: TableColumnCollectionBase<ReportGroupItem, TableColumnBase>;
    getColumn(index: number): TableColumnBase;
    getColPoints(): number[];
}

declare enum CrosstabSummary {
    SUM = "sum",
    AVG = "avg",
    MIN = "min",
    MAX = "max",
    COUNT = "count",
    DISTINCT = "distinct"
}
declare class CrosstabFieldHeader extends ReportItem {
    static readonly PROP_SUFFIX = "suffix";
    static readonly PROPINFOS: IPropInfo[];
    private _suffix;
    private _field;
    constructor(field: CrosstabField, source: any);
    get field(): CrosstabField;
    /** suffix */
    get suffix(): string;
    set suffix(value: string);
    get page(): ReportPage;
    get outlineSource(): IOutlineSource;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    getSaveLabel(): string;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * 필드 summary 영역 (column 혹은 row)헤더 셀에 대한 설정.
 */
declare class CrosstabFieldSummaryHeader extends ReportItem {
    static readonly PROP_TEXT = "text";
    static readonly PROPINFOS: IPropInfo[];
    private _text;
    private _summary;
    constructor(summary: CrosstabFieldSummary, source: any);
    get summary(): CrosstabFieldSummary;
    get field(): CrosstabField;
    /** text */
    get text(): string;
    set text(value: string);
    get page(): ReportPage;
    get outlineSource(): IOutlineSource;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    getSaveLabel(): string;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * 필드 summary 영역 data 셀에 대한 설정.
 * row field 설정이 column field 설정보다 우선하고, column field 설정이 value field 설정보다 우선한다.
 */
declare class CrosstabFieldSummary extends ReportItem {
    static readonly PROPINFOS: IPropInfo[];
    private _field;
    private _header;
    constructor(field: CrosstabField, source: any);
    get field(): CrosstabField;
    get header(): CrosstabFieldSummaryHeader;
    get page(): ReportPage;
    get outlineSource(): IOutlineSource;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    getSaveLabel(): string;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
declare abstract class CrosstabField extends ReportItemCollectionItem {
    static readonly PROP_FIELD = "field";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _field;
    private _index;
    fieldIndex: number;
    dataType: string;
    protected _header: CrosstabFieldHeader;
    protected _summary: CrosstabFieldSummary;
    constructor(collection: CrosstabFieldCollection<any>, source: any);
    /** band */
    get band(): CrosstabBand;
    /** index */
    get index(): number;
    /** field */
    get field(): string;
    set field(value: string);
    /** header */
    get header(): CrosstabFieldHeader;
    /** summary */
    get summary(): CrosstabFieldSummary;
    get itemType(): string;
    get page(): ReportPage;
    get displayPath(): string;
    get collection(): CrosstabFieldCollection<any>;
    get marqueeParent(): ReportItem;
    isAncestor(group: ReportGroupItem): boolean;
    getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _changed(prop: string, newValue: any, oldValue: any): void;
    protected _doLoad(src: any): void;
    protected _doSave(target: any): any;
}
declare abstract class CrosstabFieldCollection<T extends CrosstabField> extends ReportItemCollection<T> {
    private _band;
    private _type;
    private _fields;
    constructor(owner: CrosstabBand, type: string);
    get band(): CrosstabBand;
    load(src: any[]): void;
    save(target: any): void;
    contains(field: string): boolean;
    getField(field: string): T;
    slice(count: number): T[];
    indexOf(field: T): number;
    add(field: any, index?: number): T;
    removeAt(index: number): boolean;
    remove(field: T): void;
    get owner(): ReportItem;
    get count(): number;
    get items(): CrosstabField[];
    get outlineLabel(): string;
    get outlineParent(): IOutlineSource;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get(index: number): T;
    getSaveType(): string;
    private $_add;
    protected _doMoveItem(from: number, to: number): boolean;
    protected abstract _createField(src: any): T;
    protected _resetFields(): void;
    protected _fieldChanged(field: CrosstabField): void;
}
declare type CrosstabFieldCell = CrosstabField | CrosstabFieldHeader | CrosstabFieldSummary | CrosstabFieldSummaryHeader;
declare class CrosstabRowField extends CrosstabField {
    get itemType(): string;
    getCollectionLabel(): string;
}
declare class CrosstabRowFieldCollection extends CrosstabFieldCollection<CrosstabRowField> {
    constructor(owner: CrosstabBand);
    protected _createField(src: any): CrosstabRowField;
}
declare class CrosstabColumnField extends CrosstabField {
    constructor(collection: CrosstabColumnFieldCollection, source: any);
    get itemType(): string;
    getCollectionLabel(): string;
    protected _doLoad(src: any): void;
    protected _doSave(target: any): any;
}
declare class CrosstabColumnFieldCollection extends CrosstabFieldCollection<CrosstabColumnField> {
    constructor(owner: CrosstabBand);
    protected _createField(src: any): CrosstabColumnField;
}
declare class CrosstabValueField extends CrosstabField {
    static readonly PROP_VALUE = "value";
    static readonly PROPINFOS: IPropInfo[];
    private _value;
    constructor(collection: CrosstabFieldCollection<any>, source: any);
    /** value */
    get value(): CrosstabSummary;
    set value(value: CrosstabSummary);
    get itemType(): string;
    getCollectionLabel(): string;
    getEditProps(): IPropInfo[];
    protected _doLoad(src: any): void;
    protected _doSave(target: object): void;
}
declare class CrosstabValueFieldCollection extends CrosstabFieldCollection<CrosstabValueField> {
    constructor(owner: CrosstabBand);
    protected _createField(src: any): CrosstabValueField;
}
declare class CrosstabRec {
    private _keys;
    private _rows;
    private sum;
    private count;
    private min;
    private max;
    private avg;
    constructor(keys: any[], rows: number[]);
    get rowCount(): number;
    getKey(field: number): any;
    getSummary(data: IBandData, field: number, exp: string): number;
}
interface IFilter {
    select(data: IBandData, row: number): boolean;
}
declare class RecCollection {
    private _band;
    private _filters;
    private _recs;
    constructor(band: CrosstabBand);
    get count(): number;
    getKey(rec: number, field: number): any;
    getRec(index: number): CrosstabRec;
    getRecs(start?: number, end?: number): CrosstabRec[];
    setFilters(filters: IFilter[]): void;
    build(data: BandArrayData): void;
    private $_collectRows;
    private $_sortRows;
    private $_buildRecs;
}
declare class CrosstabColumn {
    hash: number;
    parent: CrosstabColumn;
    protected _field: CrosstabColumnField;
    private _value;
    private _children;
    constructor(field: CrosstabColumnField, value: any);
    get field(): CrosstabColumnField;
    get value(): any;
    get count(): number;
    get children(): CrosstabColumn[];
    get level(): number;
    get isLeaf(): boolean;
    get leafCount(): number;
    getChild(index: number): CrosstabColumn;
    clear(): void;
    add(column: CrosstabColumn, force?: boolean): void;
    addSummary(column: CrosstabSummaryColumn): void;
    sort(): void;
    getHeader(): string;
}
declare class CrosstabLeafColumn extends CrosstabColumn {
    protected _valueField: CrosstabValueField;
    constructor(field: CrosstabColumnField, valueField: CrosstabValueField, value: any);
    get valueField(): CrosstabValueField;
    get leafCount(): number;
    getHeader(): string;
}
declare class CrosstabSummaryColumn extends CrosstabColumn {
    private _summary;
    constructor(summary: CrosstabFieldSummary);
    get summary(): CrosstabFieldSummary;
    getHeader(): string;
}
declare class ColumnCollection$1 {
    private _band;
    private _root;
    _leafs: CrosstabLeafColumn[];
    constructor(band: CrosstabBand);
    get root(): CrosstabColumn;
    get count(): number;
    get leafCount(): number;
    get levels(): number;
    build(recs: RecCollection): void;
    get(index: number): CrosstabColumn;
    getLeaf(index: number): CrosstabLeafColumn;
    getColumns(parent: CrosstabColumn, columns: CrosstabColumn[][]): void;
    private $_collectColumns;
}
declare abstract class CrosstabRowBase {
    abstract slice(count: number): any[];
    abstract getValue(index: number): any;
    abstract getColumnRec(column: CrosstabColumn): CrosstabRec;
}
declare class RowCollection {
    private _band;
    private _rows;
    constructor(band: CrosstabBand);
    get rowCount(): number;
    getRow(index: number): CrosstabRowBase;
    build(data: BandArrayData, recs: RecCollection): void;
    private $_collectRows;
    private $_collectSummaryRows;
}
/**
 * Crosstab band topLeft 모서리 셀에 표시되는 내용에 대한 모델.
 */
declare class CrosstabBandTitle extends ReportItem {
    static readonly PROP_TEXT = "text";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _text;
    private _band;
    constructor(band: CrosstabBand);
    /** text */
    get text(): string;
    set text(value: string);
    protected _getEditProps(): any[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
declare class CrosstabNullValue extends ReportItem {
    static readonly PROP_TEXT = "text";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _text;
    private _band;
    constructor(band: CrosstabBand);
    /** text */
    get text(): string;
    set text(value: string);
    protected _getEditProps(): any[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * Crosstab band
 */
declare class CrosstabBand extends ReportGroupItem {
    static readonly PROP_TITLE = "title";
    static readonly PROP_NULL_VALUE = "nullValue";
    static readonly PROP_MAX_ROW_COUNT = "maxRowCount";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static isFieldCell(item: ReportPageItem): boolean;
    static getFieldOf(cell: CrosstabFieldCell): CrosstabField;
    static getBandOf(cell: CrosstabFieldCell): CrosstabBand;
    private _maxRowCount;
    private _title;
    private _nullValue;
    private _rowFields;
    private _columnFields;
    private _valueFields;
    private _recs;
    _columns: ColumnCollection$1;
    private _rows;
    pageNo: number;
    rowIndex: number;
    constructor(name: string);
    /**
     * Cross table 생성시 사용될 원본 데이터 최대 행 수.
     */
    get maxRowCount(): number;
    set maxRowCount(value: number);
    /**
     * title
     */
    get title(): CrosstabBandTitle;
    /**
     * null value
     */
    get nullValue(): CrosstabNullValue;
    /** rowFields */
    get rowFields(): CrosstabRowFieldCollection;
    /** columnFields */
    get columnFields(): CrosstabColumnFieldCollection;
    /** valueFields */
    get valueFields(): CrosstabValueFieldCollection;
    get rows(): RowCollection;
    get bandData(): BandArrayData;
    get columnLevels(): number;
    containsField(field: string): boolean;
    getRowField(index: number): CrosstabField;
    getColumnField(index: number): CrosstabColumnField;
    getGroupFields(): CrosstabField[];
    build(): void;
    private _calcSummary;
    getCellValue(data: BandArrayData, r: number, c: number): any;
    getSaveType(): string;
    get outlineLabel(): string;
    get outlineItems(): IOutlineSource[];
    get isBand(): boolean;
    protected _datable(): boolean;
    protected _getEditProps(): IPropInfo[];
    isAncestorOf(item: ReportPageItem): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: any): void;
    _fieldsChanged(field: CrosstabField): void;
}

declare enum PaperSize {
    A0 = "A0",
    A1 = "A1",
    A2 = "A2",
    A3 = "A3",
    A4 = "A4",
    A5 = "A5",
    A6 = "A6",
    A7 = "A7",
    A8 = "A8"
}
declare enum PaperOrientation {
    PORTRAIT = "portrait",
    LANDSCAPE = "landscape"
}
/**
 * Paper options
 */
declare class PaperOptions extends Base$1 {
    private _orientation;
    private _size;
    private _width;
    private _height;
    private _marginLeft;
    private _marginRight;
    private _marginTop;
    private _marginBottom;
    private _report;
    private _widthDim;
    private _heightDim;
    private _marginLeftDim;
    private _marginRightDim;
    private _marginTopDim;
    private _marginBottomDim;
    constructor(report: Report);
    protected _doDispose(): void;
    /** orientation */
    get orientation(): PaperOrientation;
    set orientation(value: PaperOrientation);
    /** size */
    get size(): PaperSize;
    set size(value: PaperSize);
    /** width */
    get width(): ValueString;
    set width(value: ValueString);
    /** height */
    get height(): ValueString;
    set height(value: ValueString);
    /** marginLeft */
    get marginLeft(): ValueString;
    set marginLeft(value: ValueString);
    /** marginRight */
    get marginRight(): ValueString;
    set marginRight(value: ValueString);
    /** marginTop */
    get marginTop(): ValueString;
    set marginTop(value: ValueString);
    /** marginBottom */
    get marginBottom(): ValueString;
    set marginBottom(value: ValueString);
    load(src: any): void;
    getPageSize(): Size$1;
    getContentRect(r: Rectangle$1): Rectangle$1;
    getClientRect(): Rectangle$1;
    applyExtents(css: CSSStyleDeclaration): void;
    applyPreviewExtents(css: CSSStyleDeclaration): void;
    applyClient(css: CSSStyleDeclaration): void;
    applyPreviewClient(css: CSSStyleDeclaration): void;
    protected _changed(): void;
}
/**
 * Report info.
 */
declare class ReportInfo extends Base$1 {
    name: string;
    author: string;
    version: string;
    created: Date;
    description: string;
    paper: PaperOptions;
    constructor(report: Report);
}
/**
 * Find result
 */
interface FindResult {
    item: ReportItem;
    prop: string;
}
declare class ReportRootItem extends ReportGroupItem {
    static readonly PROP_REPORT_NAME = "name";
    static readonly PROP_REPORT_AUTHOR = "author";
    static readonly PROP_REPORT_VERSION = "version";
    static readonly PROP_REPORT_DESCRIPTION = "description";
    static readonly PROP_PAPER_ORIENTATION = "paperOrientation";
    static readonly PROP_PAPER_SIZE = "paperSize";
    static readonly PROP_PAPER_WIDTH = "paperWidth";
    static readonly PROP_PAPER_HEIGHT = "paperHeight";
    static readonly PROP_MARGIN_LEFT = "marginLeft";
    static readonly PROP_MARGIN_RIGHT = "marginRight";
    static readonly PROP_MARGIN_TOP = "marginTop";
    static readonly PROP_MARGIN_BOTTOM = "marginBottom";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    private _report;
    constructor(report: Report);
    get report(): Report;
    /** name */
    get name(): string;
    set name(value: string);
    /** author */
    get author(): string;
    set author(value: string);
    /** version */
    get version(): string;
    set version(value: string);
    /** description */
    get description(): string;
    set description(value: string);
    /** paperOrientation */
    get paperOrientation(): PaperOrientation;
    set paperOrientation(value: PaperOrientation);
    /** paperSize */
    get paperSize(): PaperSize;
    set paperSize(value: PaperSize);
    /** paperWidth */
    get paperWidth(): ValueString;
    set paperWidth(value: ValueString);
    /** paperHeight */
    get paperHeight(): ValueString;
    set paperHeight(value: ValueString);
    /** marginLeft */
    get marginLeft(): ValueString;
    set marginLeft(value: ValueString);
    /** marginRight */
    get marginRight(): ValueString;
    set marginRight(value: ValueString);
    /** marginTop */
    get marginTop(): ValueString;
    set marginTop(value: ValueString);
    /** marginBottom */
    get marginBottom(): ValueString;
    set marginBottom(value: ValueString);
    get pathLabel(): string;
    get displayPath(): string;
    protected _ignoreItems(): boolean;
    getEditProps(): IPropInfo[];
    getStyleProps(): IPropInfo[];
    canResize(dir: ResizeDirection): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * Report model.
 */
declare class Report extends EventAware$1 implements IEditCommandStackOwner, IPropertyContainer {
    static readonly RESET = "onReportReset";
    static readonly PAPER_CHANGED = "onReportPaperChanged";
    static readonly ITEM_ADD = "onReportItemAdd";
    static readonly ITEM_ADDED = "onReportItemAdded";
    static readonly ITEMS_ADDED = "onReportItemsAdded";
    static readonly ITEM_REMOVED = "onReportItemRemoved";
    static readonly ITEMS_REMOVED = "onReportItemsRemoved";
    static readonly ITEM_CHANGED = "onReportItemChanged";
    static readonly ITEM_MOVED = "onReportItemMoved";
    static readonly COLLECTION_CHANGED = "onReportCollectionChanged";
    static readonly COMMANDS_STACK_CHANGED = "onReportCommandStackChanged";
    static readonly DIRTY_CHANGED = "onReportDirtyChanged";
    static readonly DATA_ADDED = "onReportDataAdded";
    static readonly DATA_REMOVED = "onReportDataRemoved";
    static readonly DATA_UPDATED = "onReportDataUpdated";
    static readonly DATA_NAME_CHANGED = "onReportDataNameChanged";
    static readonly DATA_FIELD_NAME_CHANGED = "onReportDataFieldNameChanged";
    static readonly CELL_MERGED = "onReportCellMerged";
    static readonly ALERT = "onReportAlert";
    static isReportSource(source: any): boolean;
    private _info;
    private _unit;
    private _assetRoot;
    private _root;
    private _page;
    private _assets;
    private _data;
    private _designData;
    designTag: any;
    models: any;
    private _designTime;
    private _loader;
    private _commands;
    private _loading;
    private _invalids;
    constructor(designTime?: boolean, source?: any);
    _doDispose(): void;
    onDesignDataManagerDataAdded(dm: DesignDataManager, data: IReportData): void;
    onDesignDataManagerDataRemoved(dm: DesignDataManager, data: IReportData): void;
    onDesignDataManagerDataUpdated(dm: DesignDataManager, data: IReportData): void;
    onDesignDataManagerNameChanged(dm: DesignDataManager, data: IReportData, oldName: string): void;
    onDesignDataManagerFieldNameChanged(dm: DesignDataManager, data: IReportData, newName: string, oldName: string): void;
    editCommandStackChanged(stack: EditCommandStack$1, cmd: EditCommand$1, undoable: boolean, redoable: boolean): void;
    editCommandStackDirtyChanged(stack: EditCommandStack$1): void;
    addCollectionItem(collection: IPropertySource): void;
    /** @internal */
    get loader(): IReportLoader;
    /** info */
    get info(): ReportInfo;
    /** paper */
    get paper(): PaperOptions;
    /** unit */
    get unit(): PrintUnit;
    set unit(value: PrintUnit);
    /** assetRoot */
    get assetRoot(): string;
    set assetRoot(value: string);
    get root(): ReportRootItem;
    /** page */
    get page(): ReportPage;
    set page(value: ReportPage);
    /** assets */
    get assets(): AssetManager;
    /** data */
    get data(): IReportDataProvider;
    /** desingData */
    get designData(): DesignDataManager;
    /** canUndo */
    get canUndo(): boolean;
    /** canRedo */
    get canRedo(): boolean;
    get dirty(): boolean;
    load(src: any): Report;
    setSaveTagging(tag: string): Report;
    save(pageOnly?: boolean): object;
    prepareLayout(): void;
    preparePrint(ctx: PrintContext): void;
    getImageUrl(url: string): string;
    clearHistory(): void;
    closeHistory(): void;
    undo(): boolean;
    redo(): boolean;
    execute(cmd: EditCommand$1): boolean;
    getEditHistory(all?: boolean): EditCommand$1[];
    getCommand(id: number): EditCommand$1;
    itemByName(name: string): ReportItem;
    defaultInit(item: ReportItem, group: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    addItem(parent: ReportGroupItem, item: ReportItem, index?: number): boolean;
    moveCollectionItem(collection: ReportItemCollection<any>, from: number, to: number): void;
    addChartSeries(chart: HichartItem, seriesType: string): HichartSeries;
    addHichartPlotLine(axis: HichartAxis, config?: object): HichartAxisPlotLine;
    addHichartPlotBand(axis: HichartAxis, config?: object): HichartAxisPlotBand;
    /**
     * 테이블 행을 추가한다.
     *
     * @param table - 테이블 객체. TableContainer 혹은 TableBand 구성 테이블들.
     * @param row - 추가 위치.
     */
    addTableRow(table: TableBase, row: number): void;
    /**
     * 테이블 행들을 이동시킨다.
     *
     * @param table - 테이블 객체. TableContainer 혹은 TableBand 구성 테이블들.
     * @param row - 이동할 시작 행 위치.
     * @param count - 이동할 행 개수.
     * @param delta - 이동 간격. 음수면 위로, 양수면 아래로 이동한다.
     * @param alert - true로 설정하면, 이동 불가능한 상태일 때 예외를 발생시킨다.
     */
    moveTableRows(table: TableBase, row: number, count: number, delta: number, alert?: boolean): void;
    moveTableRowsToNearest(table: TableBase, row: number, count: number, delta: number, alert?: boolean): void;
    /**
     * 테이블이나 테이블밴드에 컬럼을 추가한다.
     * 병함된 셀을 분할해서 이동할 수 없다.
     * 또, 이동 후 병합된 셀을 분할시킬 수 없다.
     *
     * @param table - 테이블 혹은 테이블밴드 객체.
     * @param col - 추가 위치.
     */
    addTableColumn(table: TableContainer | TableBand, col: number): void;
    /**
     * 테이블이나 테이블밴드의 컬럼들을 이동시킨다.
     * 병함된 셀을 분할해서 이동할 수 없다.
     * 또, 이동 후 병합된 셀을 분할시킬 수 없다.
     *
     * @param table - 테이블 혹은 테이블밴드 객체.
     * @param col - 이동할 시작 컬럼 위치.
     * @param count - 이동할 컬럼 개수.
     * @param delta - 이동 간격. 음수면 왼쪽으로, 양수면 오른쪽으로 이동한다.
     */
    moveTableColumns(table: TableContainer | TableBand, col: number, count: number, delta: number): void;
    moveTableColumnsToNearest(table: TableContainer | TableBand, col: number, count: number, delta: number): void;
    addCrosstabField(collection: CrosstabFieldCollection<any>, field: string): void;
    /**
     * 리포트 아이템을 제거한다.
     *
     * @param item - 제거할 리포트 아이템 객체.
     */
    removeItem(item: ReportPageItem): void;
    /**
     * 리포트 아이템들을 제거한다.
     *
     * @param items - 제거할 리포트 아이템 객체들의 배열.
     */
    removeItems(items: ReportPageItem[]): void;
    setItemProperty(item: ReportPageItem, prop: string, value: any): void;
    setItemProperties(item: ReportPageItem, props: ConfigObject$1): void;
    setItemsProperties(items: ReportItem[], props: ConfigObject$1): void;
    resetItemProperty(item: ReportPageItem, prop: IPropInfo): boolean;
    setItemsProperty(items: ReportPageItem[], prop: string, value: any): void;
    setItemStyle(item: ReportPageItem, style: string, value: any): void;
    setItemsStyle(items: ReportPageItem[], style: string, value: any): void;
    setChildStyleProperty(item: ReportItem, prop: string, style: string, value: any): void;
    setItemsChildStyleProperty(items: ReportItem[], prop: string, style: string, value: any): void;
    addTableBandColumn(band: TableBand, config: any, index?: number): void;
    addTableBandGroup(band: TableBand, config: any, index?: number): void;
    addSimpleBandGroup(band: SimpleBand, config: any, index?: number): void;
    canMergeSelection(selection: ISelectionSource): boolean;
    mergeSelection(selection: TableSelection): void;
    canUnmergeCell(cell: TableCell$1): boolean;
    unmergeCell(cell: TableCell$1): void;
    search(key: string, options?: FindOptions): FindResult[];
    applyDropResult(item: ReportItem | TableCell$1, r: IDropResult): boolean;
    addAsset(group: AssetGroup | string, item: AssetItem): void;
    removeAsset(item: AssetItem): void;
    renameData(data: IReportData, newName: string): boolean;
    addData(data: IReportData): boolean;
    removeData(data: string | IReportData): boolean;
    saveSimpleData(data: SimpleData, values: any): void;
    saveItems(items: ReportItem[]): string;
    pasteItems(sources: string, target: ReportPageItem): ReportItem[];
    /**
     * 아이템의 위치를 변경한다. Undo 가능하다.
     *
     * @param item - 아이템 객체.
     * @param newX - x 위치.
     * @param newY - y 위치.
     */
    moveItem(item: ReportItem, newX: any, newY: any): void;
    moveItemDir(item: ReportItem, dir: string, newPt: number): void;
    resizeItem(item: ReportItem, orgWidth: any, orgHeight: any, width: number, height: number, dx: number, dy: number): void;
    resizeSpace(item: SpaceItem, orgSize: any, size: number, delta: number): void;
    resizeAndMove(item: ReportItem, orgWidth: any, orgHeight: any, width: number, height: number, dx: number, dy: number, newX: any, newY: any): void;
    alignItem(item: ReportPageItem, align: 'left' | 'top' | 'center' | 'right' | 'bottom'): void;
    alignItems(items: ReportPageItem[], align: 'left' | 'top' | 'center' | 'right' | 'bottom'): void;
    changeItemIndex(item: ReportItem, newIndex: number): boolean;
    clearTexts(items: ReportItem[]): void;
    /**
     * col + 1 컬럼의 너비를 줄이거나 늘이면서 col 컬럼의 너비를 변경한다.
     */
    adjustColumnWidths(table: ITable, col: number, colPoints: number[], newSize: number): void;
    /**
     * row + 1 행의 높이를 줄이거나 늘이면서 row 행의 높이를 변경한다.
     */
    adjustRowHeights(table: TableBase, row: number, rowPoints: number[], newSize: number): void;
    getInvalids(): {
        item: ReportItem;
        reason: string;
    }[];
    private $_refreshInvalids;
    private onPageItemAdded;
    private onPageItemsAdded;
    private onPageItemRemoved;
    private onPageItemsRemoved;
    private onPageItemChanged;
    private onPageCollectionChanged;
    protected _fireReset(): void;
    protected _firePaperChanged(): void;
    protected _fireItemAdd(group: ReportGroupItem, item: ReportItem, index: number): boolean;
    protected _fireItemMoved(item: ReportItem, index: number): void;
    protected _fireCollectionChanged(collection: ReportItemCollection<any>): void;
    protected _fireCellMerged(cell: TableCell$1): void;
    protected _fireAlert(item: ReportItem, message: string): void;
}

interface IOutlineSource {
    outlineParent: IOutlineSource;
    outlineExpandable: boolean;
    outlineItems?: IOutlineSource[];
    outlineLabel: string;
    outlineOrder: number;
    getSaveType(): string;
    canRemoveFrom(): boolean;
    canParentOf?(itemType: string): boolean;
}

declare abstract class ChartObject<T extends ReportGroupItem> extends ReportItem {
    static readonly PROPINFOS: IPropInfo[];
    private _chart;
    constructor(chart: T, name?: string);
    get chart(): T;
    canHide(): boolean;
    getWrapper(): object;
    get page(): ReportPage;
    get report(): Report;
    get dataParent(): ReportGroupItem;
    get marqueeParent(): ReportItem;
    getSaveType(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: any): void;
    protected _isDefaultVisible(): boolean;
    protected _getPropsWrapper(target: any, excludes?: string[], names?: {
        [key: string]: string;
    }): any;
}
declare abstract class ChartTextObject<T extends ReportGroupItem> extends ChartObject<T> {
    static readonly PROP_TEXT = "text";
    static readonly PROPINFOS: IPropInfo[];
    private _text;
    constructor(chart: T);
    /** text */
    get text(): string;
    set text(value: string);
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}
declare abstract class ChartSeries<T extends ReportGroupItem> extends ChartObject<T> {
    static readonly PROP_SERIES_ID = "id";
    static readonly PROP_DESIGN_VISIBLE = "designVisible";
    static readonly PROP_VALUE_FIELD = "valueField";
    static readonly PROP_VALUES = "values";
    static readonly PROPINFOS: IPropInfo[];
    private _id;
    private _designVisible;
    private _valueField;
    private _values;
    constructor(chart: T);
    getPropDomain(prop: IPropInfo): any[];
    abstract get seriesType(): string;
    /**
     * id
     */
    get id(): string;
    set id(value: string);
    /**
     * design visible
     */
    get designVisible(): boolean;
    set designVisible(value: boolean);
    /**
     * valueField
     **/
    get valueField(): string;
    set valueField(value: string);
    /**
     * valueField가 지정되면 이 속성은 무시된다.
     */
    get values(): number[];
    set values(value: number[]);
    hasValuesProp(): boolean;
    getValues(ctx: PrintContext, dp: IReportDataProvider): any[];
    getSaveType(): string;
    get displayPath(): string;
    get outlineLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
declare abstract class ChartSeriesCollection<T extends ReportGroupItem> extends ReportItemCollection<ChartSeries<T>> {
    private _chart;
    protected _series: ChartSeries<T>[];
    constructor(chart?: T);
    get outlineParent(): IOutlineSource;
    get outlineLabel(): string;
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    get owner(): ReportItem;
    /** chart */
    get chart(): T;
    /** count */
    get count(): number;
    get items(): ReportPageItem[];
    get visibleCount(): number;
    load(loader: IReportLoader, src: any): void;
    save(target: any): void;
    get(index: number): ChartSeries<T>;
    indexOf(series: ChartSeries<T>): number;
    add(loader: IReportLoader, series: ChartSeries<T> | ConfigObject$1, index?: number): ChartSeries<T>;
    addAll(loader: IReportLoader, series: (ChartSeries<T> | ConfigObject$1)[], index?: number): boolean;
    removeAt(index: number): boolean;
    remove(series: ChartSeries<T>): boolean;
    clear(): boolean;
    select(series: ChartSeries<T>): void;
    getSaveType(): string;
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    isAncestorOf(item: ReportPageItem): boolean;
    protected abstract _createSeries(loader: IReportLoader, src: any): ChartSeries<T>;
    protected abstract _seriesChanged(series: ChartSeries<T>): void;
    private $_add;
    private $_invalidateSeries;
    private $_seriesChanged;
    protected _doMoveItem(from: number, to: number): boolean;
}

declare enum HichartDash {
    DASH = "Dash",
    DASH_DOT = "DashDot",
    DOT = "Dot",
    LONG_DASH = "LongDash",
    LONG_DASH_DOT = "LongDashDot",
    LONG_DASH_DOT_DOT = "LongDashDotDot",
    SHORT_DASH = "ShortDash",
    SHORT_DASH_DOT = "ShortDashDot",
    SHORT_DASH_DOT_DOT = "ShortDashDotDot",
    SHORT_DOT = "ShortDot",
    SOLID = "Solid"
}
/**
 * Chart title.
 */
declare class HichartTitle extends ChartTextObject<HichartItem> {
    static readonly PROP_TITLE_ALIGN = "align";
    static readonly PROP_TITLE_VERTICAL_ALIGN = "verticalAlign";
    static readonly PROP_TITLE_X = "x";
    static readonly PROP_TITLE_Y = "y";
    static readonly PROPINFOS: IPropInfo[];
    private _align;
    private _verticalAlign;
    private _x;
    private _y;
    constructor(chart: HichartItem);
    /**
     * align
     */
    get align(): Align;
    set align(value: Align);
    /**
     * vertical align
     */
    get verticalAlign(): VerticalAlign;
    set verticalAlign(value: VerticalAlign);
    /**
     * x
     */
    get x(): number;
    set x(value: number);
    /**
     * y
     */
    get y(): number;
    set y(value: number);
    getWrapper(): object;
    getSaveLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
}
declare class HichartSubtitle extends HichartTitle {
    constructor(chart: HichartItem);
    getSaveLabel(): string;
    protected _isDefaultVisible(): boolean;
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
}
declare enum HichartStacking {
    NORMAL = "normal",
    PERCENT = "percent"
}
/**
 * Highcharts chart item.
 */
declare class HichartItem extends ReportGroupItem {
    static readonly PROP_HICHART_THEME = "theme";
    static readonly PROP_HICHART_INVERTED = "inverted";
    static readonly PROP_HICHART_STACKING = "stacking";
    static readonly PROP_HICHART_PLOT_BORDER_WIDTH = "plotBorderWidth";
    static readonly PROP_HICHART_PLOT_BORDER_COLOR = "plotBorderColor";
    static readonly PROP_HICHART_TITLE = "title";
    static readonly PROP_HICHART_SUBTITLE = "subtitle";
    static readonly PROP_HICHART_XAXIS = "xAxis";
    static readonly PROP_HICHART_YAXIS = "yAxis";
    static readonly PROP_HICHART_LEGEND = "legend";
    static readonly PROP_HICHART_SERIES = "series";
    static readonly PROPINFOS: IPropInfo[];
    static readonly STYLE_PROPS: string[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Highchart";
    private _theme;
    private _inverted;
    private _stacking;
    private _plotBorderWidth;
    private _plotBorderColor;
    private _colors;
    private _title;
    private _subtitle;
    private _xAxis;
    private _yAxis;
    private _legend;
    private _series;
    constructor(name: string);
    get outlineItems(): IOutlineSource[];
    /** theme */
    get theme(): string;
    set theme(value: string);
    /** inverted */
    get inverted(): boolean;
    set inverted(value: boolean);
    /** stacking */
    get stacking(): HichartStacking;
    set stacking(value: HichartStacking);
    /** plotBorderWidth */
    get plotBorderWidth(): number;
    set plotBorderWidth(value: number);
    /** plotBorderColor */
    get plotBorderColor(): string;
    set plotBorderColor(value: string);
    /** title */
    get title(): HichartTitle;
    /** subtitle */
    get subtitle(): HichartSubtitle;
    /** xAxis */
    get xAxis(): HichartXAxis;
    /** yAxis */
    get yAxis(): HichartYAxis;
    /** legend */
    get legend(): HichartLegend;
    /** series */
    get series(): HichartSeriesCollection;
    /**
     * 시리즈들을 Hichart 모델이 아니라 HichartItem의 자식으로 설정한다.
     * 시리즈에 대응하는 별도의 view는 존재하지 않지만,
     * Outline view에는 별도의 항목으로 표시돼서 chart와 별도로 속성을 편집할 수 있게 한다.
     */
    addSeries(series: any, index?: number): HichartSeries;
    removeSeries(series: HichartSeries): void;
    selectSeries(series: HichartSeries): void;
    getParentBand(): DataBand;
    getSaveType(): string;
    get outlineLabel(): string;
    needDesignWidth(): boolean;
    needDesignHeight(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    canAddTo(group: ReportGroupItem): boolean;
    private $_seriesChanged;
}
/**
 * Axis title.
 */
declare class HichartAxisTitle extends ChartTextObject<HichartItem> {
    static readonly PROPINFOS: IPropInfo[];
    constructor(chart: HichartItem);
    getSaveLabel(): string;
    canRotate(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}
declare class HichartAxisLabels extends ChartObject<HichartItem> {
    static readonly PROP_ALIGN = "align";
    static readonly PROP_FORMAT = "format";
    static readonly PROP_PADDING = "padding";
    static readonly PROP_STAGGER_LINES = "staggerLines";
    static readonly PROP_STEP = "step";
    static readonly PROPINFOS: IPropInfo[];
    private _align;
    private _format;
    private _padding;
    private _staggerLines;
    private _step;
    constructor(chart: HichartItem);
    /** align */
    get align(): Align;
    set align(value: Align);
    /** format */
    get format(): string;
    set format(value: string);
    /** padding */
    get padding(): number;
    set padding(value: number);
    /** staggerLines */
    get staggerLines(): number;
    set staggerLines(value: number);
    /** step */
    get step(): number;
    set step(value: number);
    canRotate(): boolean;
    getSaveLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}
declare class HichartAxisPlotLabel extends ChartObject<HichartItem> {
    static readonly PROP_ALIGN = "align";
    static readonly PROP_VERTICAL_ALIGN = "verticalAlign";
    static readonly PROP_TEXT = "text";
    static readonly PROP_TEXT_ALIGN = "textAlign";
    static readonly PROP_X = "x";
    static readonly PROP_Y = "y";
    static readonly PROPINFOS: IPropInfo[];
    private static readonly styleProps;
    private _align;
    private _verticalAlign;
    private _text;
    private _textAlign;
    private _x;
    private _y;
    constructor(chart: HichartItem);
    /** align */
    get align(): Align;
    set align(value: Align);
    /** verticalAlign */
    get verticalAlign(): VerticalAlign;
    set verticalAlign(value: VerticalAlign);
    /** text */
    get text(): string;
    set text(value: string);
    /** textAlign */
    get textAlign(): Align;
    set textAlign(value: Align);
    /** x */
    get x(): number;
    set x(value: number);
    /** y */
    get y(): number;
    set y(value: number);
    getSaveLabel(): string;
    canRotate(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}
declare class HichartAxisPlotLine extends ReportItemCollectionItem {
    static readonly PROP_VALUE = "value";
    static readonly PROP_COLOR = "color";
    static readonly PROP_WIDTH = "width";
    static readonly PROP_DASH_STYLE = "dashStyle";
    static readonly PROP_LABEL = "label";
    static readonly PROP_Z_INDEX = "zIndex";
    static readonly PROPINFOS: IPropInfo[];
    private _value;
    private _color;
    private _width;
    private _dashStyle;
    private _zIndex;
    private _index;
    private _label;
    constructor(collection: HichartAxisPlotLineCollection, src: any);
    /** value */
    get value(): number;
    set value(value: number);
    /** color */
    get color(): string;
    set color(value: string);
    /** width */
    get width(): number;
    set width(value: number);
    /** dashStyle */
    get dashStyle(): HichartDash;
    set dashStyle(value: HichartDash);
    /** zIndex */
    get zIndex(): number;
    set zIndex(value: number);
    get label(): HichartAxisPlotLabel;
    get itemType(): string;
    get index(): number;
    get page(): ReportPage;
    get collection(): HichartAxisPlotLineCollection;
    get displayPath(): string;
    get marqueeParent(): ReportItem;
    protected _getStyleProps(): string[];
    getEditProps(): IPropInfo[];
    protected _doLoad(src: any): void;
    protected _doSave(target: any): void;
    getWrapper(): object;
    getCollectionLabel(): string;
}
declare class HichartAxisPlotLineCollection extends ReportItemCollection<HichartAxisPlotLine> {
    private _owner;
    private _lines;
    constructor(owner: HichartAxis);
    get owner(): ReportItem;
    get axis(): HichartAxis;
    load(src: any): void;
    save(target: any): void;
    indexOf(item: HichartAxisPlotLine): number;
    add(line: HichartAxisPlotLine | ConfigObject$1, index?: number): HichartAxisPlotLine;
    remove(line: HichartAxisPlotLine): void;
    getWrapper(): any;
    get count(): number;
    get items(): ReportPageItem[];
    get outlineParent(): IOutlineSource;
    get outlineExpandable(): boolean;
    get outlineLabel(): string;
    get outlineItems(): IOutlineSource[];
    isEditableCollection(): boolean;
    getCollectionLabel(): string;
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get marqueeParent(): ReportItem;
    get(index: number): HichartAxisPlotLine;
    getSaveType(): string;
    protected _doMoveItem(from: number, to: number): boolean;
    private $_resetLines;
}
declare class HichartAxisPlotBand extends ReportItemCollectionItem {
    static readonly PROP_FROM = "from";
    static readonly PROP_TO = "to";
    static readonly PROP_COLOR = "color";
    static readonly PROP_LABEL = "label";
    static readonly PROP_Z_INDEX = "zIndex";
    static readonly PROPINFOS: IPropInfo[];
    private _color;
    private _from;
    private _to;
    private _zIndex;
    private _index;
    private _label;
    constructor(collection: HichartAxisPlotBandCollection, src: any);
    /** color */
    get color(): string;
    set color(value: string);
    /** from */
    get from(): number;
    set from(value: number);
    /** to */
    get to(): number;
    set to(value: number);
    /** zIndex */
    get zIndex(): number;
    set zIndex(value: number);
    get label(): HichartAxisPlotLabel;
    get itemType(): string;
    get index(): number;
    get page(): ReportPage;
    get collection(): HichartAxisPlotBandCollection;
    get displayPath(): string;
    get marqueeParent(): ReportItem;
    protected _getStyleProps(): string[];
    getEditProps(): IPropInfo[];
    protected _doLoad(src: any): void;
    protected _doSave(target: any): void;
    getWrapper(): object;
    getCollectionLabel(): string;
}
declare class HichartAxisPlotBandCollection extends ReportItemCollection<HichartAxisPlotBand> {
    private _owner;
    private _bands;
    constructor(owner: HichartAxis);
    get owner(): ReportItem;
    get axis(): HichartAxis;
    load(src: any): void;
    save(target: any): void;
    indexOf(item: HichartAxisPlotBand): number;
    add(band: HichartAxisPlotBand | ConfigObject$1, index?: number): HichartAxisPlotBand;
    remove(line: HichartAxisPlotBand): void;
    getWrapper(): any;
    get count(): number;
    get items(): ReportPageItem[];
    get outlineParent(): IOutlineSource;
    get outlineExpandable(): boolean;
    get outlineLabel(): string;
    get outlineItems(): IOutlineSource[];
    isEditableCollection(): boolean;
    getCollectionLabel(): string;
    get page(): ReportPage;
    get displayPath(): string;
    get level(): number;
    get marqueeParent(): ReportItem;
    get(index: number): HichartAxisPlotBand;
    getSaveType(): string;
    protected _doMoveItem(from: number, to: number): boolean;
    private $_resetBands;
}
declare abstract class HichartAxis extends ChartObject<HichartItem> {
    static readonly PROP_TITLE = "title";
    static readonly PROP_CATEGORIES = "categories";
    static readonly PROP_CATEGORY_FIELD = "categoryField";
    static readonly PROP_LABELS = "labels";
    static readonly PROP_MIN_PADDING = "minPadding";
    static readonly PROP_MAX_PADDING = "maxPadding";
    static readonly PROP_PLOT_LINES = "plotLines";
    static readonly PROP_PLOT_BANDS = "plotBands";
    static readonly PROPINFOS: IPropInfo[];
    private _categories;
    private _categoryField;
    private _minPadding;
    private _maxPadding;
    private _title;
    private _labels;
    private _plotLines;
    private _plotBands;
    constructor(chart: HichartItem);
    getPropDomain(prop: IPropInfo): any[];
    getPopupPropLabel(prop: string): string;
    get outlineItems(): IOutlineSource[];
    get outlineExpandable(): boolean;
    get title(): HichartAxisTitle;
    get labels(): HichartAxisLabels;
    /** categories */
    get categories(): string[];
    set categories(value: string[]);
    /** categoryField */
    get categoryField(): string;
    set categoryField(value: string);
    /** minPadding */
    get minPadding(): number;
    set minPadding(value: number);
    /** minPadding */
    get maxPadding(): number;
    set maxPadding(value: number);
    get plotLines(): HichartAxisPlotLineCollection;
    get plotBands(): HichartAxisPlotBandCollection;
    getCategories(ctx: PrintContext, dp: IReportDataProvider): any[];
    abstract getPlotLineConfig(): object;
    abstract getPlotBandConfig(): object;
    get outlineParent(): IOutlineSource;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}
declare class HichartXAxis extends HichartAxis {
    static readonly PROPINFOS: IPropInfo[];
    constructor(chart: HichartItem);
    getPropDomain(prop: IPropInfo): any[];
    getSaveLabel(): string;
    get displayPath(): string;
    get outlineLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
    getPlotLineConfig(): object;
    getPlotBandConfig(): object;
}
declare class HichartYAxis extends HichartAxis {
    static readonly PROP_MIN = "min";
    static readonly PROP_MAX = "max";
    static readonly PROPINFOS: IPropInfo[];
    private _min;
    private _max;
    constructor(chart: HichartItem);
    /** min */
    get min(): number;
    set min(value: number);
    /** max */
    get max(): number;
    set max(value: number);
    getSaveLabel(): string;
    get displayPath(): string;
    get outlineLabel(): string;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
    getPlotLineConfig(): object;
    getPlotBandConfig(): object;
}
declare abstract class HichartSeries extends ChartSeries<HichartItem> {
    static readonly PROP_SERIES_COLOR = "color";
    static readonly PROP_SERIES_COLORS = "colors";
    static readonly PROP_SERIES_COLOR_BY_POINT = "colorByPoint";
    static readonly PROP_SERIES_SHOW_IN_LEGEND = "showInLegend";
    static readonly PROPINFOS: IPropInfo[];
    private _color;
    private _colors;
    private _colorByPoint;
    private _showInLegend;
    constructor(chart: HichartItem);
    /**
     * color
     */
    get color(): string;
    set color(value: string);
    /**
     * colors
     */
    get colors(): string[];
    set colors(value: string[]);
    /**
     * colorByPoint
     */
    get colorByPoint(): boolean;
    set colorByPoint(value: boolean);
    /**
     * showInLegend
     */
    get showInLegend(): boolean;
    set showInLegend(value: boolean);
    canHideMarker(): boolean;
    wrap(target: any): any;
    get outlineParent(): IOutlineSource;
    protected _getEditProps(): IPropInfo[];
    getPropDomain(prop: IPropInfo): any[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getCollectionLabel(): string;
    canRemoveFrom(): boolean;
    getValues(ctx: PrintContext, dp: IReportDataProvider): any[];
    protected _getFieldProps(): string[];
    protected _getValues(ctx: PrintContext, prop: string, dp: IReportDataProvider): number[];
}
declare class HichartSeriesCollection extends ChartSeriesCollection<HichartItem> {
    constructor(chart?: HichartItem);
    getIds(exept: string): string[];
    getCollectionLabel(): string;
    isCollectionProp(): boolean;
    protected _createSeries(loader: IReportLoader, src: any): HichartSeries;
    protected _seriesChanged(series: HichartSeries): void;
}
declare enum HichartLegendLayout {
    HORIZONTAL = "horizontal",
    VERTICAL = "vertical",
    PROXIMATE = "proximate"
}
declare class HichartLegend extends ChartObject<HichartItem> {
    static readonly PROP_HICHART_ALIGN = "align";
    static readonly PROP_HICHART_VERTICAL_ALIGN = "verticalAlign";
    static readonly PROP_HICHART_LAYOUT = "layout";
    static readonly PROP_HICHART_FLOATING = "floating";
    static readonly PROP_HICHART_X = "x";
    static readonly PROP_HICHART_Y = "y";
    static readonly PROP_HICHART_BORDER_WIDTH = "borderWidth";
    static readonly PROP_HICHART_SHADOW = "shadow";
    static readonly PROPINFOS: IPropInfo[];
    private _layout;
    private _align;
    private _verticalAlign;
    private _floating;
    private _x;
    private _y;
    private _borderWidth;
    private _shadow;
    constructor(chart?: HichartItem);
    /** align */
    get align(): Align;
    set align(value: Align);
    /** verticalAlign */
    get verticalAlign(): VerticalAlign;
    set verticalAlign(value: VerticalAlign);
    /** layout */
    get layout(): HichartLegendLayout;
    set layout(value: HichartLegendLayout);
    /**
     * flaoting
     */
    get floating(): boolean;
    set floating(value: boolean);
    /**
     * x
     */
    get x(): number;
    set x(value: number);
    /**
     * y
     */
    get y(): number;
    set y(value: number);
    /**
     * border width
     */
    get borderWidth(): number;
    set borderWidth(value: number);
    /**
     * flaoting
     */
    get shadow(): boolean;
    set shadow(value: boolean);
    getSaveLabel(): string;
    protected _isDefaultVisible(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    getWrapper(): object;
}

/**
 * Report loader spec.
 */
interface IReportLoader {
    createItem(type: any): ReportItem;
    createHichartSeries(chart: HichartItem, src: any): HichartSeries;
}

interface ISelectionSource {
    selectItem: ReportPageItem;
    canSelectedWith(other: ISelectionSource): boolean;
}
declare enum DropResultType {
    PROP = "prop"
}
interface IDropResult {
    type: DropResultType;
    prop?: string;
    value?: any;
}
/**
 * Report page 구성 요소 기반 클래스.
 * 현재, ReportItem, TableBandField가 있다.
 */
declare abstract class ReportPageItem extends Base$1 implements ISelectionSource, IOutlineSource, IPropertySource {
    get selectItem(): ReportPageItem;
    canSelectedWith(other: ISelectionSource): boolean;
    abstract get outlineParent(): IOutlineSource;
    abstract get outlineExpandable(): boolean;
    abstract get outlineLabel(): string;
    outlineOrder: number;
    get index(): number;
    get outlineItems(): IOutlineSource[];
    abstract getSaveType(): string;
    abstract canRemoveFrom(): boolean;
    canParentOf(itemType: string): boolean;
    abstract getEditProps(): IPropInfo[];
    abstract getStyleProps(): IPropInfo[];
    abstract getSubStyleProps(prop: string): IPropInfo[];
    abstract getPlaceHolder(prop: IPropInfo): string;
    abstract getPropDomain(prop: IPropInfo): any[];
    getProperty(prop: string): any;
    setProperty(prop: string, value: any): void;
    abstract setItemsProperty(sources: IPropertySource[], prop: string, value: any): void;
    abstract getStyle(style: string): string;
    abstract setStyle(style: string, value: string): void;
    abstract getStyleProperty(prop: string): any;
    abstract setStyleProperty(prop: string, value: any): void;
    abstract isChildProp(prop: string): boolean;
    abstract getSubStyleProperty(prop: string, style: string): any;
    abstract setSubStyleProperty(prop: string, style: string, value: any): void;
    abstract setItemsSubStyleProperty(sources: IPropertySource[], prop: string, style: string, value: any): void;
    abstract canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    abstract adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    isReadOnlyProperty(prop: IPropInfo): boolean;
    /**
     * 이 속성 값이 변경되면 전체 property model을 변경해야 하는가?
     */
    isDominantProp(prop: IPropInfo): boolean;
    isCollectionProp(): boolean;
    isEditableCollection(): boolean;
    isCollectionItem(): boolean;
    getPropertySources(): IPropertySource[];
    getCollectionLabel(): string;
    setItemsStyleProperty(sources: IPropertySource[], prop: string, value: any): void;
    getPopupPropLabel(prop: string): string;
    abstract get page(): ReportPage;
    abstract get displayPath(): string;
    abstract get level(): number;
    abstract get styles(): Styles;
    get outlineSource(): IOutlineSource;
    get parent(): ReportGroupItem;
    get dataParent(): ReportGroupItem;
    get displayParent(): ReportPageItem;
    /**
     * 선택됐을 때 표시될 marquee를 생성하는 item.
     */
    get marqueeParent(): ReportItem;
    get printable(): boolean;
    isAncestorOf(item: ReportPageItem): boolean;
    getProps(): any;
    setProps(src: any): void;
    canMove(): boolean;
    protected _loadProp(src: any, prop: string): void;
    protected _loadProps(src: any, ...props: string[]): void;
    protected _loadPropOf(src: any, info: IPropInfo): void;
    protected _loadPropsOf(src: any, infos: IPropInfo[]): void;
    protected _saveProp(target: object, prop: string): void;
    protected _saveProps(target: object, ...props: string[]): void;
    /**
     * 속성값이 undefined 이거나 IPropInfo.default와 동일하면 저장하지 않는다.
     * 속성의 기본값은 undefined이거나 IPropInfo.default와 동일해야 한다!!
     */
    protected _savePropOf(target: object, info: IPropInfo): void;
    protected _savePropsOf(target: object, infos: IPropInfo[]): void;
    protected _loadObject(item: ReportItem, loader: IReportLoader, src: any): void;
    protected _loadObjects(items: ReportItem[], loader: IReportLoader, src: any): void;
    protected _saveObject(item: ReportItem, target: any): void;
    protected _saveObjects(items: ReportItem[], target: any): void;
    protected _arrangePaddingStyles(styles: Styles): void;
    protected _validateSize(v: ValueString): ValueString;
}
declare enum ItemMoveType {
    INNER = "inner",
    OUTER = "outer"
}
declare type ReportItemValueCallback = (ctx: PrintContext, item: ReportItem, row: number, value: any) => any;
declare type ReportItemStyleCallback = (ctx: PrintContext, item: ReportItem, row: number, value: any) => {
    [key: string]: string | undefined;
};
/**
 * Report 구성 요소 기반 클래스.
 *
 * [data]
 * 1. data 속성에 dataProvider에 등록된 리포트 data 이름.
 * 2. value 속성에 "."으로 분리된 값 경로.
 * 3. data를 지정하지 않으면 가장 가까운 조상에 설정된 data.
 * 4. value에 "data::value" 형식으로 지정하면 이 것을 우선.
 */
declare abstract class ReportItem extends ReportPageItem {
    static readonly DEF_DISPLAY_ORDER = 99;
    static readonly PROP_NAME = "name";
    static readonly PROP_TAG = "tag";
    static readonly PROP_LEFT = "left";
    static readonly PROP_RIGHT = "right";
    static readonly PROP_TOP = "top";
    static readonly PROP_BOTTOM = "bottom";
    static readonly PROP_DESIGN_BORDER = "designBorder";
    static readonly PROP_ON_GET_VALUE = "onGetValue";
    static readonly PROP_STYLES = "styles";
    static readonly PROP_ON_GET_STYLES = "onGetStyles";
    static readonly PROP_VISIBLE = "visible";
    static readonly PROP_DATA = "data";
    static readonly PROP_VALUE = "value";
    static readonly PROP_HINT = "hint";
    static readonly PROP_WIDTH = "width";
    static readonly PROP_HEIGHT = "height";
    static readonly PROP_MIN_WIDTH = "minWdth";
    static readonly PROP_MIN_HEIGHT = "minHeight";
    static readonly PROP_LOCKED = "locked";
    static readonly PROP_PAGE_BREAK = "pageBreak";
    static readonly PROP_STYLE_CALLBACK = "styleCallback";
    static readonly PROP_ROTATION = "rotation";
    static readonly DATA_PROP: {
        name: string;
        category: PropCategory;
        type: typeof ListableProperty;
        multiple: boolean;
        default: any;
        domain: any;
    };
    static readonly VALUE_PROP: {
        name: string;
        category: PropCategory;
        type: typeof ListableProperty;
        multiple: boolean;
        default: any;
        domain: any;
        validate: (source: ReportItem, value: any) => void;
    };
    static readonly PROPINFOS: IPropInfo[];
    static readonly SIZE_PROPINFOS: IPropInfo[];
    static readonly VALUE_PROPINFOS: IPropInfo[];
    static findFloatingAnchor(item: ReportPageItem): ReportItem;
    private _name;
    private _tag;
    private _visible;
    private _data;
    private _value;
    private _valueCallback;
    private _onGetValue;
    private _hint;
    private _width;
    private _height;
    private _minWidth;
    private _minHeight;
    private _rotation;
    private _styles;
    private _styleCallback;
    private _onGetStyles;
    private _pageBreak;
    private _designOrder;
    private _designBorder;
    private _parent;
    private _index;
    private _childPropInfos;
    private _childProps;
    private _valueCallbackFunc;
    private _valueCallbackDelegate;
    private _styleCallbackFunc;
    private _styleCallbackDelegate;
    private _leftDim;
    private _rightDim;
    private _topDim;
    private _bottomDim;
    private _widthDim;
    private _heightDim;
    private _minWidthDim;
    private _minHeightDim;
    constructor(name: string);
    get outlineParent(): IOutlineSource;
    get outlineExpandable(): boolean;
    /**
     * Report 편집기에서 수정할 수 있는 속성 정의 목록.
     * 속성이 없는 경우라도 빈 배열을 리턴해야 한다.
     * 각 항목은 아래 속성들을 갖는다.
     * {
     *  name: string,
     *  type: DesignType.
     *  category: string,
     *  domain: any[],
     * }
     */
    getEditProps(): IPropInfo[];
    getStyleProps(): IPropInfo[];
    getSubStyleProps(prop: string): IPropInfo[];
    getPlaceHolder(prop: IPropInfo): string;
    /**
     * @internal
     */
    getData(): IReportData;
    /**
     * @internal
     */
    getDataFieldNames(): string[];
    getPropDomain(prop: IPropInfo): any[];
    getProperty(prop: string): any;
    setProperty(prop: string, value: any): void;
    setItemsProperty(sources: IPropertySource[], prop: string, value: any): void;
    getProperties(props: string[] | ConfigObject$1): ConfigObject$1;
    setProperties(props: ConfigObject$1): void;
    getStyleProperty(prop: string): any;
    setStyleProperty(prop: string, value: any): void;
    getSubStyleProperty(prop: string, style: string): any;
    setSubStyleProperty(prop: string, style: string, value: any): void;
    setItemsSubStyleProperty(sources: IPropertySource[], prop: string, style: string, value: any): void;
    canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    dataNameChanged(data: IReportData, oldName: string): void;
    dataFieldNameChanged(data: IReportData, newName: string, oldName: string): void;
    /** parent */
    get parent(): ReportGroupItem;
    /** dataParent */
    get dataParent(): ReportGroupItem;
    /** index */
    get index(): number;
    /** level */
    get level(): number;
    /** page */
    get page(): ReportPage;
    get report(): Report;
    /** name */
    get name(): string;
    set name(value: string);
    get pathLabel(): string;
    get displayPath(): string;
    /** tag */
    get tag(): string;
    set tag(value: string);
    /** load/save 시 array를 사용하면 true */
    get isArray(): boolean;
    get isBand(): boolean;
    /**
     * false면 자리를 차지하지 않는다.
     */
    get visible(): boolean;
    set visible(value: boolean);
    get removable(): boolean;
    /**
     * IReportData name.
     */
    get data(): string;
    set data(value: string);
    /**
     * 리포트에 지정된 data의 특정 값(들)을 지시하는 경로.
     * "::" 앞쪽에서 설정된 data 이름이 없는 경우,
     * 자신으로 시작해서 Report까지 가장 가까운 곳(dataParent)에 설정된 data에서 값을 가져온다.
     * '${page}', '%{page}', '${pages}', '%{pages}', '${date}', '%{date}' 등으로 print context 값을 지정할 수도 있다.
     */
    get value(): string;
    set value(value: string);
    /**
     * Dom title.
     * 출력 리포트에서 이게 필요한가?
     */
    get hint(): string;
    set hint(value: string);
    /**
     * width
     */
    get width(): ValueString;
    set width(value: ValueString);
    /**
     * height
     */
    get height(): ValueString;
    set height(value: ValueString);
    /**
     * minWidth
     */
    get minWidth(): ValueString;
    set minWidth(value: ValueString);
    /**
     * minHeight
     */
    get minHeight(): ValueString;
    set minHeight(value: ValueString);
    /**
     * rotation
     */
    get rotation(): number;
    set rotation(value: number);
    get isRotated(): boolean;
    /**
     * onGetValue
     */
    get onGetValue(): string;
    set onGetValue(value: string);
    /** valueCallback */
    get valueCallback(): ReportItemValueCallback;
    set valueCallback(value: ReportItemValueCallback);
    /** styles */
    get styles(): Styles;
    set styles(value: Styles);
    /** styleCallback */
    get styleCallback(): ReportItemStyleCallback;
    set styleCallback(value: ReportItemStyleCallback);
    get onGetStyles(): string;
    set onGetStyles(value: string);
    /** pageBreak */
    get pageBreak(): PageBreakMode;
    set pageBreak(value: PageBreakMode);
    /**
     * 아웃라인에 표시되는 라벨명
     */
    get outlineLabel(): string;
    /** designText */
    get designText(): string;
    /** designLevel */
    get designLevel(): number;
    /** childPropInfos */
    get childPropInfos(): IPropInfo[];
    set childPropInfos(value: IPropInfo[]);
    /** floating */
    get floating(): boolean;
    /**
     * outline viewer 등에서 이 아이템이 표시되는 순서.
     * 값이 작을 수록 먼저 표시된다.
     * 기본값은 99.
     */
    get designOrder(): number;
    set designOrder(value: number);
    get designBorder(): boolean;
    set designBorder(value: boolean);
    get isRelativeHeight(): boolean;
    /**
     * ColumnBoxContainer|BoundedContainer
     */
    get left(): any;
    /**
     * ColumnBoxContainer|BoundedContainer
     */
    get right(): any;
    /**
     * RowBoxContainer|BoundedContainer
     */
    get top(): any;
    /**
     * RowBoxContainer|BoundedContainer
     */
    get bottom(): any;
    /**
     * TableContainer.
     * cell row index in table
     */
    get row(): number;
    /**
     * TableContainer.
     * cell column index in table.
     */
    get col(): number;
    /**
     * TableBandRow.
     * 이전 행 값과 동일하면 값을 표시하지 않는다.
     * 값의 비교는 blankFields가 설정되면 그 필드들의 값이 모두 동일한 경우,
     * blankFields가 설정되지 않은 경우 value에 설정된 필드 값이 동일한 경우.
     */
    get equalBlank(): boolean;
    /**
     * TableBandRow.
     * equalBlank가 true일 깨 값을 비교하는 필드들을 ',' 분리해서 지정한다.
     * 이 속성을 지정하지 않으면 value에 지정된 필드의 값으로 비교한다.
     */
    get blankFields(): string;
    /**
     * true로 지정되면 값과 상관 없이 leaf group 내의 모든 셀을 merge한다.
     * 또, 둘 이상의 table row로 출력되는 경우에도 이 아이템이 속한 컬럼 셀들을 모두 병합한다.
     * 한 행으로 구성된 group field에 bind된 아이템에만 적용해야 의미가 있다.
     */
    get mergedInGroup(): boolean;
    /**
     * 디자이너에서 추기될 때 초기값들 설정.
     */
    defaultInit(loader: IReportLoader, group: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    getSaveType(): string;
    /**
     * 하위 object 저장 label.
     * _loadObject(), _saveObject()에서 사용.
     */
    getSaveLabel(): string;
    isContextValue(): boolean;
    /**
     * 아이템이 특별한 부모에 포함될 때 추가되는 속성들.
     * 예를들어 아이템을 table의 cell로 이동시키면 table에 추가하기 전
     * 사용자가 마우스로 지정한 곳에 있는 셀의 'col', 'row' 속성을 설정해서
     * table이 적절히 item을 배치하도록 한다.
     */
    setChildProp(prop: string, value: any): boolean;
    private $_setChildProp;
    isChildProp(prop: string): boolean;
    getChildProp(prop: string, defaultValue?: any): any;
    getChildProps(): any[];
    isStyleProp(prop: string): boolean;
    canParentOf(itemType: string): boolean;
    canAddTo(group: ReportGroupItem): boolean;
    prepareLayout(printing: boolean): void;
    preparePrint(ctx: PrintContext): void;
    getLeft(domain: number): number;
    setLeft(dim: Dimension): void;
    getRight(domain: number): number;
    setRight(dim: Dimension): void;
    getTop(domain: number): number;
    setTop(dim: Dimension): void;
    getBottom(domain: number): number;
    setBottom(dim: Dimension): void;
    getWidth(domain: number): number;
    getHeight(domain: number): number;
    getMinWidth(domain: number): number;
    getMinHeight(domain: number): number;
    canSized(): boolean;
    canResize(dir: ResizeDirection): boolean;
    canResizeWidth(): boolean;
    canResizeHeight(): boolean;
    resize(width: number, height: number): ReportItem;
    canRotate(): boolean;
    hasStyle(style: string): boolean;
    getStyle(style: string): string;
    setStyle(style: string, value: string): void;
    clearStyle(style: string): void;
    clearStyles(css: CSSStyleDeclaration): void;
    load(loader: IReportLoader, source: any): void;
    save(target: object): boolean;
    getFloatingContainer(): FloatingContainer;
    delete(): void;
    isAncestor(group: ReportGroupItem): boolean;
    private $_getValue;
    /**
     * onGetStyles 등 callback 내에서 사용할 수 있게 노출.
     */
    getValue(row: number, field: string): any;
    /**
     * 출력 시 ReportItemElement에서 호출.
     */
    getPrintValue(dp: IReportDataProvider, row: number): any;
    protected _getParentData(): string;
    canRemoveFrom(): boolean;
    canAdoptDragSource(source: any): boolean;
    adoptDragSource(source: any): IDropResult;
    canPageBreak(): boolean;
    isBreakBefore(): boolean;
    isBreakAfter(): boolean;
    getInvalids(report: Report): string[];
    get marqueeParent(): ReportItem;
    get printable(): boolean;
    isReadOnlyProperty(prop: IPropInfo): boolean;
    protected _sizable(): boolean;
    protected _boundable(): boolean;
    /**
     * 리포트 아이템 생성 시, 수행할 초기화 작업을 정의한다.
     *
     * @param loader - 아이템을 로드하는 리포트 로더
     * @param group - 아이템의 상위 리포트그룹아이템
     * @param hintWidth - 아이템 영역 너비
     * @param hintHeight - 아이템 영역 높이
     */
    protected _doDefaultInit(loader: IReportLoader, group: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _getSubStyle(prop: string, style: string): any;
    protected _setSubStyle(prop: string, style: string, value: any): void;
    protected _doApplyStyle(prop: string, value: string, target: CSSStyleDeclaration): boolean;
    protected _setLeft(value: ValueString): void;
    protected _setRight(value: ValueString): void;
    protected _setTop(value: ValueString): void;
    protected _setBottom(value: ValueString): void;
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _getChildStyleProps(prop: string): string[];
    protected _valueable(): boolean;
    protected _datable(): boolean;
    private $_attached;
    protected _doAttached(): void;
    private $_detached;
    protected _doDetached(): void;
    protected _isLoading(): boolean;
    protected _changed(prop: string, newValue: any, oldValue: any): void;
    get stylable(): boolean;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _saveChildPropsOf(target: object, infos: IPropInfo[]): void;
    protected _doSave(target: object): void;
    protected _doPrepareLayout(printing: boolean): void;
    protected _doPreparePrint(ctx: PrintContext): void;
}
/**
 * 하나 이상의 report item을 포함하는 group item 기반 클래스.
 */
declare abstract class ReportGroupItem extends ReportItem {
    static readonly PROP_DESIGN_WIDTH = "designWidth";
    static readonly PROP_DESIGN_HEIGHT = "designHeight";
    static readonly PROPINFOS: IPropInfo[];
    private _designWidth;
    private _designHeight;
    private _items;
    layoutChanged: boolean;
    constructor(name: string);
    get outlineExpandable(): boolean;
    get outlineItems(): IOutlineSource[];
    /**
     * child props를 제공하는가?
     */
    get isChildPropContainer(): boolean;
    /** count */
    get count(): number;
    /** items */
    get items(): ReportItem[];
    /** designWidth */
    get designWidth(): number;
    set designWidth(value: number);
    /** designHeight */
    get designHeight(): number;
    set designHeight(value: number);
    get dataDominant(): boolean;
    get firstChild(): ReportItem;
    get lastChild(): ReportItem;
    get isDataRowContainer(): boolean;
    needDesignWidth(): boolean;
    needDesignHeight(): boolean;
    get(index: number): ReportItem;
    canContainsBand(): boolean;
    canContainsBandGroup(): boolean;
    contains(item: ReportPageItem, deep?: boolean): boolean;
    indexOf(item: ReportPageItem): number;
    getNames(list: string[], recursive?: boolean): string[];
    find(name: string, recursive?: boolean): ReportItem;
    canAdd(item: ReportItem): boolean;
    append(item: ReportPageItem, slient?: boolean): boolean;
    /**
     * @param silent View나 Tool 쪽에서 지정하고 사용한다.
     */
    add(item: ReportPageItem, index?: number, silent?: boolean): boolean;
    canRemove(item: ReportItem): boolean;
    remove(item: ReportItem): void;
    removeLast(): void;
    clear(): void;
    getMoveType(item: ReportItem): ItemMoveType;
    canResizeChild(item: ReportItem, dir: ResizeDirection): boolean;
    search(key: string, options: FindOptions, results: FindResult[]): void;
    canChangeChildProp(item: ReportPageItem, prop: string, value: any): boolean;
    changeChildIndex(child: ReportItem, newIndex: number): boolean;
    canAlign(child: ReportItem): boolean;
    canAlignTo(child: ReportPageItem, to: string): boolean;
    filter(callback: (item: ReportItem) => boolean): ReportItem[];
    getDescendants(all?: boolean, recursive?: boolean): ReportItem[];
    collectInvalids(report: Report, list: {
        item: ReportItem;
        reason: string;
    }[]): void;
    collectBlankItems(childs?: ReportItem[]): ReportItem[];
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _maxChildCount(): number;
    isAncestorOf(item: ReportPageItem): boolean;
    canParentOf(itemType: string): boolean;
    prepareLayout(printing: boolean): void;
    preparePrint(ctx: PrintContext): void;
    protected _getNameOfItems(): string;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _ignoreItems(): boolean;
    save(target: object): boolean;
    dataNameChanged(data: IReportData, oldName: string): void;
    protected get internalItems(): ReportItem[];
    protected _valueable(): boolean;
    protected _loadChildProp(child: ReportItem, prop: string, src: any): void;
    protected _loadChildProps(child: ReportItem, props: string[], src: any): void;
    protected _loadChildPropsOf(child: ReportItem, src: any, infos: IPropInfo[]): void;
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _loadChild(loader: IReportLoader, item: ReportItem, src: any): ReportItem;
    protected _loadItems(loader: IReportLoader, src: any): void;
    protected _doLoadChild(child: ReportItem, src: any): void;
    protected _saveItems(target: any[]): void;
    protected _doSaveItems(target: any[], items: ReportItem[]): void;
    protected _addItem(item: ReportItem, index: number, silent: boolean): ReportItem;
    protected _removeItem(item: ReportItem): number;
    protected _clearItems(): void;
    protected _doItemAdded(item: ReportItem, index: number): void;
    protected _doItemRemoved(item: ReportItem, index: number): void;
    private $_resetIndices;
    private $_childChanged;
    protected _doItemChanged(item: ReportItem, prop: string, value: any, oldValue: any): void;
    protected _setOutlineOrders(start: number, ...items: ReportPageItem[]): void;
}
declare abstract class ReportItemCollectionItem extends ReportPageItem {
    private _collection;
    private _styles;
    constructor(collection: ReportItemCollection<any>, src?: any);
    get outlineParent(): IOutlineSource;
    get outlineExpandable(): boolean;
    get outlineLabel(): string;
    getSaveType(): string;
    canRemoveFrom(): boolean;
    getPropDomain(prop: IPropInfo): any[];
    getStyleProps(): IPropInfo[];
    getStyle(style: string): string;
    setStyle(style: string, value: string): void;
    getStyleProperty(prop: string): string;
    setStyleProperty(prop: string, value: any): void;
    getSubStyleProps(prop: string): IPropInfo[];
    getPlaceHolder(prop: IPropInfo): string;
    setItemsProperty(sources: IPropertySource[], prop: string, value: any): void;
    getSubStyleProperty(prop: string, style: string): any;
    isChildProp(prop: string): boolean;
    setSubStyleProperty(prop: string, style: string, value: any): void;
    setItemsSubStyleProperty(sources: IPropertySource[], prop: string, style: string, value: any): void;
    canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    isCollectionItem(): boolean;
    abstract get itemType(): string;
    /** styles */
    get styles(): Styles;
    set styles(value: Styles);
    load(src: any): void;
    save(target: any): any;
    get collection(): ReportItemCollection<any>;
    get level(): number;
    protected _doLoad(src: any): void;
    protected _doSave(target: any): void;
    protected abstract _getStyleProps(): string[];
    protected _changed(prop: string, newValue: any, oldValue: any): void;
}
declare abstract class ReportItemCollection<T extends ReportPageItem> extends ReportPageItem {
    canRemoveFrom(): boolean;
    canParentOf(itemType: string): boolean;
    getEditProps(): IPropInfo[];
    getStyleProps(): IPropInfo[];
    getSubStyleProps(prop: string): IPropInfo[];
    getPlaceHolder(prop: IPropInfo): string;
    getPropDomain(prop: IPropInfo): any[];
    getProperty(prop: string): any;
    setProperty(prop: string, value: any): void;
    setItemsProperty(sources: IPropertySource[], prop: string, value: any): void;
    getStyleProperty(prop: string): any;
    getStyle(style: string): string;
    setStyle(style: string, value: string): void;
    setStyleProperty(prop: string, value: any): void;
    setItemsStyleProperty(sources: IPropertySource[], prop: string, value: any): void;
    isChildProp(prop: string): boolean;
    getSubStyleProperty(prop: string, style: string): any;
    setSubStyleProperty(prop: string, style: string, value: any): void;
    setItemsSubStyleProperty(sources: IPropertySource[], prop: string, style: string, value: any): void;
    canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    isCollectionProp(): boolean;
    getPropertySources(): IPropertySource[];
    abstract get owner(): ReportItem;
    abstract get count(): number;
    abstract get items(): ReportPageItem[];
    abstract get(index: number): T;
    abstract indexOf(item: T): number;
    preparePrint(ctx: PrintContext): void;
    forEach(callback: (item: T, index: number) => void): void;
    protected abstract _doMoveItem(from: number, to: number): boolean;
    moveItem(from: number, to: number): boolean;
    get styles(): Styles;
    protected _itemChanged(item: ReportPageItem, prop: string, newValue: any, oldValue: any): void;
    protected _itemAdded(item: ReportPageItem): void;
    protected _itemsAdded(items: ReportPageItem[]): void;
    protected _itemRemoved(item: ReportPageItem, oldParent: ReportGroupItem): void;
    protected _itemsRemoved(items: ReportPageItem[]): void;
    protected _indexChanged(): void;
    protected _doPreparePrint(ctx: PrintContext): void;
}
declare enum AnchorPosition {
    CENTER = "center",
    LEFT = "left",
    RIGHT = "right",
    TOP = "top",
    BOTTOM = "bottom",
    INNER_LEFT = "innerLeft",
    INNER_RIGHT = "innerRight",
    INNER_TOP = "innerTop",
    INNER_BOTTOM = "innerBottom"
}
/**
 * 동일 그룹 내의 다른 아이템을 기준점으로 표시되는 아이템.
 * 자식으로 floating을 추가할 수 없다.
 */
declare class FloatingContainer extends ReportGroupItem {
    static readonly PROP_ANCHOR_TARGET = "anchorTarget";
    static readonly PROP_ANCHOR_POSITION = "anchorPosition";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Floating Container";
    private _anchorTarget;
    private _anchorPosition;
    constructor(name: string);
    /** anchorTarget */
    get anchorTarget(): string;
    set anchorTarget(value: string);
    /** anchorPosition */
    get anchorPosition(): AnchorPosition;
    set anchorPosition(value: AnchorPosition);
    getSaveType(): string;
    get outlineLabel(): string;
    protected _maxChildCount(): number;
    protected _boundable(): boolean;
    protected _getEditProps(): IPropInfo[];
    getPropDomain(prop: IPropInfo): any[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    canAdd(item: ReportItem): boolean;
}
/**
 * 자식들의 위치를 지정할 수 있는 container.
 * 위치 설정이 안된 item은 중앙에 정렬 시킨다.
 */
declare abstract class BoundedContainer extends ReportGroupItem {
    static readonly CHILD_PROPS: IPropInfo[];
    constructor(name: string);
    protected _getChildPropInfos(item: ReportItem): IPropInfo[];
    protected _doLoadChild(child: ReportItem, src: any): void;
}
/**
 * 자식을 대리하는 그룹.
 * 자식 하나만 가질 수 있다.
 */
declare abstract class CellGroup extends ReportGroupItem {
    private _item;
    constructor(item: ReportItem, name: string);
    /**
     * item
     */
    get item(): ReportItem;
    get isEmpty(): boolean;
    get isChildPropContainer(): boolean;
    set childPropInfos(value: IPropInfo[]);
    get printable(): boolean;
    protected _maxChildCount(): number;
    protected _doItemChanged(item: ReportItem, prop: string, value: any, oldValue: any): void;
}
/**
 * CellGroup들만을 자식으로 갖는다.
 */
declare abstract class CellContainer extends ReportGroupItem {
    /** @internal */
    noPrepareCell: boolean;
    constructor(name: string);
    contains(item: ReportItem, deep?: boolean): boolean;
    indexOf(item: ReportItem): number;
    findCell(item: ReportItem): CellGroup;
    find(name: string, recursive?: boolean): ReportItem;
    protected _loadChild(loader: IReportLoader, item: ReportItem, src: any): ReportItem;
    protected _addItem(item: ReportItem, index: number, silent: boolean): ReportItem;
    protected _removeItem(item: ReportItem): number;
    protected abstract _prepareCellGroup(item: ReportItem): CellGroup;
    protected _unprepareCellGroup(item: ReportItem): CellGroup;
}
declare enum BandSectionLayout {
    ACROSS_DOWN = "acrossDown",
    DOWN_ACROSS = "downAcross"
}

interface IPropertySource {
    getEditProps(): IPropInfo[];
    getStyleProps(): IPropInfo[];
    getSubStyleProps(prop: string): IPropInfo[];
    isDominantProp(prop: IPropInfo): boolean;
    getPlaceHolder(prop: IPropInfo): string;
    getPropDomain(prop: IPropInfo): any[];
    getProperty(prop: string): any;
    setProperty(prop: string, value: any): void;
    setItemsProperty(sources: IPropertySource[], prop: string, value: any): void;
    getStyleProperty(prop: string): any;
    setStyleProperty(prop: string, value: any): void;
    setItemsStyleProperty(sources: IPropertySource[], prop: string, value: any): void;
    getSubStyleProperty(prop: string, style: string): any;
    setSubStyleProperty(prop: string, style: string, value: any): void;
    setItemsSubStyleProperty(sources: IPropertySource[], prop: string, style: string, value: any): void;
    isReadOnlyProperty(prop: IPropInfo): boolean;
    canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    isCollectionProp(): boolean;
    isEditableCollection(): boolean;
    isCollectionItem(): boolean;
    getCollectionLabel(): string;
    getPropertySources(): IPropertySource[];
    getPopupPropLabel(prop: string): string;
}
interface IPropertyContainer {
    addCollectionItem(collection: IPropertySource): void;
    removeItem(item: IPropertySource): void;
}
declare enum PropCategory {
    DESIGN = "design",
    BASIC = "basic",
    TEXT = "text",
    DATA = "data",
    BOUND = "bound",
    EVENT = "event",
    EDITOR = "editor",
    REPORT = "report",
    PAPER = "paper",
    BOX = "box",
    TABLE = "table",
    BARCODE = "barcode",
    CELL = "cell",
    BAND = "band",
    BAND_GROUP = "band group",
    BAND_CELL = "band cell",
    FIELD = "field",
    COLUMN = "column",
    ROW = "row",
    CHART = "chart",
    TITLE = "title",
    SUBTITLE = "subtitle",
    AXIS = "axis",
    XAXIS = "x Axis",
    YAXIS = "y Axis",
    SERIES = "series",
    LABEL = "label",
    LABELS = "labels",
    DATA_LABELS = "dataLabels",
    MARKER = "marker",
    LEGEND = "legend"
}
interface IPropInfo {
    name: string;
    category: string;
    type: any;
    typeProps?: any;
    parent?: string;
    indented?: boolean;
    calculated?: boolean;
    collection?: boolean;
    visible?: (source: IPropertySource) => boolean;
    multiple?: boolean;
    default?: any;
    readonly?: boolean;
    domain?: any[] | any;
    label?: string;
    tag?: string;
    params?: any;
    signature?: string;
    validate?: (source: IPropertySource, inputValue: any) => void;
    refresh?: boolean;
    description?: string;
}

/**
 * 자식 item들을 순서대로 쌓아가며 배치한다.
 * 위치 설정이 안된 item은 중앙에 정렬 시킨다.
 */
declare class StackContainer extends BoundedContainer {
    static readonly PROP_OVERFLOW = "overflow";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Stack Container";
    static readonly STYLE_PROPS: string[];
    private _overflow;
    constructor(name: string);
    /**
     * true로 설정되면 자식이 넘칠 수 있다.
     * 특히, table을 자식으로 갖는 경우 true로 설정해야 우측 끝이 표시되는 경우가 있을 수 있다.
     */
    get overflow(): boolean;
    set overflow(value: boolean);
    get outlineLabel(): string;
    getSaveType(): string;
    protected _datable(): boolean;
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _getStyleProps(): string[];
    canAlign(child: ReportItem): boolean;
    canAdoptDragSource(source: any): boolean;
    getMoveType(item: ReportItem): ItemMoveType;
}

/**
 * 리포트 페이지의 수평 전체와 수직 일부를 차지하는 영역 그룹 item.
 * body를 제외하고 페이지를 넘어갈 수 없다.
 */
declare abstract class PageSection extends StackContainer {
    constructor(name: string);
    get removable(): boolean;
    get page(): ReportPage;
    canMove(): boolean;
    getSaveType(): string;
    canResize(dir: ResizeDirection): boolean;
    protected _getStyleProps(): string[];
}
/**
 * 섹션 위아래에 공간(space)를 설정할 수 있는 page 섹션.
 */
declare abstract class SpaceableSection extends PageSection {
    static readonly PROP_SPACE_TOP = "spaceTop";
    static readonly PROP_SPACE_BOTTOM = "spaceBottom";
    static readonly PROPINFOS: IPropInfo[];
    private _spaceTop;
    private _spaceBottom;
    constructor(name: string);
    /**
     * spaceTop
     */
    get spaceTop(): number;
    set spaceTop(value: number);
    /**
     * spaceBottom
     */
    get spaceBottom(): number;
    set spaceBottom(value: number);
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _getEditProps(): IPropInfo[];
}
/**
 * Report header model.
 */
declare class ReportHeader extends SpaceableSection {
    static readonly $_ctor: string;
    constructor();
    get outlineLabel(): string;
    get pathLabel(): string;
    canResize(dir: ResizeDirection): boolean;
}
/**
 * Report footer model.
 */
declare class ReportFooter extends SpaceableSection {
    static readonly PROP_ALIGN_TO_BOTTOM = "alignToBottom";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    private _alignToBottom;
    constructor();
    /**
     * wrap
     */
    get alignToBottom(): boolean;
    set alignToBottom(value: boolean);
    get outlineLabel(): string;
    get pathLabel(): string;
    canResize(dir: ResizeDirection): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}
/**
 * Report page header model.
 */
declare class PageHeader extends SpaceableSection {
    static readonly $_ctor: string;
    constructor();
    get outlineLabel(): string;
    get pathLabel(): string;
    canResize(dir: ResizeDirection): boolean;
}
/**
 * Report page footer model.
 */
declare class PageFooter extends SpaceableSection {
    static readonly $_ctor: string;
    constructor();
    get outlineLabel(): string;
    get pathLabel(): string;
    canResize(dir: ResizeDirection): boolean;
}

/** @internal */
declare abstract class BoundedContainerElement<T extends BoundedContainer> extends ReportGroupItemElement<T> {
    constructor(doc: Document, model: T, name: string);
    protected _prepareChild(child: ReportElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _layoutItem(ctx: PrintContext, child: ReportElement, model: ReportItem, x: number, y: number, width: number, height: number): void;
    protected _layoutChild(ctx: PrintContext, child: ReportElement, x: number, y: number, width: number, height: number): void;
}

/** @internal */
declare abstract class StackContainerElement<T extends StackContainer> extends BoundedContainerElement<T> {
    constructor(doc: Document, model: T, name?: string);
    get debugLabel(): string;
    protected _doSetStyles(model: ReportItem, dom: HTMLElement): void;
    protected _getPrev(item: ReportItemView): ReportItemView;
    protected _getNext(item: ReportItemView): ReportItemView;
    getUpper(item: ReportItemView): ReportItemView;
    getLower(item: ReportItemView): ReportItemView;
    private $_getSorted;
}

/** @internal */
declare abstract class SectionElement<T extends PageSection> extends StackContainerElement<T> {
    constructor(doc: Document, model: T, name: string);
    protected _doDispose(): void;
    protected _needDesignBox(): boolean;
    protected _isContexable(): boolean;
    protected _doPrepareMeasure(ctx: PrintContext, dom: HTMLElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    measure(ctx: PrintContext, hintWidth: number, hintHeight: number): Size$1;
}
/** @internal */
declare class ReportHeaderElement extends SectionElement<ReportHeader> {
    constructor(doc: Document, model?: ReportHeader);
    protected _doDispose(): void;
    get debugLabel(): string;
    protected _getCssSelector(): string;
}
/** @internal */
declare class ReportFooterElement extends SectionElement<ReportFooter> {
    static readonly STYLE_NAME = "rr-page-header rr-group-element";
    static isFooter: (div: HTMLElement) => boolean;
    constructor(doc: Document, model?: ReportFooter);
    protected _doDispose(): void;
    get debugLabel(): string;
    protected _getCssSelector(): string;
}
/** @internal */
declare class PageHeaderElement extends SectionElement<PageHeader> {
    constructor(doc: Document, model?: PageHeader);
    protected _doDispose(): void;
    get debugLabel(): string;
    protected _getCssSelector(): string;
    protected _isContexable(): boolean;
}
/** @internal */
declare class PageFooterElement extends SectionElement<PageFooter> {
    constructor(doc: Document, model?: PageFooter);
    protected _doDispose(): void;
    get debugLabel(): string;
    protected _getCssSelector(): string;
    protected _isContexable(): boolean;
}

/**
 * @internal
 * View base for BoxContainer.
 */
declare abstract class BoxContainerElement<T extends BoxContainer> extends ReportGroupItemElement<T> {
    protected _container: ReportGroupItemView;
    protected _paddings: any;
    protected _gap: number;
    constructor(doc: Document, model: T, name: string);
    get gap(): number;
    get debugLabel(): string;
    protected _needDesignBox(): boolean;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _doSetStyles(model: ReportItem, dom: HTMLElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _doAfterMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number, sz: Size$1): void;
}
/**
 * View for ColumnBoxContainer
 */
declare class ColumnBoxContainerElement extends BoxContainerElement<ColumnBoxContainer> {
    private _points;
    constructor(doc: Document, model: ColumnBoxContainer, name?: string);
    protected _doDispose(): void;
    getRowPoints(): number[];
    get debugLabel(): string;
    protected _getCssSelector(): string;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _doLayoutContent(ctx: PrintContext): void;
    protected _layoutItem(ctx: PrintContext, child: ReportElement, model: ReportItem, x: number, y: number, width: number, height: number): void;
    getLeft(view: ReportItemView): ReportItemView;
    getRight(view: ReportItemView): ReportItemView;
}

/** @internal */
declare class PageBodyElement extends ReportElement {
    private _model;
    private _findable;
    private _backContainerView;
    private _frontContainerView;
    private _itemsView;
    private _modelChanged;
    constructor(doc: Document, model?: PageBody);
    protected _doDispose(): void;
    /** model */
    get model(): PageBody;
    set model(value: PageBody);
    /** empty */
    get empty(): boolean;
    get itemsView(): ColumnBoxContainerElement;
    isPageDom(dom: HTMLElement): boolean;
    findElement(modelName: string): ReportItemElement<ReportItem>;
    findElementOf(dom: HTMLElement): ReportItemElement<ReportItem>;
    getElementOf(model: ReportPageItem): ReportElement;
    /**
     * 페이지의 한 행을 전부 차지하는가?
     */
    isLine(view: ReportItemView): boolean;
    /**
     * view가 포함된 line.
     * view가 line이면 view.
     */
    getLineOf(view: ReportItemView): ReportItemView;
    getSiblingLine(line: ReportItemView, delta: number): ReportItemView;
    /**
     * @param index 0보다 작으면 뒤에서 부터. -1이면 마지막 line.
     */
    getLine(index: number): ReportItemView;
    getLines(): ReportItemView[];
    printAll(doc: Document, ctx: PrintContext): PageBodyOutput;
    prepareAsync(doc: Document, ctx: PrintContext): PrintLine[];
    itemOfDom(dom: Element): ReportItem;
    protected _getCssSelector(): string;
    get debugLabel(): string;
    get findable(): boolean;
    set findable(value: boolean);
    protected _debugBorder(): string;
    protected _debugColor(): string;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    protected _doLayoutContent(ctx: PrintContext): void;
    layoutFloating(ctx: PrintContext): void;
    private $_buildPages;
    private $_prepareAsync;
}
interface PageBodyOutput {
    pages: HTMLDivElement[][];
}

/** @internal */
declare class PageItemContainerElement extends BoundedContainerElement<PageItemContainer> {
    private _emptySize;
    private _findable;
    constructor(doc: Document, model: PageItemContainer, name: string, emptySize?: boolean);
    protected _doDispose(): void;
    get isLayer(): boolean;
    get findable(): boolean;
    set findable(value: boolean);
    get debugLabel(): string;
    get lazyLayout(): boolean;
    protected _getCssSelector(): string;
    protected _needDesignBox(): boolean;
    protected _isEmptySize(): boolean;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _prepareChild(child: ReportElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
}

declare type PrintPageCallback = (ctx: PrintContext, page: PrintPage, pageNo: number) => void;
declare type PrintEndCallback = (ctx: PrintContext, pages: PrintPage[]) => void;
/** @internal */
declare class PageView extends LayerElement$1 {
    private _model;
    private _reportHeaderView;
    private _reportFooterView;
    private _pageHeaderView;
    private _pageFooterView;
    private _bodyView;
    private _backView;
    private _frontView;
    private _sections;
    private _sectionGuard;
    constructor(doc: Document);
    protected _doDispose(): void;
    /** model */
    get model(): ReportPage;
    /** reportHeaderView */
    get reportHeaderView(): ReportHeaderElement;
    /** reportFooterView */
    get reportFooterView(): ReportFooterElement;
    /** pageHeaderView */
    get pageHeaderView(): PageHeaderElement;
    /** pageFooterView */
    get pageFooterView(): PageFooterElement;
    /** bodyView */
    get bodyView(): PageBodyElement;
    /** backFloatingView */
    get backFloatingView(): PageItemContainerElement;
    /** frontFloatingView */
    get frontFloatingView(): PageItemContainerElement;
    get sections(): ReportElement[];
    isPageDom(dom: HTMLElement): boolean;
    measure(ctx: PrintContext, bounds: Rectangle$1): ISize;
    layout(ctx: PrintContext, bounds: Rectangle$1): void;
    layoutFloating(ctx: PrintContext): void;
    afterRender(ctx: PrintContext): void;
    findElement(modelName: string): ReportElement;
    findElementOf(dom: HTMLElement): ReportElement;
    getElementOf(model: ReportPageItem): ReportElement;
    getAllElements(root: ReportElement, bounds: Rectangle$1): ReportItemView[];
    prepareAsync(doc: Document, ctx: PrintContext): PrintLine[];
    refreshPageHeader(doc: Document, ctx: PrintContext): HTMLDivElement;
    getSections(): ReportElement[];
    /**
     * 페이지의 한 행을 전부 차지하는가?
     */
    isLine(view: ReportItemView): boolean;
    getFirst(): ReportItemView;
    getLast(): ReportItemView;
    getFirstInGroup(group: ReportGroupItemView): ReportItemView;
    getLastInGroup(group: ReportGroupItemView): ReportItemView;
    getPrev(elt: ReportItemView): ReportItemView;
    getNext(elt: ReportItemView): ReportItemView;
    getLeft(elt: ReportItemView): ReportItemView;
    getRight(elt: ReportItemView): ReportItemView;
    getUpper(elt: ReportItemView): ReportItemView;
    getLower(elt: ReportItemView): ReportItemView;
    itemOfDom(dom: Element): ReportItem;
    protected _getCssSelector(): string;
    private $_setModel;
}
/**
 * print page model.
 */
declare class PrintPage {
    page: HTMLDivElement;
    pageHeader: HTMLDivElement;
    pageFooter: HTMLDivElement;
    background: HTMLDivElement;
    contents: HTMLDivElement[];
    foreground: HTMLDivElement;
}

/** @internal */
declare class ReportView extends LayerElement$1 implements IImageContainer {
    static readonly PAGE_HEAD = "rr-page-head";
    static readonly BACK_HEAD = "rr-back-head";
    static readonly FRONT_HEAD = "rr-front-head";
    private static ViewCreators;
    private _model;
    private _loadError;
    private _editable;
    private _emptyView;
    private _pageView;
    private _activePage;
    private _boxMeasurer;
    private _boxInner;
    private _nameMap;
    private _modelDirty;
    private _images;
    constructor(doc: Document, editable?: boolean, printing?: boolean);
    protected _doDispose(): void;
    addImage(url: string): void;
    imageLoaded(url: string): void;
    imagesAllLoaded(): boolean;
    /** editable */
    get editable(): boolean;
    /** model */
    get model(): Report;
    set model(value: Report);
    /** pageView */
    get pageView(): PageView;
    /** loadError */
    get loadError(): string;
    set loadError(value: string);
    get zoom(): number;
    getBoxPaddings(model: ReportItem): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    findElement(modelName: string): ReportElement;
    findElementOf(dom: HTMLElement): ReportElement;
    getElementOf(model: ReportPageItem): ReportElement;
    getItemBoundingRect(element: VisualElement$1, rotated?: boolean): Rectangle$1;
    protected _getCssSelector(): string;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _createEmptyView(doc: Document): VisualElement$1;
    protected _layoutPageBorders(rReport: Rectangle$1, rPage: Rectangle$1): void;
    private $_layout;
    protected _afterLayout(ctx: PrintContext): void;
    $_afterRender(ctx: PrintContext): void;
    $_createElement(item: ReportItem): ReportElement;
    /**
     * PrintContainer.$_print(...)에서 호출한다.
     */
    private $_preparePrint;
    /**
     * PrintContainer.$_print(...)에서 호출한다.
     */
    private $_endPrint;
    protected _modelChanged(): void;
    protected onReportReset(report: Report): void;
    protected onReportPaperChanged(report: Report): void;
    protected onReportItemAdded(report: Report, item: ReportItem, index: number, silent: boolean): void;
    protected onReportItemRemoved(report: Report, item: ReportItem, oldParent: ReportGroupItem): void;
    protected onReportItemsRemoved(report: Report, items: ReportPageItem[]): void;
    protected onReportItemChanged(report: Report, item: ReportItem, prop: string, value: any, oldValue: any): void;
    protected onReportCommandStackChanged(report: Report, cmd: EditCommand$1): void;
}

/**
 * 한 줄 혹은 여러줄의 텍스트를 표시한다.
 * value 속성으로 지정된 data 위치가 타당하면 그 값을, 아니면 text 속성으로 지정한 문자열을 표시한다.
 */
declare abstract class TextItemBase extends ReportItem {
    static readonly PROP_WRAP = "wrap";
    static readonly PROP_MULTI_LINE = "multiLine";
    static readonly PROP_BOOLEAN_FORMAT = "booleanFormat";
    static readonly PROP_NUMBER_FORMAT = "numberFormat";
    static readonly PROP_DATE_FORMAT = "dateFormat";
    static readonly PROP_TEXT_FORMAT = "textFormat";
    static readonly PROP_TEXT_PREFIX = "prefix";
    static readonly PROP_TEXT_SUFFIX = "suffix";
    static readonly PROPINFOS: IPropInfo[];
    static readonly STYLE_PROPS: string[];
    private _wrap;
    private _multiLine;
    private _booleanFormat;
    private _numberFormat;
    private _dateFormat;
    private _textFormat;
    private _prefix;
    private _suffix;
    constructor(name: string);
    /**
     * wrap
     */
    get wrap(): boolean;
    set wrap(value: boolean);
    /**
     * multiLine
     * true면 '<br>'이나 '\n', '\r\n'으로 줄을 나눠 표시한다.
     */
    get multiLine(): boolean;
    set multiLine(value: boolean);
    /**
     * booleanFormat
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * numberFormat
     */
    get numberFormat(): string;
    set numberFormat(value: string);
    /**
     * dateFormat
     */
    get dateFormat(): string;
    set dateFormat(value: string);
    /**
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수,
     * 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) Mr. 홍길동: `'([A-Za-z]*); Mr\. \$1'`,
     * 예) 사업자번호: '(\\d{3})(\\d{2})(\\d{5});$1-$2-$3'
     */
    get textFormat(): string;
    set textFormat(value: string);
    /**
     * 접두어.
     * expression을 이용해서 표현할 수도 있지만,
     * 이 속성으로 설정하면 text와 다른 스타일을 적용할 수 있다.
     */
    get prefix(): string;
    set prefix(value: string);
    /**
     * 접미어.
     * expression을 이용해서 표현할 수도 있지만,
     * 이 속성으로 설정하면 text와 다른 스타일을 적용할 수 있다.
     */
    get suffix(): string;
    set suffix(value: string);
    protected _getEditProps(): IPropInfo[];
    protected _getStyleProps(): string[];
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
    protected _doApplyStyle(prop: string, value: string, target: CSSStyleDeclaration): boolean;
    canRotate(): boolean;
    canAdoptDragSource(source: any): boolean;
    adoptDragSource(source: any): IDropResult;
    canPropAdoptDragSource(prop: IPropInfo, source: any): boolean;
    adoptPropDragSource(prop: IPropInfo, source: any): IDropResult;
    getPrintValue(dp: IReportDataProvider, row: number): any;
}
declare type ContextValueCallback = (ctx: PrintContext) => any;
/**
 * 고정된 텍스트나 데이터 필드의 값을 출력하는 아이템.
 */
declare class TextItem extends TextItemBase {
    static readonly PROP_MULTI_LINE = "multiLine";
    static readonly PROP_TEXT = "text";
    static readonly PROP_ON_GET_CONTEXT_VALUE = "onGetContextValue";
    static readonly PROPINFOS: IPropInfo[];
    static readonly $_ctor: string;
    static readonly ITEM_TYPE = "Text";
    private _text;
    private _contextValueCallback;
    private _onGetContextValue;
    private _contextValueCallbackFunc;
    private _contextValueCallbackDelegate;
    constructor(name: string, text?: string);
    /**
     * text
     */
    get text(): string;
    set text(value: string);
    /**
     * onGetContextValue
     */
    get onGetContextValue(): string;
    set onGetContextValue(value: string);
    /**
     * contextValueCallback
     */
    get contextValueCallback(): ContextValueCallback;
    set contextValueCallback(value: ContextValueCallback);
    getSaveType(): string;
    get outlineLabel(): string;
    get designText(): string;
    get pathLabel(): string;
    isContextValue(): boolean;
    protected _getEditProps(): IPropInfo[];
    protected _doDefaultInit(loader: IReportLoader, parent: ReportGroupItem, hintWidth: number, hintHeight: number): void;
    protected _doLoad(loader: IReportLoader, src: any): void;
    protected _doSave(target: object): void;
}

/** @internal */
declare abstract class TextItemElementBase<T extends TextItemBase> extends ReportItemElement<T> {
    static readonly CLASS_NAME = "rr-text";
    static readonly CLASS_LIST: string;
    static readonly SPAN = "_rr_span_";
    private _span;
    protected _text: string;
    constructor(doc: Document, model: T, name: string);
    protected _doDispose(): void;
    get debugLabel(): string;
    protected _initDom(doc: Document, dom: HTMLElement): void;
    protected _doPrepareMeasure(ctx: PrintContext, dom: HTMLElement): void;
    protected _doMeasure(ctx: PrintContext, dom: HTMLElement, hintWidth: number, hintHeight: number): Size$1;
    _doLayoutContent(ctx: PrintContext): void;
    refreshPrintValues(ctx: PrintContext): void;
    isDom(dom: HTMLElement): boolean;
    protected _getText(m: TextItemBase, v: any): string;
    protected abstract _getPrintText(ctx: PrintContext, m: T): string;
    protected abstract _getDesignText(m: T, system: boolean): string;
}

/**
 * Printing 관련 상태 정보 모델.
 */
declare class PrintContext extends Base$1 {
    private _printing;
    private _compositePrinting;
    private _dp;
    private _desingDp;
    private _assets;
    private _reportView;
    private _pageWidth;
    private _pageHeight;
    private _date;
    private _pageCount;
    private _page;
    private _detailPageCount;
    private _detailPage;
    private _compositePageCount;
    private _compositePage;
    detailRows: number[];
    noValueCallback: boolean;
    preview: boolean;
    report: Report;
    container: HTMLDivElement;
    headerHeight: number;
    footerHeight: number;
    reportHeaderHeight: number;
    reportFooterHeight: number;
    bodyTop: number;
    bodyBottom: number;
    bodyHeight: number;
    y: number;
    h: number;
    yBand: number;
    bandSummaryRuntime: DataBandSummaryRuntime;
    row: number;
    index: number;
    contextable: boolean;
    contextValues: TextItemElementBase<any>[];
    private _userData;
    private _tags;
    private _bandSave;
    async: boolean;
    band: DataBand | CrosstabBand;
    pages: PrintPage[];
    floatings: HTMLDivElement[];
    reportCount: number;
    reportIndex: number;
    prevPages: number;
    firstReport: PrintContext;
    nextReport: PrintContext;
    contextElements: {
        [hash: string]: TextItemElementBase<any>;
    };
    constructor(printing?: boolean, compositePrinting?: boolean);
    /**
     * printing
     */
    get printing(): boolean;
    /**
     * compositePrinting 복합 출력 여부를 반환
     */
    get compositePrinting(): boolean;
    /**
     * data provider
     */
    get dp(): IReportDataProvider;
    set dp(value: IReportDataProvider);
    /**
     * design data provider
     */
    get designDp(): DesignDataManager;
    set designDp(value: DesignDataManager);
    /**
     * assets
     */
    get assets(): AssetManager;
    set assets(value: AssetManager);
    /**
     * reportView
     */
    get reportView(): ReportView;
    set reportView(value: ReportView);
    /**
     * pageWidth
     */
    get pageWidth(): number;
    set pageWidth(value: number);
    /**
     * pageHeight
     */
    get pageHeight(): number;
    set pageHeight(value: number);
    /**
     * date
     */
    get date(): Date;
    /**
     * page count.
     */
    get pageCount(): number;
    /**
     * page index.
     */
    get page(): number;
    /**
     * detail page count.
     */
    get detailPageCount(): number;
    /**
     * detail page index.
     */
    get detailPage(): number;
    /**
     * compositePage count.
     */
    get compositePageCount(): number;
    /**
     * compositePage index.
     */
    get compositePage(): number;
    preparePrint(report?: Report): void;
    preparePage(page: number, allPage: number): void;
    setDetailPage(count: number, page: number): void;
    finishPrint(pageCount: number): void;
    setCompositePageCount(compostePageCount: number): void;
    getUserData(): any;
    getCurrentValue(prop: string): any;
    setTag(tag: string, value: any): void;
    unsetTag(tag: string): void;
    getTag(tag: string, def?: any): any;
    getValue(data: string, row: number, field: string): any;
    saveBand(): void;
    restoreBand(): void;
}
declare class PageBreaker {
}
declare abstract class BandPrintInfo<T extends ReportItem> {
    band: T;
    xBand: number;
    ptsBand: number[];
    wBand: number;
    wCell: number;
    masterRow: number;
    masterValues: any;
    /**
     * rows per page.
     * NaN이 아니면 이 수 만큼만 출력하고 페이지를 넘긴다.
     */
    rpp: number;
    /**
     * end row count
     * NaN이 아니면 이 수만큼 빈 행을 추가한다.
     * endRowCount가 0보다 커서 이전 페이지에서 빈 행들을 추가했는데 다 출력하지 못한 빈 행수.
     */
    erc: number;
    detailRows: number[];
    abstract isEnded(): boolean;
    abstract getRows(): any[];
    abstract getNextPage(doc: Document, ctx: PrintContext, width: number, parent: HTMLDivElement): HTMLDivElement | null;
    setMaxCount(rows: any[], count: number): void;
    isRow(row: any): row is number;
    isBand(row: any): row is BandPrintInfo<any>;
    isGroupHeader(row: any): boolean;
    isGroupFooter(row: any): boolean;
    protected _setX(dom: HTMLElement, x: number): void;
    protected _setY(dom: HTMLElement, y: number): void;
    protected _setPos(dom: HTMLElement, x: number, y: number): void;
    protected _createPage(doc: Document, parent: HTMLDivElement): HTMLDivElement;
}
declare type PrintLine = HTMLElement | BandPrintInfo<any> | PageBreaker;
interface IReportData {
    name: string;
    isBand: boolean;
    getFieldNames(): string[];
    getSaveType(): string;
    getSaveValues(): any;
    getValue(path: string): any;
}
interface IReportDataProvider {
    designTime?: boolean;
    preparePrint(ctx: PrintContext): void;
    getAll(): IReportData[];
    get(name: string): IReportData;
    getContextValue(path: string): any;
    getValue(path: string, row: number): any;
    getValueAt(data: string, path: string, row: number): any;
    getFieldValues(data: string, field: string, rows?: number[]): any[];
    addData?(data: IReportData): boolean;
    removeData?(data: string | IReportData): IReportData;
    dataNameChanged?(data: IReportData, oldName: string): void;
    fieldNameChanged?(data: IReportData, newName: string, oldName: string): void;
}
declare abstract class ReportData$1 extends Base$1 {
    private _name;
    private _dp;
    constructor(name: string, dp: IReportDataProvider);
    get provider(): IReportDataProvider;
    get designTime(): boolean;
    get isBand(): boolean;
    /** name */
    get name(): string;
    set name(value: string);
    preparePrint(ctx: PrintContext, design: boolean): void;
}
/**
 * 단순형 값이나, json 객체를 값으로 지정한다.
 */
declare class SimpleData extends ReportData$1 implements IReportData {
    private _isObj;
    private _values;
    constructor(name: string, values: any);
    /**
     * TODO: array index
     */
    getValue(path?: string): any;
    get sample(): any;
    setSample(values: any): void;
    getFieldNames(): string[];
    getSaveType(): string;
    getSaveValues(): any;
}

interface IPrintReport {
    report: Report;
    data: IReportDataProvider;
}
interface IPrintOptions {
    report: Report | (Report | IPrintReport)[];
    data: IReportDataProvider;
    preview?: boolean;
    id?: string;
    async?: boolean;
    pageMark?: boolean;
    noScroll?: boolean;
    callback?: PrintPageCallback;
    endCallback?: PrintEndCallback;
}
/**
 */
declare class PrintContainer extends VisualContainer$1 {
    static readonly CLASS_NAME = "rr-report-container";
    static readonly PREVIEW_CLASS = "rr-report-preview";
    private static readonly CONFIRM_CLASS;
    private _pageGap;
    private _zoom;
    private _align;
    private _styles;
    traceMode: boolean;
    onZoomed: (scale: number) => void;
    private _context;
    private _errorView;
    private _indicator;
    private _reportView;
    private _reportViews;
    private _contexts;
    private _pages;
    private _preview;
    private _previewId;
    private _options;
    constructor(containerId: string | HTMLDivElement);
    protected _doDispose(): void;
    /** pageCount */
    get pageCount(): number;
    /** page */
    get page(): number;
    set page(value: number);
    /** zoom */
    get zoom(): number;
    set zoom(value: number);
    get pages(): PrintPage[];
    print(options: IPrintOptions): void;
    printSingle(options: IPrintOptions): void;
    private $_printSingle2;
    printAll(options: IPrintOptions): void;
    private $_printAll2;
    isAllRendered(): boolean;
    getPrintHtml(): string;
    setStyles(styles: any): void;
    fitToWidth(): void;
    fitToHeight(): void;
    fitToPage(): void;
    get printing(): boolean;
    protected _doPrepareContainer(dom: HTMLElement): void;
    protected _render(timestamp: number): void;
    protected _doResized(): void;
    private $_showError;
    private $_createIndicator;
    private $_refreshContextValues;
    private $_printAsync;
    private $_print2Async;
    private $_getContainer;
    private $_getPreviewer;
    private $_resetPreviewer;
    private $_addPageSpace;
    private $_buildOutputAsync;
    private $_layoutFloatings;
}

interface PdfFont {
    file: string;
    name: string;
    content: string;
    style?: 'normal' | 'italic';
    weight?: 'normal' | 'bold';
}

declare enum CCITTScheme {
    GROUP_3 = "g3",
    GROUP_3_2D = "g3-2d",
    GROUP_4 = "g4"
}

interface ITiffOptions {
    dpi?: number;
    grayscale?: boolean;
    encoding?: CCITTScheme;
}

interface ImageExportOptions {
    type?: 'png' | 'jpeg' | 'jpg' | 'gif' | 'tif' | 'tiff';
    fileName?: string;
    zipName?: string;
    tiff?: ITiffOptions;
}

interface DocExportOptions {
    type: 'hwp' | 'docx';
    fileName?: string;
}

/**
 * 데이터 필드의 데이터 자료형
 *
 * @remarks
 * {@link DataField.dataType} 에서 사용될 때는 `TEXT`, `NUMBER`, `DATETIME`, `BOOLEAN`, `OBJECT` 으로 사용되며, 적용한 자료형을 제한하고 싶을 때에는 {@link DataField.subType} 에 다음과 같이 부여 가능하다.
 *
 * {@link DataField.dataType | dataType} 이 `TEXT`: `CHAR`
 *
 * {@link DataField.dataType | dataType} 이 `NUMBER`: `INT`, `UNUM`, `UINT`
 *
 * {@link DataField.dataType | dataType} 이 `DATETIME`: `DATE`
 *
 * @example
 * ```js
 * let fields = [{
 * ...
 *      dataType: "text",
 *      subType: "char",
 * ...
 * }]
 *
 * ds.setFields(fields);
 * ```
 */
declare enum ValueType {
    /**
     * 텍스트
     */
    TEXT = "text",
    /**
     * 숫자
     */
    NUMBER = "number",
    /**
     * Boolean
     */
    BOOLEAN = "boolean",
    /**
     * 날짜
     */
    DATETIME = "datetime",
    /**
     * 오브젝트
     */
    OBJECT = "object",
    /**
     * 문자
     *
     * @remarks
     * 0보다 큰 `length` 속성과 더불어 길이가 제한된 문자열로 저장된다. `length`를 0 이하로 지정하면 `text` 기본 자료형과 동일하다.
     */
    CHAR = "char",
    /**
     * 0 이상의 숫자
     */
    UNUM = "unum",
    /**
     * 정수형
     *
     * @remarks
     * `i = v >= 0 ? Math.floor(v) : Math.ceil(v);` 와 같은 방식으로 저장 즉, 1.1이면 1로, -1.1이면 -1로 저장된다.
     */
    INT = "int",
    /**
     * 0 이상의 정수형 값
     * @remarks
     * i = `Math.floor(v);` 와 같은 방식으로 저장된다.
     */
    UINT = "uint",
    /**
     * 시간 부분이 제거된 날짜
     */
    DATE = "date"
}
/**
 * 정렬 방식
 *
 * @remarks
 * {@link DataProviderBase.getDistinctValues | getDistinctValues()}, {@link GridBase.orderBy | orderBy()} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
 * ```
 *
 */
declare enum SortDirection {
    /**
     * 오름차순
     */
    ASCENDING = "ascending",
    /**
     * 내림차순
     */
    DESCENDING = "descending",
    /**
     * 없음
     */
    NONE = "none"
}
/**
 * 대소문자 구분 유형
 *
 * @remarks
 * {@link SortingOptions.textCase}, {@link GridBase.orderBy | orderBy()} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
 * ```
 */
declare enum SortCase {
    /**
     * 구분
     */
    SENSITIVE = "sensitive",
    /**
     * 구분하지 않음
     */
    INSENSITIVE = "insensitive"
}
/**
 * 데이터 수정 이후 정렬 동작 모드
 *
 * @remarks
 * {@link GridBase.sortMode} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.sortMode = "explicit";
 * ```
 */
declare enum SortMode {
    /**
     * 자동
     */
    AUTO = "auto",
    /**
     * 데이터 수정이후 명시적으로 정렬을 수행해야 정렬
     */
    EXPLICIT = "explicit"
}
/**
 * 데이터 수정 이후 필터 동작 모드
 *
 * @remarks
 * {@link GridView.filterMode} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.filterMode = 'explicit';
 * ```
 */
declare enum FilterMode {
    /**
     * 자동
     */
    AUTO = "auto",
    /**
     * 데이터 수정이후 명시적으로 필터링을 수행해야 필터링됨
     */
    EXPLICIT = "explicit"
}
/**
 * 행 그룹 상태일 때 헤더나 푸터의 표시 방법
 *
 * @remarks
 * {@link RowGroup.collapsedAdornments}, {@link RowGroup.expandedAdornments} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.setRowGroup({expandedAdornments: "none"});
 * ```
 */
declare enum RowGroupAdornments {
    /**
     * 표시 안 함, expandedAdornments 상태에서만 적용 가능하다.
     */
    NONE = "none",
    /**
     * 행 그룹 상태일 때 헤더 표시
     */
    HEADER = "header",
    /**
     * 행 그룹 상태일 때 푸터 표시
     */
    FOOTER = "footer",
    /**
     * 행 그룹 상태일 때 summary의 내용을 헤더 위치에 표시
     */
    SUMMARY = "summary",
    /**
     * 행 그룹 상태일 때 헤더와 푸터 둘 다 표시, expandedAdornments 상태에서만 적용
     */
    BOTH = "both"
}
/**
 * 검증 방법
 *
 * @remarks
 * {@link GridBase.setValidations} 등에서 쓰인다.
 *
 * @example
 * ```js
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100",
 *      mode: 'always'
 * })
 * ```
 */
declare enum ValidationMode {
    /**
     * 항상(삽입, 수정) 커밋될 때마다
     */
    ALWAYS = "always",
    /**
     * 수정한 행이 커밋될 때
     */
    UPDATE = "update",
    /**
     * 추가한 행이 커밋될 때
     */
    INSERT = "insert"
}
/**
 * 데이터 검증 결과 수준
 *
 * @remarks
 * {@link GridBase.setValidations} 등에서 쓰인다.
 *
 * @example
 * ```js
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100",
 *      level: 'error'
 * })
 * ```
 */
declare enum ValidationLevel {
    /**
     * 오류
     */
    ERROR = "error",
    /**
     * 경고
     */
    WARNING = "warning",
    /**
     * 정보
     */
    INFO = "info",
    /**
     * 없음
     */
    IGNORE = "ignore"
}
/**
 * 그리드의 각 컬럼의 합계를 계산하는 방식
 *
 * @remarks
 * {@link GridBase.summaryMode} 등에서 설정하여 사용할 수 있다.
 *
 * @example
 *
 * ```js
 * let sum = gridView.getSummary('unitPrice', 'sum');
 * ```
 */
declare enum SummaryMode {
    /**
     * 계산하지 않음
     */
    NONE = "none",
    /**
     * 합, 평균, 최대값, 최소값 등 산술적인 합계를 자동으로 계산
     */
    AGGREGATE = "aggregate",
    /**
     * 분산, 표준 편차 등 통계적 합계를 자동으로 계산
     */
    STATISTICAL = "statistical"
}
/**
 * 컬럼 헤더의 이미지나 체크 박스의 위치 유형
 *
 * @remarks
 * {@link ColumnHeader.checkLocation} 에서 사용된다.
 *
 * @example
 * ```js
 * let col = grid.columnByName('col1')
 * col.header.checkLocation = 'leftEdge';
 * ```
 */
declare enum ColumnHeaderItemLocation {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 왼쪽 모서리
     */
    LEFT_EDGE = "leftEdge",
    /**
     * 오른쪽 모서리
     */
    RIGHT_EDGE = "rightEdge",
    /**
     * 위쪽 모서리
     */
    TOP_EDGE = "topEdge",
    /**
     * 아래쪽 모서리
     */
    BOTTOM_EDGE = "bottomEdge",
    /**
     * 왼쪽
     */
    LEFT = "left",
    /**
     * 오른쪽
     */
    RIGHT = "right",
    /**
     * 위쪽
     */
    TOP = "top",
    /**
     * 아래쪽
     */
    BOTTOM = "bottom",
    /**
     * 가운데
     */
    CENTER = "center"
}
/**
 * @internal
 */
declare enum BlankState {
    NONE = "none",
    HEAD = "head",
    BODY = "body",
    TAIL = "tail"
}
/**
 * 컬럼들의 표시 방식을 조정하는 상수
 *
 * @remarks
 * {@link DisplayOptions.fitStyle} 등에서 쓰인다.
 *
 * @example
 *
 * ```js
 * grid.displayOptions.fitStyle = 'even'
 * ```
 */
declare enum GridFitStyle {
    /**
     * 조정하지 않고 컬럼 너비대로 표시
     */
    NONE = "none",
    /**
     * 표시한 컬럼들의 전체 너비가 그리드 너비보다 작을 경우 비율에 맞춰 남는 크기를 분배
     */
    EVEN = "even",
    /**
     * 항상 그리드 너비에 맞게 늘리거나 축소 (컬럼의 width를 이용)
     */
    EVEN_FILL = "evenFill",
    /**
     * fillWidth가 설정되었다면 이를 이용하여, 그렇지 않다면 even과 동일한 방식으로 그리드를 채움
     */
    FILL = "fill"
}
/**
 * @internal
 */
declare const enum Cursor {
    DEFAULT = "default",
    AUTO = "auto",
    POINTER = "pointer",
    WAIT = "wait",
    MOVE = "move",
    COL_RESIZE = "col-resize",
    ROW_RESIZE = "row-resize",
    CROSSHAIR = "crosshair",
    HORZ_RESIZE = "ew-resize",
    VERT_RESIZE = "ns-resize",
    NESW_RESIZE = "nesw-resize",
    NWSE_RESIZE = "nwse-resize",
    NO_DROP = "no-drop",
    NOT_ALLOWED = "not-allowed"
}
/**
 * 그리드의 셀 종류
 *
 * @remarks
 * {@link ClickData} 등에서 사용된다.
 *
 * @example
 * ```js
 * gridView.onMenuItemClicked =  function (grid, item, clickData) {
 *      console.log(item.label + "was clicked.");
 *      console.log("cellType is: " + clickData.cellType);
 * };
 * ```
 */
declare const enum GridCellType {
    /**
     * 데이터
     */
    DATA = "data",
    /**
     * 헤더
     */
    HEADER = "header",
    /**
     * 푸터
     */
    FOOTER = "footer",
    /**
     * Summary
     */
    SUMMARY = "summary",
    /**
     * 인디케이터
     */
    INDICATOR = "indicator",
    /**
     * 상태 바
     */
    STATE = "state",
    /**
     * 체크 바
     */
    CHECK = "check",
    /**
     * head
     */
    HEAD = "head",
    /**
     * foot
     */
    FOOT = "foot",
    /**
     * sum
     */
    SUM = "sum",
    /**
     * 고정 바
     */
    FIXED_BAR = "fixedbar",
    /**
     * 그룹 헤더
     */
    GROUP_HEADER = "groupHeader",
    /**
     * 그룹 푸터
     */
    GROUP_FOOTER = "groupFooter",
    /**
     * 그룹 바
     */
    GROUP_BAR = "groupBar",
    /**
     * group head
     */
    GROUP_HEAD = "groupHead",
    /**
     * group foot
     */
    GROUP_FOOT = "groupFoot",
    /**
     * 그룹 패널
     */
    GROUP_PANEL = "groupPanel",
    /**
     * 그룹 컬럼
     */
    GROUP_COLUMN = "groupColumn",
    /**
     * 빈 그리드
     */
    GRID_EMPTY = "gridEmpty",
    /**
     * Column Group의 Header
     */
    LAYOUT_HEADER = "layoutHeader"
}
/**
 * 선택 된 행의 표시 형태 (행의 마스크 종류)
 *
 * @remarks
 * {@link DisplayOptions.rowBlockType | rowBlockType}, {@link DisplayOptions.rowHoverType | rowHoverType}, {@link DisplayOptions.rowFocusType | rowFocusType} 등에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.displayOptions.rowBlockCallback = f;
 * grid.displayOptions.rowBlockType = 'row';
 * ```
 */
declare enum RowMaskType {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 인디케이터, 상태바, 체크바, 컬럼을 포함한 영역
     */
    ROW = "row",
    /**
     * 컬럼 영역
     */
    DATA = "data",
    /**
     * 인디케이터, 상태바, 체크바, 컬럼을 포함한 영역 + 빈 영역
     */
    FILL = "fill",
    /**
     * 하나의 셀
     */
    CELL = "cell"
}
/**
 * 대소문자 형태
 *
 * @remarks
 * {@link ValueColumn.textInputCase}, {@link CellEditor.textCase} 등에서 사용된다.
 *
 * @example
 * ```js
 * column.editor = { type: "line", maxLength: 1, textCase: 'lower'}
 * ```
 */
declare enum TextInputCase {
    /**
     * 입력되는 대로 표시
     */
    NORMAL = "normal",
    /**
     * 대문자로 표시
     */
    UPPER = "upper",
    /**
     * 소문자로 표시
     */
    LOWER = "lower",
    /**
     * 편집기에서 이 값으로 설정되면 컬럼에 설정된 값을 따름
     */
    DEFAULT = "default"
}
/**
 * 그리드 컬럼 헤더 클릭 시 정렬 유형
 *
 * @remarks
 * {@link SortingOptions.style} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * grid.sortingOptions.style = 'inclusive'
 * ```
 */
declare enum SortStyle {
    /**
     * 정렬 안 함
     */
    NONE = "none",
    /**
     * 마지막으로 클릭 한 컬럼으로 정렬
     */
    EXCLUSIVE = "exclusive",
    /**
     * 처음으로 클릭 한 컬럼을 우선으로 정렬
     */
    INCLUSIVE = "inclusive",
    /**
     * 마지막으로 클릭한 컬럼을 우선으로 정렬
     */
    REVERSE = "reverse"
}
/**
 * PopupMenu 등에 표시되는 메뉴 항목의 유형
 *
 * @remarks
 * {@link PopupMenuItem."type"} 과 {@link MenuItem."type"} 에서 사용된다.
 *
 * @example
 * ```js
 * let menu = [{
 *      label: "menu3 입니다",
 *      type: "check",
 *      checked: true,
 *  }]
 * ```
 */
declare enum MenuItemType {
    /**
     * 일반 텍스트
     */
    NORMAL = "normal",
    /**
     * 체크박스와 텍스트
     */
    CHECK = "check",
    /**
     * 라디오 버튼과 텍스트
     */
    RADIO = "radio",
    /**
     * 메뉴 항목 간 구분
     */
    SEPARATOR = "separator"
}
/**
 * 핸들의 표시 방법
 *
 * @remarks
 * 소팅(sorting), 필터링(filtering) 시 컬럼 헤더에 표시되는 기능 아이콘을 핸들(Handle)이라고 한다.
 *
 * HandleVisiblity는 {@link SortingOptions }, {@link FilteringOptions } 의 handleVisibility 속성으로 구현되어 있다.
 *
 * @example
 *
 * ```js
 * grid.sortingOptions.handleVisibility = 'visible';
 * ```
 */
declare enum HandleVisibility {
    /**
     * 표시
     */
    VISIBLE = "visible",
    /**
     * 호버링 된 경우만 표시
     */
    HOVERED = "hovered",
    /**
     * 항상 표시
     */
    ALWAYS = "always",
    /**
     * 숨김
     */
    HIDDEN = "hidden"
}
/**
 * 데이터 셀의 우측에 표시할 버튼 종류
 *
 * @remarks
 * {@link ValueColumn.button} 에서 사용된다.
 *
 * @example
 * ```js
 * column.button = 'popup';
 * ```
 */
declare enum CellButton {
    /**
     * 버튼 없음
     */
    NONE = "none",
    /**
     * 실행 버튼 (클릭 시 {@link GridBase.onCellButtonClicked | onCellButtonClicked} 콜백 호출)
     */
    ACTION = "action",
    /**
     * 팝업 메뉴 버튼
     *
     * @remarks
     * 컬럼에 {@link ValueColumn.popupMenu | popupMenu } 속성값이 있고, 컬럼의 popupMenu 값과 {@link GridBase.addPopupMenu | addPopupMenu} 호출 시 name 값과 일치 해야 한다.
     *
     * 팝업 메뉴의 메뉴 항목 클릭 시 {@link GridBase.onMenuItemClicked | onMenuItemClicked} 콜백이 호출된다.
     */
    POPUP = "popup"
}
/**
 * 컬럼에 버튼이 설정된 경우, 데이터 셀에 컬럼 버튼과 편집 버튼을 표시하는 방법
 *
 * @remarks
 * ValueColumn의 {@link ValueColumn.buttonVisibility | buttonVisibility} 속성과 {@link ValueColumn.editButtonVisibility| editButtonVisibility} 속성에 사용된다.
 *
 * @example
 * ```js
 * // 컬럼 버튼
 * column.buttonVisibility = false;
 *
 * // 편집기의 버튼
 * column.editButtonVisibility = false;
 * ```
 */
declare enum ButtonVisibility {
    /**
     * 항상 표시
     */
    ALWAYS = "always",
    /**
     * 마우스가 셀 위에 있거나, 셀을 선택한 상태에서만 표시
     */
    DEFAULT = "default",
    /**
     * 셀을 선택한 상태에서 표시
     */
    VISIBLE = "visible",
    /**
     * 표시하지 않음
     */
    HIDDEN = "hidden",
    /**
     * 행이 선택된 상태에서 표시
     */
    ROWFOCUSED = "rowfocused"
}
/**
 * 그리드를 다시 그릴 때 필요한 상수
 *
 * @remarks
 * {@link DisplayOptions.refreshMode} 에서 사용한다.
 *
 * @example
 * ```js
 * grid.displayOptions.refreshMode = 'visibleOnly';
 * ```
 */
declare enum RefreshMode {
    /**
     * 모든 컬럼들을 다시 그리기
     */
    ALL = "all",
    /**
     * 보이는 컬럼들만 다시 그리기
     */
    VISIBLE_ONLY = "visibleOnly"
}
/**
 * 편집 중 일때 스크롤 시 처리 상태
 *
 * @remarks
 * {@link EditOptions.scrollOnEditing} 에서 설정 가능하다.
 *
 * @example
 * ```js
 * grid.editOptions.scrollOnEditing = 'cancel';
 * ```
 */
declare enum ScrollOnEditing {
    /**
     * 편집 취소
     */
    CANCEL = "cancel",
    /**
     * 커밋
     */
    COMMIT = "commit",
    /**
     * 편집기 유지
     */
    DEFAULT = "default"
}
/**
 * 그리드에서 아이템의 종류
 *
 * @remarks
 * {@link GridBase.getModelAs | getModelAs()} 등에서 사용한다.
 *
 * @example
 * ```js
 * let model = gridView.getModelAs(3, 'row');
 * ```
 */
declare enum ItemType {
    /**
     * 행
     */
    ROW = "row",
    /**
     * 그룹 아이템
     */
    GROUP = "group",
    /**
     * 그룹 푸터
     */
    FOOTER = "footer",
    /**
     * 트리 아이템
     */
    TREE = "tree"
}
/**
 * 필드의 합계값을 계산하기 위한 유형
 *
 * @remarks
 * {@link GridBase.getSummary} 에서 사용된다.
 *
 * @example
 *
 * ```js
 * let sum = gridView.getSummary('unitPrice', 'sum');
 * ```
 */
declare enum SummaryType {
    /**
     * 개수
     */
    COUNT = "count",
    /**
     * 합
     */
    SUM = "sum",
    /**
     * 최대값
     */
    MAX = "max",
    /**
     * 최소값
     */
    MIN = "min",
    /**
     * 평균
     */
    AVG = "avg",
    /**
     * 표본집단 분산
     */
    VAR = "var",
    /**
     * 모집단 분산
     */
    VARP = "varp",
    /**
     * 표본집단 표준편차
     */
    STDEV = "stdev",
    /**
     * 모집단 표준편차
     */
    STDEVP = "stdevp",
    /**
     * 값이 지정되어 잇는 데이터 개수 (null 이 아닌)
     */
    DATACOUNT = "datacount",
    /**
     * `DATACOUNT` 로 나눈 평균
     */
    DATAAVG = "dataavg"
}
/**
 * 행 그룹핑 시 Expander 표시여부
 *
 * @remarks
 * {@link RowGroup.mergeExpanderVisibility} 에서 사용된다.
 *
 * @example
 * ```js
 * gridView.rowGroup.mergeExpanderVisibility = 'always';
 * ```
 */
declare enum ExpanderVisibility {
    /**
     * 행 그룹핑 시 Expander 를 항상 표시한다.
     */
    ALWAYS = "always",
    /**
     * 기본값: 그룹핑 된 행들이 여러 개 보임 상태이면 표시하고 그렇지 않으면 표시하지 않는다.
     */
    DEFAULT = "default",
    /**
     * 행 그룹핑 시 Expander 를 표시하지 않는다.
     */
    NONE = "none"
}
/**
 * tab 입력 시 그리드를 벗어나기 위한 조건
 *
 * {@link EditOptions.exitGridWhenTab} 에서 설정 가능하다.
 *
 * @example
 * ```js
 * grid.editOptions.exitGridWhenTab = 'grid';
 * ```
 */
declare enum ExitGridWhenTab {
    /**
     * 행의 마지막 셀일 경우 벗어난다.
     */
    ROW = "row",
    /**
     * 그리드의 마지막 셀일 경우 벗어난다.
     */
    GRID = "grid",
    /**
     * tab키를 입력했을때 그리드를 벗어나지 않는다.
     */
    NONE = "none"
}
/**
 * focus를 layer형태로 표시하거나 테두리만 표시한다.
 *
 * {@link DisplayOptions.focusType} 에서 설정 가능하다.
 */
declare const enum FocusType {
    /**
     * 선택된 셀을 덮는 layer형태로 표시한다.
     */
    LAYER = "layer",
    /**
     * 선택된 셀의 테두리만 line으로 표시한다.
     */
    LINE = "line"
}
/**
 * edgeMark
 *
 * @remarks
 * {@link ValueColumn.edgeMark}에서 사용된다.
 *
 * @example
 * ```js
 * column.edgeMark = "leftTop"
 * ```
 */
declare const enum EdgeMark {
    /**
     * 왼쪽 위
     */
    LEFT_TOP = "leftTop",
    /**
     * 왼쪽 아래
     */
    LEFT_BOTTOM = "leftBottom",
    /**
     * 오른쪽 위
     */
    RIGHT_TOP = "rightTop",
    /**
     * 오른쪽 아래
     */
    RIGHT_BOTTOM = "rightBottom"
}
/**
 * @internal
 */
declare const enum EventFrom {
    MOUSE_DOWN = "mousedown",
    MOUSE_UP = "mouseup",
    MOUSE_CLICK = "mouseclick",
    KEY_DOWN = "keydown",
    KEY_UP = "keyup"
}
/**
 * @internal
 */
declare const enum SummaryItemType {
    HEADER_SUMMARY = "summary",
    FOOTER = "footer",
    GROUP_FOOTER = "groupFooter"
}
/**
 * 그룹을 접거나 펼쳤을때 보여질것인가를 결정한다.
 *
 * {@link CellLayoutItem.groupShowMode}에서 설정한다.
 *
 * @remarks
 * 상위 layout의 expand상태에 따라서 보이거나 숨도록 한다.
 */
declare enum GroupShowMode {
    /**
     * 그룹을 펼쳤을때 보여진다.
     */
    "EXPAND" = "expand",
    /**
     * 그룹을 접었을때 보여진다.
     */
    "COLLAPSE" = "collapse",
    /**
     * 항상 보여진다.
     */
    "ALWAYS" = "always"
}
/**
 * @public
 *
 * 조회된 data가 모두 보일수 있도록 그리드의 높이를 변경한다.
 *
 * @remarks
 * data가 없는 경우 초기 높이로 표시된다.
 * 많은 data가 출력되는 경우 느려지기 때문에 일부 data만 가져온후 `더보기` 버튼등을 이용해서 data를 추가해야 한다.
 *
 * @defaultValue `none`
 * {@link DisplayOptions.syncGridHeight}에서 설정한다.
 * {@link DisplayOptions.rowHeight}가 `-1`인 경우 사용할수 없다.
 */
declare enum SyncGridHeight {
    /**
     * 지정된 높이를 유지한다.
     */
    "NONE" = "none",
    /**
     * 그리드의 영역보다 커지는 경우 그리드의 높이를 변경한다.
     */
    "OVER" = "over",
    /**
     * 항상 data 영역에 그리드 높이를 맞춘다.
     */
    "ALWAYS" = "always"
}
/**
 * @public
 *
 * Tree Expander에 표시되는 기본 아이콘의 스타일을 지정한다.
 *
 * @defaultValue `triangle`
 */
declare enum TreeExpanderIconStyle {
    /**
     * 삼각형 형태의 Tree Expander 아이콘을 표시한다.
     */
    "TRIANGLE" = "triangle",
    /**
     * 사각형 형태의 Tree Expander 아이콘을 표시한다.
     */
    "SQUARE" = "square"
}

/** @internal */
declare class Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
    static Temp: Rectangle;
    constructor(x?: number, y?: number, width?: number, height?: number);
    /** left */
    get left(): number;
    set left(value: number);
    /** right */
    get right(): number;
    set right(value: number);
    /** top */
    get top(): number;
    set top(value: number);
    /** bottom */
    get bottom(): number;
    set bottom(value: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Rectangle;
    getInner(): Rectangle;
    equals(r: Rectangle): boolean;
    leftBy(delta: number): Rectangle;
    rightBy(delta: number): Rectangle;
    topBy(delta: number): Rectangle;
    bottomBy(delta: number): Rectangle;
    shrink(dx: number, dy: number): Rectangle;
    expand(dx: number, dy: number): Rectangle;
    contains(x: number, y: number): boolean;
    setEmpty(): Rectangle;
    move(x?: number, y?: number): Rectangle;
    set(x: number, y: number, width: number, height: number): Rectangle;
    setWidth(value: number): Rectangle;
    copy(r: Rectangle): Rectangle;
    copyHorz(r: Rectangle): Rectangle;
    copyVert(r: Rectangle): Rectangle;
    inflate(left?: number, top?: number, right?: number, bottom?: number): Rectangle;
    offset(dx: number, dy: number): Rectangle;
    round(): Rectangle;
    union(r: Rectangle): Rectangle;
    normalize(): Rectangle;
    toString(): string;
}

declare type ConfigObject = {
    [key: string]: any;
};

/** @internal */
declare abstract class Base {
    private $_hash;
    private $_disposed;
    constructor(noHash?: boolean);
    dispose(): null;
    protected _doDispose(): void;
    get disposing(): boolean;
    isMe(hash: number): boolean;
    private $_getters;
    /**
     * true를 리턴하면 assign()이 호출되지 않는다.
     */
    protected doAssignSimple(source: any): boolean;
    assignFrom(source: any): void;
    extend(source: ConfigObject): void;
    toProxy(containUndefined?: boolean): ConfigObject;
}

/** @internal */
declare class EventAware extends Base {
    private _listeners;
    constructor();
    protected _doDispose(): void;
    get listenerCount(): number;
    addListener(listener: object, index?: number): EventAware;
    removeListener(listener: object): EventAware;
    clearListener(): void;
    fireEvent(event: string, ...args: any): void;
    fireConfirmEvent(event: string, ...args: any): boolean;
    fireMessageEvent(event: string, ...args: any): string;
    fireObjectEvent(event: string, ...args: any): any;
}

/**
 * @internal
 */
declare class BooleanConverter {
    static readonly Default: BooleanConverter;
    private _format;
    private _values;
    private _sensitive;
    private _trueText;
    private _falseText;
    constructor(format: string);
    /** format */
    get format(): string;
    set format(value: string);
    toBool(value: string): boolean;
    toBoolEx(value: string): boolean;
    toBoolStrict(value: string): boolean;
    toText(value: boolean): string;
    private $_toBool;
    private parse;
}

/** @internal */
declare class DateTimeReader {
    static readonly Formats: string[];
    static readonly Default: DateTimeReader;
    static initialize(): void;
    private _format;
    private _type;
    private _parser;
    constructor(format: string);
    /** format */
    get format(): string;
    set format(value: string);
    /** amText */
    get amText(): string;
    set amText(value: string);
    /** pmText */
    get pmText(): string;
    set pmText(value: string);
    /** baseYear */
    get baseYear(): number;
    set baseYear(value: number);
    toDate(value: string): Date;
    private parse;
}

/**
 * 데이터 필드 모델 객체
 *
 * @remarks
 * {@link DataProviderBase | DataProvider} 의 필드관련 method 에서 사용된다.
 *
 * @example
 * ```js
 * // model
 * let fields = ds.getFields();
 * ds.setFields(fields);
 * ```
 */
interface DataField$1 {
    /**
     * 필드의 인덱스
     * @readonly
     */
    index: number;
    /**
     * 필드명
     *
     * @remarks
     * 읽어올 때에는 대문자로 출력된다.
     *
     * 속성으로 접근 하여 설정하면, {@link DataField.orgFieldName | orgFieldName} 이 그대로 설정되고 해당 속성은 내부적으로 처리하기 위해 대문자로 바뀌어 설정된다.
     */
    fieldName: string;
    /**
     * 지정 당시의 필드명
     * @readonly
     */
    orgFieldName: string;
    /**
     * 자료형
     *
     * @remarks
     * {@link ValueType} 참고
     */
    dataType: ValueType;
    /**
     * 기본 자료형을 제한된 범위로 사용하기 위한 지시자
     *
     * @remarks
     * {@link ValueType} 참고
     *
     * @defaultValue `null`
     */
    subType: ValueType;
    /**
     * {@link DataField.subType | 자료형을 제한 된 범위로 사용하기 위한 지시자} 사용 가능 여부
     *
     * @defaultValue `true`
     */
    subTypeEnabled: boolean;
    /**
     * 기준 필드
     *
     * @remarks
     * 읽어올 때는 대문자로 출력된다.
     *
     * 속성으로 접근하여 설정하면 대문자로 저장된다.
     *
     * 검증 시 사용된다.
     */
    baseField: string;
    /**
     * 데이터 길이
     */
    length: number;
    /**
     * 필드셋
     *
     * @remarks
     * 배열에 포함된 값이 아니면 `undefined`로 저장되게 한다.
     *
     * Boolean 자료형을 제외한 나머지 자료형에서 사용가능하다.
     */
    set: any[];
    /**
     * 최소 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    minimum: number;
    /**
     * 최대 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    maximum: number;
    /**
     * 데이터 필수 여부
     * @alpha
     */
    required: boolean;
    /**
     * 그룹 헤더 타이틀
     *
     * @remarks
     * Row Grouping 시 그룹 헤더의 타이틀에 기준필드의 헤더 값을 표시할 수 있다.
     */
    header: string;
    /**
     * 필드의 기본 데이터 값
     * @remarks
     * 기본값을 지정하면 {@link GridView.beginInsertRow}, {@link GridView.beginAppendRow} 함수 호출시 지정된 기본값이 입력된 상태로 새로운 행이 추가된다.
     */
    defaultValue: any;
    /**
     * 데이터가 `null` 일 때 대체될 데이터
     */
    nullValue: any;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.booleanFormat} 에 설정된 값을 우선한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat: string;
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.datetimeFormat} 에 설정된 값을 우선한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat: string;
    /**
     * 오전 표시 텍스트
     */
    amText: string;
    /**
     * 오후 표시 텍스트
     */
    pmText: string;
    /**
     * 년도 값이 100보다 작을 경우 기준 년도
     *
     * @defaultValue `2000`
     */
    baseYear: number;
    /**
     * calculated 필드일 경우 사용될 수식
     *
     * @remarks
     * values['필드명'], values[필드인덱스]로 참조한다.
     *
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     *
     * @example
     * ```js
     * dataField.valueExpression = "values['Quantity'] * values['UnitPrice']";
     * ```
     */
    valueExpression: string;
    /**
     * calculated 필드일 경우 수식을 지정하여 계산 될 콜백
     *
     * @remarks
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataField.valueCallback = function (provider, dataRow, fieldName, fieldNames, values) {
     *     let quantity = values[fieldNames.indexOf("Quantity")];
     *     let unitprice = values[fieldNames.indexOf("UnitPrice")];
     *     if (isNaN(quantity) || isNaN(unitprice))
     *         return undefined;
     *     else
     *         return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
     * }
     * ```
     */
    valueCallback: FieldValueCallback;
    /**
     * calculated 필드인지 여부
     *
     * @remarks
     * {@link DataField.valueExpression | valueExpression} 이나 {@link DataField.valueCallback | valueCallback} 이 설정되어 있으면 calculated 이다.
     *
     * @readonly
     */
    calculated: boolean;
    /**
     * 필드값 수정 가능 여부
     */
    updatable: boolean;
}
/**
 * 설정할 때 사용하는 {@link DataField} 와 동일한 구조의 오브젝트
 *
 * @remarks
 * {@link DataProviderBase.setFields | setFields()} 에서 사용된다.
 *
 * @example
 * ```js
 * // config
 * ds.setFields({
 *      fieldName: 'OrderID',
 *      dataType: 'text',
 * });
 * ```
 */
interface DataFieldObject {
    /**
     * 필드명
     */
    fieldName?: string;
    /**
     * 자료형
     *
     * @remarks
     * {@link ValueType} 참고
     */
    dataType: ValueType;
    /**
     * 기본 자료형을 제한된 범위로 사용하기 위한 지시자
     *
     * @remarks
     * {@link ValueType} 참고
     *
     * @defaultValue `null`
     */
    subType?: string;
    /**
     * 데이터 길이
     */
    length?: number;
    /**
     * 필드셋
     *
     * @remarks
     * 배열에 포함된 값이 아니면 `undefined`로 저장되게 한다.
     *
     * Boolean 자료형을 제외한 나머지 자료형에서 사용가능하다.
     */
    set?: any[];
    /**
     * 필드의 기본 데이터 값
     * @remarks
     * 기본값을 지정하면 {@link GridView.beginInsertRow}, {@link GridView.beginAppendRow} 함수 호출시 지정된 기본값이 입력된 상태로 새로운 행이 추가된다.
     */
    defaultValue?: any;
    /**
     * 기준 필드
     *
     * @remarks
     * 검증 시 사용된다.
     */
    baseField?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.booleanFormat} 에 설정된 값을 우선한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * {@link DataOutputOptions.datetimeFormat} 에 설정된 값을 우선한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat?: string;
    /**
     * 오전 표시 텍스트
     */
    amText?: string;
    /**
     * 오후 표시 텍스트
     */
    pmText?: string;
    /**
     * @alpha
     */
    objectKey?: string;
    /**
     * @alpha
     */
    objectCallback?: any;
    /**
     * 최소 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    minimum?: number;
    /**
     * 최대 범위의 한계값
     *
     * @remarks
     * 숫자 또는 날짜형 자료형일 때 사용 가능하다.
     */
    maximum?: number;
    /**
     * 데이터 필수 여부
     * @alpha
     */
    required?: boolean;
    /**
     * 년도 값이 100보다 작을 경우 기준 년도
     *
     * @defaultValue `2000`
     */
    baseYear?: number;
    /**
     * calculated 필드일 경우 사용될 수식
     *
     * @remarks
     * values['필드명'], values[필드인덱스]로 참조한다.
     *
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     *
     * @example
     * ```js
     * ds.setFields({
     *      fieldName: 'TotalPrice',
     *      dataType: 'text',
     *      valueExpression: "values['Quantity'] * values['UnitPrice']"
     * });
     * ```
     */
    valueExpression?: string;
    /**
     * calculated 필드일 경우 수식을 지정하여 계산 될 콜백
     *
     * @remarks
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     * @eventProperty
     *
     * @example
     * ```js
     * ds.setFields({
     *      fieldName: 'TotalPrice',
     *      dataType: 'text',
     *      valueCallback: function (dataRow, fieldName, fieldNames, values) {
     *          let quantity = values[fieldNames.indexOf("Quantity")];
     *          let unitprice = values[fieldNames.indexOf("UnitPrice")];
     *          if (isNaN(quantity) || isNaN(unitprice))
     *              return undefined;
     *          else
     *              return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
     *      }
     * });
     * ```
     */
    valueCallback?: FieldValueCallback;
    /**
     * 그룹 헤더 타이틀
     *
     * @remarks
     * Row Grouping 시 그룹 헤더의 타이틀에 기준필드의 헤더 값을 표시할 수 있다.
     */
    header?: string;
}
/**
 * 데이터 필터 조건을 갖고 있는 오브젝트
 *
 * @remarks
 * {@link DataFilters} 의 하위 타입으로 이 모델의 배열이 포함된다.
 *
 * {@link LocalDataProvider.setFilters} 에서 실질적으로 사용된다.
 *
 * @example
 * ```js
 * dataProvider.setFilters({criteria: "value['field1']='가수'"});
 * ```
 */
interface DataFilter {
    /**
     * 필터 조건식
     */
    criteria: string;
}
/**
 * 필터 조건의 배열 및 컬렉션 오브젝트
 *
 * @remarks
 * {@link LocalDataProvider.setFilters} 에서 사용한다.
 *
 * @example
 * ```js
 * // string
 * dataProvider.setFilters([
 *   "value['field1']='가수'",
 *   "value['field2']='여자'"
 * ], "and");
 *
 * // object
 * dataProvider.setFilters([
 *   {criteria: "value['field1']='가수'"},
 *   {criteria: "value['field2']='여자'"}
 * ], "and");
 * ```
 */
declare type DataFilters = DataFilter | DataFilter[] | string | string[];
/**
 * 행 상태의 따른 행들의 목록
 *
 * @remarks
 * {@link DataProviderBase.getAllStateRows} 로 해당 모델을 반환할 수 있다.
 */
interface RowStateList {
    /**
     * 생성된 행의 index 들
     */
    c?: number[];
    /**
     * 생성되었다 삭제된 행의 index 들
     */
    x?: number[];
    /**
     * 삭제된 행의 index 들
     */
    d?: number[];
    /**
     * 갱신 된 행의 index 들
     */
    u?: number[];
}

/**
 * calculated 필드일 경우 수식을 지정하여 계산 될 콜백의 형식
 *
 * @remarks
 * {@link DataField.valueCallback} 또는 {@link DataFieldObject.valueCallback} 에서 사용된다.
 *
 * 최종적으로 출력하고자 하는 값을 반환하면 된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `rowId` - 행 고유번호
 *
 * `fieldName` - 필드명
 *
 * `fields` - 필드명 배열
 *
 * `values` - 값 배열
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * function (ds, rowID, fieldName, fields, values) {
 *     let quantity = values[fields.indexOf("Quantity")];
 *     let unitprice = values[fields.indexOf("UnitPrice")];
 *     if (isNaN(quantity) || isNaN(unitprice))
 *         return undefined;
 *     else
 *         return quantity >= 1000 ? Math.round(quantity * unitprice * 0.95) : quantity * unitprice;
 * }
 * ```
 */
declare type FieldValueCallback = (ds: DataSource, rowId: number, fieldName: string, fields: string[], values: any[]) => any;
/**
 * 데이터 필드 모델
 * @internal
 */
declare class DataField extends Base implements DataField$1 {
    private _owner;
    private _index;
    private _dataType;
    private _subType;
    private _runType;
    private _orgFieldName;
    private _orgAttrName;
    private _fieldName;
    private _orgBaseField;
    private _baseField;
    private _length;
    private _subTypeEnabled;
    private _set;
    private _minimum;
    private _maximum;
    private _required;
    private _header;
    private _defaultValue;
    private _booleanFormat;
    private _datetimeFormat;
    private _amText;
    private _pmText;
    private _baseYear;
    private _valueExpression;
    private _valueCallback;
    private _tag;
    private _boolParser;
    private _dateParser;
    private _ownerBoolParser;
    private _ownerDateParser;
    private _updatable;
    private _ranged;
    private _runSet;
    private _runMax;
    private _runMin;
    private _typeLock;
    private _equalValues;
    private _sameValues;
    private _readValue;
    private _nullValue;
    private _objectKey;
    private _objectCallback;
    private _exprNode;
    constructor(fieldName: string, dataType?: ValueType, length?: number);
    /**
     * 필드의 해쉬
     *
     * @alpha
     */
    get hash(): string;
    /**
     * 필드 인덱스
     * @defaultValue `-1`
     */
    get index(): number;
    /**
     * 필드명
     */
    get fieldName(): string;
    set fieldName(value: string);
    /**
     * 지정 당시의 필드명
     */
    get orgFieldName(): string;
    /** @internal */
    get orgAttrName(): string;
    /**
     * 자료형
     *
     * @defaultValue {@link  ValueType.TEXT}
     */
    get dataType(): ValueType;
    set dataType(value: ValueType);
    /**
     * @alpha
     *
     * @defaultValue {@link ValueType.TEXT}
     */
    get runType(): ValueType;
    /**
     * 기본 자료형을 제한된 범위로 사용하기 위한 지시자
     *
     * @defaultValue `null`
     */
    get subType(): ValueType;
    set subType(value: ValueType);
    /** subType 가능 여부 */
    get subTypeEnabled(): boolean;
    set subTypeEnabled(value: boolean);
    /**
     * 기준 필드
     */
    get baseField(): string;
    set baseField(value: string);
    /**
     * 데이터 길이
     */
    get length(): number;
    set length(value: number);
    /**
     * 필드셋
     *
     * @remarks
     * 배열에 포함된 값이 아니면 `undefined`로 저장되게 한다.
     * Boolean 자료형을 제외한 나머지 자료형에서 사용가능하다.
     */
    get set(): any[];
    set set(value: any[]);
    /**
     * 최소 범위의 한계값
     */
    get minimum(): number;
    set minimum(value: number);
    /**
     * 최대 범위의 한계값
     */
    get maximum(): number;
    set maximum(value: number);
    /**
     * 데이터 필수 여부
     */
    get required(): boolean;
    set required(value: boolean);
    /**
     * 그룹 헤더 타이틀
     *
     * Row Grouping 시 그룹 헤더의 타이틀에 기준필드의 헤더 값을 표시할 수 있다.
     */
    get header(): string;
    set header(value: string);
    /**
     * 필드의 기본 데이터 값
     * @remarks
     * 기본값을 지정하면 {@link GridView.beginInsertRow}, {@link GridView.beginAppendRow} 함수 호출시 지정된 기본값이 입력된 상태로 새로운 행이 추가된다.
     */
    get defaultValue(): any;
    set defaultValue(value: any);
    /**
     * 데이터가 `null` 일 때 대체될 데이터
     */
    get nullValue(): any;
    /**
     * Boolean 데이터의 입력 방식
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * 날짜형 데이터의 입력 방식
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * 오전 표시
     */
    get amText(): string;
    set amText(value: string);
    /**
     * 오후 표시
     */
    get pmText(): string;
    set pmText(value: string);
    /** 기준 연도 */
    get baseYear(): number;
    set baseYear(value: number);
    /**
     * calculated 필드일 경우 사용될 수식
     *
     * @remarks
     * values['필드명'], values[필드인덱스]로 참조한다.
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     */
    get valueExpression(): string;
    set valueExpression(value: string);
    /**
     * calculated 필드일 경우 수식을 지정하여 계산 될 콜백
     *
     * @remarks
     * 수식에서 다른 calculated 필드의 참조는 허용하지 않는다.
     */
    get valueCallback(): FieldValueCallback;
    set valueCallback(value: FieldValueCallback);
    /**
     * 사용자정의 속성.
     *
     * @remarks
     * 사용자가 필요한 Data를 입력한다.
     */
    get tag(): any;
    set tag(value: any);
    /**
     * dataType이 object인경우 정렬의 기준이 되는 name을 지정.
     *
     * @remarks
     * 참조하는 column에 objectKey가 지정되지 않으면 field의 objectKey가 적용된다.
     */
    get objectKey(): string;
    set objectKey(value: string);
    /**
     * dataType이 object인 경우 사용되는 사용자 정의 정렬 함수
     *
     * @remarks
     * 참조하는 column에 objectCallback이 지정되지 않으면 field의 objectCallback이 적용된다.
     *
     */
    get objectCallback(): Function;
    set objectCallback(value: Function);
    /**
     * calculated 필드인지 여부
     *
     * @remarks
     * {@link DataField.valueExpression | valueExpression} 이나 {@link DataField.valueCallback | valueCallback} 이 설정되어 있으면 calculated 이다.
     */
    get calculated(): boolean;
    /**
     * 수정 가능 여부
     */
    get updatable(): boolean;
    set updatable(value: boolean);
    /**
     * @internal
     */
    isEmpty(value: any): boolean;
    /**
     * @internal
     */
    isNull(value: any): boolean;
    /**
     * @internal
     */
    equalValues(v1: any, v2: any): boolean;
    /**
     * @internal
     */
    sameValues(v1: any, v2: any): boolean;
    /**
     * @internal
     */
    readValue(source: any): any;
    /**
     * @internal
     */
    getBool(parser: BooleanConverter, value: boolean | string): boolean;
    /**
     * @internal
     */
    getDate(parser: DateTimeReader, value: Date | number | string): Date;
    /**
     * @internal
     */
    clone(): DataField;
    /**
     * @internal
     */
    $_resetTypes(provider?: DataSource): void;
    /**
     * @internal
     */
    assignFrom(fld: ConfigObject): void;
    /**
     * @internal
     */
    $_setIndex(value: number): void;
    /**
     * @internal
     */
    $_prepare(owner: DataSource): void;
    /**
     * @internal
     */
    protected changed(): void;
    private resetTypes;
    /**
     * @internal
     */
    $_refreshFormats(owner: DataSource): void;
    private equalDummyValues;
    private sameDummyValues;
    private equalTextValues;
    private sameTextValues;
    private equalNumberValues;
    private sameNumberValues;
    private equalDateValues;
    private sameDateValues;
    private equalBoolValues;
    private sameBoolValues;
    private equalObjectValues;
    private sameObjectValues;
    private readDummyValue;
    private readTextValue;
    private readCharValue;
    private readNumberValue;
    private readUnumValue;
    private readIntValue;
    private readUintValue;
    private readDatetimeValue;
    private readDateValue;
    private readBooleanValue;
    private readObjectValues;
    private $_compareObject;
    /**
     * @internal
     */
    $_calculateValue(ds: DataSource, runtime: any, rowId: number, fieldName: string, fields: any, orgFields: any, values: any): any;
}

/**
 * 행의 상태
 */
declare enum RowState {
    /**
     * 아무것도 아님
     */
    NONE = "none",
    /**
     * 생성됨
     */
    CREATED = "created",
    /**
     * 업데이트됨
     */
    UPDATED = "updated",
    /**
     * 삭제됨
     */
    DELETED = "deleted",
    /**
     * 생성 후 삭제됨
     */
    CREATE_AND_DELETED = "createAndDeleted"
}

/**
 * 복원 모드 종류
 */
declare enum RestoreMode {
    /**
     * 복원 모드를 설정하지 않는다.
     */
    NONE = "none",
    /**
     * 명시적으로 {@link DataProviderBase.restoreUpdatedRows | restoreUpdatedRows()}를 사용했을 경우에만 RowState 와 값이 변경된다.
     */
    EXPLICIT = "explicit",
    /**
     * 원래 값으로 다시 수정만 하면 RowState 도 다시 원상태로 돌아온다.
     */
    AUTO = "auto"
}

/**@internal */
declare abstract class ExpressionRuntime extends Base {
    constructor();
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): void;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capital: boolean): any;
}
/**@internal */
declare abstract class ExpressionNode {
    constructor();
    get value(): any;
    get asLiteral(): any;
    prepareValue(): void;
    getLiteral(): ExpressionNode;
    isIdentifier(value: any): boolean;
    abstract evaluate(runtime: ExpressionRuntime): any;
    toString(): string;
}

/**
 * @internal
 */
declare class CalculateExpressionRuntime extends ExpressionRuntime {
    private static readonly ID_VALUE;
    private static readonly ID_VALUES;
    private static readonly IDENTS;
    private _values;
    private _fields;
    private _fieldCount;
    constructor();
    setValues(values: any[], fields: string[]): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): void;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capital: boolean): any;
}

/** @internal */
declare class DateTimeWriter {
    static readonly DEFAULT_FORMAT = "yyyy/MM/dd";
    private static readonly Formatters;
    static getFormatter(format: string): DateTimeWriter;
    static get Default(): DateTimeWriter;
    private _format;
    private _amText;
    private _pmText;
    private _tokens;
    private _hasAmPm;
    constructor(format: string);
    /** format */
    get format(): string;
    set format(value: string);
    getText(d: Date | number): string;
    private parseDateFormatTokens;
    private parse;
}

/**
 * @internal
 */
declare class BooleanFormatter {
    private static readonly Formatters;
    static getFormatter(format: string): BooleanFormatter;
    private _format;
    private _nullText;
    private _trueText;
    private _falseText;
    constructor(format: string);
    /** format */
    get format(): string;
    formatValue(v: any): string;
    private $_parse;
}

/** @internal */
declare class DecimalFormatter {
    static readonly DEFAULT_FORMAT = "#,##0.0";
    private static readonly Formatters;
    static getFormatter(format: string): DecimalFormatter;
    static get Default(): DecimalFormatter;
    private _format;
    private _optDecimal;
    private _groupPos;
    private _seperator;
    private _groupSep;
    private _reg;
    private _regDecimal;
    private _replacement;
    private _round;
    private _minDigits;
    private _maxDigits;
    constructor(format: string);
    /** format */
    get format(): string;
    /** separator */
    get separator(): string;
    /** groupSep */
    get groupSep(): string;
    /** minDigits */
    get minDigits(): number;
    /** maxDigits */
    get maxDigits(): number;
    parse(format: string): void;
    getText(value: any, minusZero?: boolean): string;
    private _parse;
}

/**
 * datetime 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.datetimeCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      if (value === 'today) {
 *          return new Date();
 *      }
 *      return new Date(value);
 * }
 * ```
 */
declare type DatetimeOutputCallback = (ds: DataSource, row: number, field: string, value: any) => Date;
/**
 * boolean 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.booleanCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      return !!value;
 * }
 * ```
 */
declare type BooleanOutputCallback = (ds: DataSource, row: number, field: string, value: any) => boolean;
/**
 * number 필드 변환시 수행 될 콜백함수 형식
 *
 * @remarks
 * {@link DataOutputOptions.numberCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - DataProvider 컨트롤
 *
 * `row` - 아이템의 인덱스
 *
 * `field` - 필드명
 *
 * `value` - 값
 *
 * [반환값] - 출력할 값
 *
 * @example
 * ```js
 * const f = function(ds, row, field, value) {
 *      let v = Number(value);
 *      return v === NaN ? 42: v;
 * }
 * ```
 */
declare type NumberOutputCallback = (ds: DataSource, row: number, field: string, value: any) => number;
/**
 * @internal
 * 출력할 때 데이터를 반환하는 방식에 대한 설정 모델
 */
declare class DataOutputOptions$1 extends Base {
    private _datetimeFormat;
    private _booleanFormat;
    private _numberFormat;
    private _datetimeCallback;
    private _booleanCallback;
    private _numberCallback;
    private _nullDateText;
    private _nullText;
    private _nanText;
    private _rowState;
    private _datetimeWriter;
    private _booleanFormatter;
    private _numberFormatter;
    constructor(config: ConfigObject);
    /**
     * 날짜 포맷
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * Boolean 포맷
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 {@link DataField | DataField}에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    get numberFormat(): string;
    set numberFormat(value: string);
    get datetimeCallback(): DatetimeOutputCallback;
    set datetimeCallback(value: DatetimeOutputCallback);
    get booleanCallback(): BooleanOutputCallback;
    set booleanCallback(value: BooleanOutputCallback);
    get numberCallback(): NumberOutputCallback;
    set numberCallback(value: NumberOutputCallback);
    get nullDateText(): string;
    set nullDateText(value: string);
    get nullText(): string;
    set nullText(value: string);
    get nanText(): string;
    set nanText(value: string);
    get rowState(): boolean;
    set rowState(value: boolean);
    get datetimeWriter(): DateTimeWriter;
    get booleanFormatter(): BooleanFormatter;
    get numberFormatter(): DecimalFormatter;
}

/**
 * 행 데이터
 *
 * @remarks
 * {@link DataValues} 의 형식 중 하나
 */
declare type RowValues = any[];
/**
 * 행 오브젝트
 *
 * @remarks
 * {@link DataValues} 의 형식 중 하나
 */
declare type RowObject = {
    [key: string]: any;
};
/**
 * 행 오브젝트 및 행 배열
 *
 * @remarks
 * {@link LocalDataProvider}, {@link LocalTreeDataProvider} 의 method 에서 다양하게 쓰인다.
 *
 * {@link RowObject} 또는 {@link RowValues} 이다.
 *
 * @example
 * ```js
 * // array
 * let row = ['value1', 'value2', 'value3']
 *
 * // object
 * let row = {field1: 'value1', field2: 'value2', field3: 'value3'}
 * ```
 */
declare type DataValues = RowObject | RowValues;
/**
 * @public
 * json형태의 data를 dataProvider에 입력할때 각 행별로 호출되는 콜백
 *
 * @remarks
 * 서버에서 전달된 data의 형태가 fields로 설정한 fieldName과 다르거나 value값을 임의로 변경할때 사용한다.
 *
 * @example
 * ```js
 * dataProvider.valuesCallback = function (ds, obj) {
 *     let row = [];
 *     if (obj) {
 *         for (let i = 0, cnt = this.fieldCount; i < cnt; i++) {
 *             let fld = this.getOrgFieldName(i);
 *             let fName = Object.keys(obj).find(function(key) {return key.toLowerCase() === fld.toLowerCase()})
 *             if (obj.hasOwnProperty(fName)) {
 *                 row[i] = obj[fName];
 *             }
 *         }
 *     }
 *     return row;
 * }
 * ```
 *
 */
declare type ObjectToValuesCallback = (ds: DataSource, obj: ConfigObject) => RowValues;
/** @internal */
interface DataSourceClient {
    isDataEditing(): boolean;
    cancelDataEditing(): void;
    commitDataEditing(): void;
}
/**
 * @internal
 */
declare abstract class DataSource extends EventAware {
    private static readonly COMMAND_STACK_CHANGED;
    private _subTypeEnabled;
    protected _undoable: boolean;
    private _insertable;
    private _updatable;
    private _deletable;
    private _softDeleting;
    private _deleteCreated;
    private _checkStates;
    private _restoreMode;
    private _strictRestore;
    private _booleanFormat;
    private _datetimeFormat;
    private _baseYear;
    private _amText;
    private _pmText;
    private _alertClientError;
    private _throwClientError;
    private _commitBeforeDataEdit;
    private _calculateRuntime;
    private _valuesCallback;
    private _fields;
    private _calcFields;
    private _fieldNames;
    private _fieldMap;
    private _defComparer;
    private _comparers;
    private _boolParser;
    private _dateParser;
    protected _eventLock: number;
    protected _resetLock: number;
    protected _countLock: number;
    private _clients;
    protected $_handler: any;
    constructor();
    protected _doDispose(): void;
    /** handler */
    abstract get handler(): any;
    /** subTypeEnabled */
    get subTypeEnabled(): boolean;
    set subTypeEnabled(value: boolean);
    /** undoable */
    get undoable(): boolean;
    set undoable(value: boolean);
    /** insertable */
    get insertable(): boolean;
    set insertable(value: boolean);
    /** updatable */
    get updatable(): boolean;
    set updatable(value: boolean);
    /** deletable */
    get deletable(): boolean;
    set deletable(value: boolean);
    /** softDeleting */
    get softDeleting(): boolean;
    set softDeleting(value: boolean);
    /** deleteCreated */
    get deleteCreated(): boolean;
    set deleteCreated(value: boolean);
    /** checkStates */
    get checkStates(): boolean;
    set checkStates(value: boolean);
    /** restoreMode */
    get restoreMode(): RestoreMode;
    set restoreMode(value: RestoreMode);
    /** strictRestore */
    get strictRestore(): boolean;
    set strictRestore(value: boolean);
    /** booleanFormat */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /** datetimeFormat */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /** baseYear */
    get baseYear(): number;
    set baseYear(value: number);
    /** amText */
    get amText(): string;
    set amText(value: string);
    /** pmText */
    get pmText(): string;
    set pmText(value: string);
    /** alertClientError */
    get alertClientError(): boolean;
    set alertClientError(value: boolean);
    /** throwClientError */
    get throwClientError(): boolean;
    set throwClientError(value: boolean);
    /** commitBeforeDataEdit */
    get commitBeforeDataEdit(): boolean;
    set commitBeforeDataEdit(value: boolean);
    /** calculateRuntime */
    get calculateRuntime(): CalculateExpressionRuntime;
    /** local */
    get local(): boolean;
    /** immediateUpdate */
    get immediateUpdate(): boolean;
    /** summarized */
    get summarized(): boolean;
    /** fieldCount */
    get fieldCount(): number;
    /** rowCount */
    abstract get rowCount(): number;
    /** boolParser */
    get boolParser(): BooleanConverter;
    /** dateParser */
    get dateParser(): DateTimeReader;
    /** eventLocked */
    get eventLocked(): boolean;
    /** canUndo */
    get canUndo(): boolean;
    /** canRedo */
    get canRedo(): boolean;
    /** undoing */
    get undoing(): boolean;
    /** redoing */
    get redoing(): boolean;
    get valuesCallback(): ObjectToValuesCallback;
    set valuesCallback(value: ObjectToValuesCallback);
    registerClient(client: DataSourceClient): void;
    unregisterClient(client: DataSourceClient): void;
    cancelClients(): void;
    commitClients(): void;
    beginUpdate(): void;
    endUpdate(refresh?: boolean): void;
    addField(source: any, resetFields: boolean, calculateData?: boolean): DataField;
    clearFields(): void;
    setFields(fields: any[]): void;
    getField(index: number): DataField;
    getFields(): DataField[];
    fieldByName(name: string): DataField;
    getFieldNames(): string[];
    getOrgFieldNames(): string[];
    getFieldName(field: number): string;
    getOrgFieldName(field: number): string;
    getFieldIndex(fieldName: string | number): number;
    getFieldIndexC(fieldName: string): number;
    getBaseField(field: number): number;
    getValueType(field: number): ValueType;
    getDefaultValue(field: number): any;
    hasData(row: number): boolean;
    objectToRow(values: RowObject): any[];
    abstract getRowId(row: number): number;
    abstract getValue(row: number, fieldIndex: number): any;
    abstract setValue(row: number, fieldIndex: number, value: any): boolean;
    abstract getRow(row: number): RowValues;
    abstract getRowObject(row: number): RowObject;
    abstract getDataRow(rowId: number): number;
    canUpdateField(row: number, field: number): boolean;
    getDataComparer(field: number): any;
    setDataComparer(field: number, comparer: any): void;
    canSummarize(field: number): boolean;
    getDistinctValues(field: number, maxCount?: number, sortDir?: SortDirection): any[];
    exportToJson(): void;
    exportToXml(): void;
    abstract getRowState(row: number): RowState;
    abstract setRowState(row: number, state: RowState, force: boolean): void;
    abstract clearRowStates(deleteRows: boolean, rowEvents: boolean): void;
    abstract getStateRows(state: RowState): number[];
    abstract getAllStateRows(): {
        [key: string]: number[];
    };
    abstract setRowStates(rows: number[], state: RowState, force: boolean, rowEvents: boolean): void;
    abstract getRowStateCount(states: RowState[]): number;
    abstract restoreUpdatedStates(rows: number[]): void;
    abstract restoreUpdatedRows(rows: number[]): void;
    abstract getUpdatedCells(rows: number[]): any;
    abstract isDataChanged(row: number, fieldIndex: number): boolean;
    canUpdateRow(row: number): boolean;
    canAppendRow(): boolean;
    canInsertRow(row: number): boolean;
    canDeleteRow(row: number): boolean;
    undo(): void;
    redo(): void;
    clearCommandStack(): void;
    protected _convertValues(obj: {}, fieldMap: {}): {};
    abstract insertRowsFrom(ds: DataSource, fieldMap: {}, rows: number[], row: number): void;
    abstract appendRowsFrom(ds: DataSource, fieldMap: {}, rows: number[]): void;
    abstract fillValue(rows: number[], fields: number[], value: any): void;
    private getClientsBusy;
    protected _checkClientState(): boolean;
    protected _checkFieldIndex(field: number): void;
    protected $_internalClearFields(): void;
    protected $_internalInsertField(index: number, field: DataField): number;
    private $_addField;
    private $_internalAddField;
    protected _internalCalculateValues(values: RowValues, row: number): void;
    refreshFieldFormats(): void;
    refreshFieldFormat(field: DataField): void;
    protected _getRowValues(): RowValues;
    protected $_createOutputRows(rows: RowObject[], options: DataOutputOptions$1 | ConfigObject, startIdx?: number): void;
    protected $_sortRows(rows: any[], field: number, compFunc: any, left: number, right: number): void;
    private $_createDateReader;
    protected _doCheckStatesChanged(): void;
    protected _doRestoreModeChanged(oldMode: RestoreMode, newMode: RestoreMode): void;
    protected _doFieldsReset(): void;
    protected _refreshClients(): void;
    protected _fireReset(): void;
    protected _fireRowCountChanged(): void;
    protected _fireRefresh(): void;
    protected _fireCommandStackChanged(undoable: boolean, redoable: boolean): void;
}

/**
 * @internal
 */
declare class ExpressionStatement {
    private _source;
    private _silentError;
    private _tokens;
    constructor(source?: string, silentError?: boolean);
    /** source */
    get source(): string;
    set source(value: string);
    evaluate(runtime: ExpressionRuntime): any;
    private _parse;
}

/**
 * 검색할 때 사용자 임의로 조건을 지정하기 위한 값 비교 콜백 형식
 *
 * @remarks
 *
 * [매개변수 목록]
 *
 * `v1` - 검색되어지는 값
 *
 * `v2` - 검색한 값
 *
 * `sensitive` - 대소문자 구분 여부
 *
 * `partialMatch` - 포함되는 글자도 검색하는지 여부
 *
 * [반환값] - 해당 값 매칭 여부
 *
 * @example
 * ```js
 * const f = function(v1, v2, sensitive, partialMatch) {
 *      if (v1 === v2) {
 *           return true;
 *      }
 *      let s1 = String(v1);
 *      let s2 = v2 == null ? undefined : String(v2);
 *      if (!s1 && !s2) {
 *           return true;
 *      }
 *      if (!s1 || !s2) {
 *           return false;
 *      }
 *      if (!caseSensitive) {
 *           s1 = s1.toLowerCase();
 *           s2 = s2.toLowerCase();
 *      }
 *      if (partialMatch) {
 *      	    return s2.indexOf(s1) >= 0;
 *      } else {
 *      	    return s1 == s2;
 *      }
 * }
 * ```
 *
 */
declare type CompareCallback = (v1: string, v2: string, sensitive: boolean, partialMatch: boolean) => boolean;
/**
 * 검색관련 설정 정보 모델
 *
 * @internal
 */
declare class SearchOptions$1 extends Base implements SearchOptions$1 {
    constructor(config: ConfigObject);
    /**
     * 검색할 필드 목록
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능
     */
    fields: any[];
    /**
     * fields 에 지정한 각 필드에 해당하는 순서에 맞게 배열된 검색 조건값
     */
    values: any[];
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     */
    wrap: boolean;
    /**
     * 검색된 행 focus 여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * @defaultValue `true`
     */
    select: boolean;
    /**
     * 해당 조건에 맞는 필드들을 전부 검색할 건지의 여부
     *
     * @remarks
     * `false`면 지정된 fields중 일치하는 필드가 있으면 검색으로 종료한다.
     *
     * @defaultValue `true`
     */
    allFields: boolean;
    /**
     * 대소문자 구분
     *
     * @defaultValue `false`
     */
    caseSensitive: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch: boolean;
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     * @example
     * ```js
     * const f = function(v1, v2, sensitive, partialMatch) {
     *      if (v1 === v2) {
     *           return true;
     *      }
     *      let s1 = String(v1);
     *      let s2 = v2 == null ? undefined : String(v2);
     *      if (!s1 && !s2) {
     *           return true;
     *      }
     *      if (!s1 || !s2) {
     *           return false;
     *      }
     *      if (!caseSensitive) {
     *           s1 = s1.toLowerCase();
     *           s2 = s2.toLowerCase();
     *      }
     *      if (partialMatch) {
     *      	    return s2.indexOf(s1) >= 0;
     *      } else {
     *      	    return s1 == s2;
     *      }
     * }
     * ```
     */
    compareCallback: CompareCallback;
}
/**
 * {@link GridBase.searchCell} 에서 사용되는 검색관련 설정 모델
 *
 * @internal
 */
declare class SearchCellOptions$1 extends Base implements SearchCellOptions$1 {
    constructor(config: ConfigObject);
    /**
     * 검색할 필드 목록 (list 형태)
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능
     */
    fields: any;
    /**
     * 지정한 검색 조건값
     */
    value: any;
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex: number;
    /**
     * fields 배열에서 검색을 시작할 필드의 인덱스
     *
     * @remarks
     * let fields = ["a", "b", "c", "d"]; const startFieldIndex = 2 인 경우 "c" 필드부터 검색을 시작한다.
     *
     * @defaultValue `0`
     */
    startFieldIndex: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     */
    wrap: boolean;
    /**
     * 검색된 행 선택여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * @defaultValue `true`
     */
    select: boolean;
    /**
     * 대소문자 구분
     *
     * @defaultValue `false`
     */
    caseSensitive: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch: boolean;
    /**
     * 필드와 컬럼들 순서가 다를 때 지정하는 컬럼들의 배열
     *
     * @remarks
     * 이곳에 지정한 순서대로 검색이 수행된다.
     */
    columns: any;
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     */
    compareCallback: any;
}

/** @internal */
declare abstract class ItemProvider extends EventAware {
    private _hideDeleted;
    private readonly _indexing;
    protected readonly _rootItem: GroupItem;
    private _eventLock;
    private _rowHeighted;
    private _explicitHeighted;
    constructor(indexing: boolean);
    protected _doDispose(): any;
    /** hideDeleted */
    get hideDeleted(): boolean;
    set hideDeleted(value: boolean);
    /** dataSource */
    abstract get dataSource(): DataSource;
    abstract set dataSource(value: DataSource);
    /** itemCount */
    abstract get itemCount(): number;
    /** rowCount */
    abstract get rowCount(): number;
    /** summaryMode */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /** sortMode */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    /** fixedCount */
    get fixedCount(): number;
    /** fixedCount */
    get maxItemCount(): number;
    set maxItemCount(value: number);
    /** sourced */
    abstract get sorted(): boolean;
    /** movable */
    get movable(): boolean;
    setFixed(count: number, sorting: boolean, filtering: boolean): void;
    abstract getItem(index: number, dataOnly?: boolean): GridItem;
    abstract getItems(index: number, count: number): GridItem[];
    protected abstract _refreshItems(): void;
    attachItem(item: GridItem): void;
    getItemsByIndices(indices: number[]): GridItem[];
    getIndexOfRow(dataRow: number, force: boolean): number;
    getIndicesOfRows(dataRows: number[], force: boolean): number[];
    abstract getItemOfRow(dataRow: number, force: boolean): GridItem;
    getItemsByRows(dataRows: number[], force?: boolean): GridItem[];
    exchange(index1: number, index2: number): void;
    setCheckable(item: GridItem, value: boolean): void;
    checkItem(item: GridItem, checked: boolean, exclusive: boolean, checkEvent: boolean): void;
    checkItems(items: GridItem[], checked: boolean, checkEvent: boolean): void;
    checkAll(checked: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent: boolean, groupCheckable: boolean): void;
    protected _setCheckItem(item: GridItem, checked: boolean): void;
    _clearDisplayLevels(): void;
    canUpdate(item: GridItem, field: number): boolean;
    canAppend(): boolean;
    canInsert(item: GridItem): boolean;
    canDelete(item: GridItem): boolean;
    abstract getAllItems(): GridItem[];
    appendDummy(): void;
    cancelDummy(): void;
    findItem(fields: number[], values: any[], options: any, startIndex: number, endIndex: number): number;
    findCell(fields: number[], value: any, options: SearchCellOptions$1, startIndex: number, endIndex: number, startFieldIndex: number): number;
    getSum(field: number): number;
    getMax(field: number): number;
    getMin(field: number): number;
    getAvg(field: number): number;
    getVar(field: number): number;
    getVarp(field: number): number;
    getStdev(field: number): number;
    getStdevp(field: number): number;
    getDataCount(field: number): number;
    getDataAvg(field: number): number;
    get isIndexing(): boolean;
    setRowHeight(item: GridItem, value: number, explicit: boolean): void;
    clearRowHeights(all: boolean): boolean;
    isRowHeighted(all?: boolean): boolean;
    setCheckFieldIndex(field: number): void;
    getItemChecked(item: GridItem, checked: boolean): boolean;
    setItemChecked(item: GridItem, value: boolean): boolean;
    protected get rootItem(): GroupItem;
    protected _createRootItem(): GroupItem;
    protected _hideDeletedChanged(): void;
    protected $_canFire(): boolean;
    private _setChecked;
    protected _clearChecked(): void;
    protected _resetItemIndicies(fromIndex: number): void;
    protected _setExpanded(group: GroupItem, value: boolean): void;
    protected _resetItemIndex(index: number): void;
    protected _incDescendents(group: GroupItem, count: number): void;
    protected _copyExtents(source: GridItem, target: GridItem): void;
    protected _fireReset(): void;
    protected _fireRefresh(): void;
    protected _fireRefreshClient(): void;
    protected _fireItemInserted(item: GridItem): void;
    protected _fireItemDeleted(item: GridItem): void;
    protected _fireItemUpdated(item: GridItem): void;
    protected _fireCheckableChanged(item: GridItem): void;
    protected _fireItemChecked(item: GridItem): void;
    protected _fireItemsChecked(items: GridItem[], checked: boolean): void;
    protected _fireItemAllChecked(checked: boolean): void;
    protected _fireItemCheckChanged(items: GridItem[], checked: boolean): void;
    protected _fireRowStateChanged(item: GridItem): void;
    protected _fireRowStatesChanged(items: GridItem[]): void;
    protected _fireRowStatesCleared(): void;
    protected _fireSort(fields: number[], directions: SortDirection[], cases: SortCase[]): void;
    protected _fireSorted(): void;
    protected _fireFilterAdded(field: number, criteria: string): void;
    protected _fireFilterRemoved(field: number, filter: ColumnFilter): void;
    protected _fireFilterCleared(field: number): void;
    protected _fireFilterAllCleared(): void;
    protected _fireFiltered(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    protected _fireCommandStackChanged(undoable: boolean, redoable: boolean): void;
    protected _fireDataLoadComplated(): void;
}
/** @internal */
declare abstract class ProxyItemProvider extends ItemProvider {
    private _source;
    constructor(source: ItemProvider, indexing: boolean);
    protected _doDispose(): void;
    /** source */
    get source(): ItemProvider;
    set source(value: ItemProvider);
    get dataSource(): DataSource;
    set dataSource(value: DataSource);
    get rowCount(): number;
    get fixedCount(): number;
    get maxItemCount(): number;
    set maxItemCount(value: number);
    get sorted(): boolean;
    setFixed(count: number, sorting: boolean, filtering: boolean): void;
    getIndexOfRow(dataRow: number): number;
    getItemOfRow(dataRow: number, force: boolean): GridItem;
    protected _refreshItems(): void;
    _clearDisplayLevels(): void;
    protected _initialize(): void;
    protected _clearItems(): void;
    protected _populateItems(): void;
    onItemProviderReset(rs: ItemProvider): void;
    onItemProviderRefresh(rs: ItemProvider): void;
    onItemProviderRefreshClient(rs: ItemProvider): void;
    onItemProviderItemInserted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemDeleted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemUpdated(rs: ItemProvider, item: GridItem): void;
    onItemProviderCheckableChanged(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemChecked(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemsChecked(rs: ItemProvider, items: GridItem[], checked: boolean): void;
    onItemProviderItemAllChecked(rs: ItemProvider, checked: boolean): void;
    onItemProviderItemCheckChanged(rs: ItemProvider, items: GridItem[], checked: boolean): void;
    onItemProviderRowStateChanged(rs: ItemProvider, item: GridItem): void;
    onItemProviderRowStatesChanged(rs: ItemProvider, items: GridItem[]): void;
    onItemProviderRowStatesCleared(rs: ItemProvider): void;
    onItemProviderFilterAdded(rs: ItemProvider, field: number, criteria: string): void;
    onItemProviderFilterRemoved(rs: ItemProvider, field: number, filter: ColumnFilter): void;
    onItemProviderFilterCleared(rs: ItemProvider, field: number): void;
    onItemProviderFilterAllCleared(rs: ItemProvider): void;
    onItemProviderFiltered(rs: ItemProvider, filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    onItemProviderSort(rs: ItemProvider, fields: number[], directions: SortDirection[]): void;
    onItemProviderSorted(rs: ItemProvider): void;
    onItemProviderCommandStackChanged(rs: ItemProvider, undoable: boolean, redoable: boolean): void;
}

/** @internal */
declare class ColumnCollection extends Base {
    private _owner;
    private _columns;
    private _orgColumns;
    private _nameMap;
    constructor(owner: GridBase$1);
    protected _doDispose(): void;
    /** owner */
    get owner(): GridBase$1;
    /** count */
    get count(): number;
    /** columns */
    get columns(): GridColumn[];
    getColumn(index: number): GridColumn;
    setColumns(columns: (GridColumn | ConfigObject)[]): void;
    add(column: GridColumn | ConfigObject, index?: number): GridColumn;
    remove(column: GridColumn): boolean;
    resetIndices(): void;
    resetSortStates(): void;
    columnByName(name: string): GridColumn;
    columnByField(field: number): DataColumn;
    restoreColumns(): void;
    private _addColumn;
    private _removeColumn;
    private _restoreColumn;
    private _clearColumn;
}

/** @internal */
declare abstract class GridMergeRoom extends Base {
    constructor();
    abstract get scope(): any;
    abstract get group(): GroupItem;
    get head(): number;
    get tail(): number;
    abstract getHead(index: CellIndex): CellIndex;
    abstract getTail(index: CellIndex): CellIndex;
    abstract isHead(index: CellIndex): boolean;
    abstract isTail(index: CellIndex): boolean;
    abstract contains(index: CellIndex): boolean;
}
/** @internal */
declare class ColumnMergeRoom extends GridMergeRoom {
    private static readonly $_rooms;
    private static $_roomCount;
    static borrow(range: CellRange): ColumnMergeRoom;
    static returnTo(room: ColumnMergeRoom): void;
    private _column;
    private _head;
    private _tail;
    private _group;
    constructor(range: CellRange);
    /** column */
    get column(): GridColumn;
    /** head */
    get head(): number;
    /** tail */
    get tail(): number;
    get scope(): any;
    get group(): GroupItem;
    set group(value: GroupItem);
    getHead(index: CellIndex): CellIndex;
    getTail(index: CellIndex): CellIndex;
    isHead(index: CellIndex): boolean;
    isTail(index: CellIndex): boolean;
    contains(index: CellIndex): boolean;
}
/**
 * @internal
 */
declare class ColumnMergeManager extends Base {
    static readonly MERGE_ROOMS = "mergeRooms";
    private _layout;
    private _flags;
    private _fixedRooms;
    private _rooms;
    private _inited;
    private _fixedCells;
    private _cells;
    private _nextId;
    constructor(layout: CellLayoutColumnItem);
    protected _doDispose(): void;
    /** count */
    get count(): number;
    clear(): void;
    initialize(count: number): void;
    refreshRooms(first: number, last: number, bFixed: boolean): void;
    getFixedRooms(): ColumnMergeRoom[];
    getRooms(): ColumnMergeRoom[];
    scroll(delta: number): void;
    getRoom(index: CellIndex): ColumnMergeRoom;
    prepareCells(fixedRows: number, rows: number): void;
    refreshCells(fixed: number, top: number): void;
    addFixedCells(row: number, count: number): number;
    addCells(row: number, count: number): number;
    isMerged(row: number, fixedRows: number): boolean;
    isMergeRoot(row: number, fixedRows: number): boolean;
    isHidden(row: number, fixedRows: number): boolean;
    getMerged(row: number, fixedRows: number): number;
    getMerged2(grid: GridBase$1, itemIndex: number, row: number, span: number): number;
    private $_checkFixedMerge;
    private $_checkMerge;
}

/**
 * @public
 * 레이아웃을 설정하기 위한 기반 모델
 *
 * @remarks
 * 하위 모델을 이용하여 {@link GridBase.setColumnLayout} 으로 설정 시, 특정 속성만 사용 가능하다.
 *
 * [하위 클래스]
 *
 * {@link CellLayoutColumnItem}
 *
 * {@link CellLayoutGroupItem}
 *
 * @warning CellLayoutItem 으로 직접 설정할 수 없다.
 */
interface CellLayoutItem$1 {
    /**
     * 레이아웃 명
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    name?: string;
    /**
     * 표시 여부
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    visible?: boolean;
    /**
     * 너비
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정 할 수 있다.
     */
    width?: number;
    /**
     * 셀 너비
     *
     */
    cellWidth?: number;
    /**
     * {@link GridFitStyle.FILL} 로 설정된 후 사용하는 너비 비율
     */
    fillWidth?: number;
    /**
     * 전체 그룹 혹은 상위 그룹 내에서의 표시 순서
     *
     * @readonly
     */
    vindex?: number;
    /**
     * 상위 레이아웃의 expanded상태에서 따라서 표시하거나 숨긴다.
     *
     * @defaultValue {@link GroupShowMode.ALWAYS | always}
     */
    groupShowMode: GroupShowMode;
}
/**
 * @public
 * 컬럼 레이아웃 정보 모델
 *
 * @remarks
 * {@link GridBase.getLayoutByColumn} 에서 해당 모델을 반환할 수 있다.
 *
 * {@link GridBase.setColumnLayout} 로 설정될 때에는 특정 속성만 사용 가능하다.
 *
 * {@link GridColumn.layout} 의 속성으로 설정 가능하다.
 *
 * {@link CellLayoutItem} 을 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellLayoutItem}
 *
 *
 * @example
 * ```js
 * // 반환값일 경우
 * {
 *      mergeRule: undefined,
 *      breakMergeOnEmpty: false,
 *      equalBlank: undefined,
 *      equalBlankExpression: undefined,
 *      cellSpan: 1,
 *      headerSpan: undefined,
 *      summarySpan: undefined,
 *      footerSpan: undefined,
 *      dataSpan: undefined,
 *      spanCallback: undefined,
 *      visible: true,
 *      vindex: 1,
 *      width: 100,
 *      fillWidth: NaN,
 *      cellWidth: 250
 * }
 *
 * // method 로 설정할 경우
 * {
 *      column: 'Country'
 *      cellSpan: 3,
 *      width: 100,
 * }
 *
 * {
 *      column: 'Country'
 *      headerSpan: 2,
 *      summarySpan: 2,
 *      footerSpan: 2,
 *      dataSpan: 4,
 * }
 *
 * // 컬럼에 설정할 경우
 * column.layout.spanCallback = function (grid, layout, itemIndex) {
 *     var value = grid.getValue(itemIndex, layout.column.name);
 *     if (value) {
 *         return value[0] === "B" ? 2 : value[0] === "F" ? 3 : 1;
 *     }
 * ```
 */
interface CellLayoutColumnItem$1 extends CellLayoutItem$1 {
    /**
     * 컬럼 머지할 때의 규칙
     *
     * @remarks
     * `undefined` 이면(기본값) 컬럼의 mergeRule 로 병합한다.
     * `null` 이면 컬럼의 mergeRule 을 무시한다.
     */
    mergeRule?: string;
    /**
     * 빈 셀일 때 머지 중단 여부
     */
    breakMergeOnEmpty?: boolean;
    /**
     * 같은 컬럼의 이전 행의 셀과 값이 동일할때 셀의 묶음 여부
     *
     * @defaultValue `undefined`
     */
    equalBlank?: boolean;
    /**
     * {@link CellLayoutColumnItem.equalBlank | equalBlank } 가 `true`인 경우 같은 값으로 처리할 수식
     *
     * @defaultValue `undefined`
     */
    equalBlankExpression?: boolean;
    /**
     * 컬럼명
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정될 때만 사용 가능하다.
     *
     * {@link GridBase.getLayoutByColumn}의 반환 형식에도 포함되지 않는다.
     */
    column?: string;
    /**
     * 기본 셀 스팬 개수
     *
     * @remarks
     * 다른 스팬이 지정이 되지 않을 때, 해당 값을 따른다.
     *
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    cellSpan?: number;
    /**
     * 헤더 스팬 개수
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    headerSpan?: number;
    /**
     * summary 스팬 개수
     *
     * @remarks
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    summarySpans?: number[];
    /**
     * 푸터 스팬 개수
     *
     * @remarks
     * summary가 하나인 경우 summarySpan 으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    footerSpans?: number[];
    /**
     * 그룹 푸터 스팬 개수
     *
     * @remarks
     * footer가 하나인 경우 footerSpan으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    groupFooterSpans?: number[];
    /**
     * 셀 스팬 개수
     *
     * @remarks
     * groupFooter가 하나인 경우 groupFooterSpan으로 지정한다.
     * {@link GridBase.setColumnLayout} 로 설정될 때 사용 가능하다.
     */
    dataSpan?: number;
    /**
     * 사용자 지정 스팬을 위한 콜백
     *
     * @eventProperty
     * @example
     * ```js
     * let layout = column.layout
     * layout.spanCallback = function (grid, layout, itemIndex) {
     *     var value = grid.getValue(itemIndex, layout.column.dataIndex);
     *     if (value) {
     *         return value[0] === "B" ? 3 : value[0] === "F" ? 2 : 1;
     *     }
     *     return 1;
     * };
     * ```
     */
    spanCallback?: CellSpanCallback$1;
    /**
     * 사용자 지정 headerSummary 스팬을 위한 콜백
     *
     * @eventProperty
     */
    summarySpanCallback?: SummaryCellSpanCallback$1;
    /**
     * 사용자 지정 footer 스팬을 위한 콜백
     *
     * @eventProperty
     */
    footerSpanCallback?: SummaryCellSpanCallback$1;
    /**
     * 사용자 지정 groupFooter 스팬을 위한 콜백
     *
     * * @eventProperty
     */
    groupFooterSpanCallback?: GroupFooterCellSpanCallback$1;
    /**
     * 사용자 지정 footer span
     */
    footerUserSpans?: UserSpan[];
    /**
     * 사용자 지정 headerSummary span
     */
    summaryUserSpans?: UserSpan[];
    /**
     * 사용자 지정 groupFooter span
     */
    groupFooterUserSpans?: UserSpan[];
}
/**
 * @public
 * 사용자 지정의 cell spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `itemIndex` - 행의 인덱스
 *
 * @example
 * ```js
 * const f = function (grid, layout, itemIndex) {
 *     var value = grid.getValue(itemIndex, layout.column.dataIndex);
 *     if (value) {
 *         return value[0] === "B" ? 3 : value[0] === "F" ? 2 : 1;
 *     }
 *     return 1;
 * };
 * ```
 */
declare type CellSpanCallback$1 = (grid: GridBase$1, layout: CellLayoutColumnItem$1, itemIndex: number) => number;
/**
 * @public
 * 사용자 지정의 headerSummary와 footer spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `footerIndex` - footer의 인덱스
 *
 */
declare type SummaryCellSpanCallback$1 = (grid: GridBase$1, layout: CellLayoutColumnItem$1, summaryIndex: number) => number;
/**
 * @public
 * 사용자 지정의 groupFooter spanning을 설정하기 위한 콜백
 *
 * @remarks
 * {@link CellLayoutColumnItem} 에서 사용된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨트롤
 *
 * `layout` - 레이아웃 아이템
 *
 * `itemIndex` - 행의 인덱스
 *
 * `footerIndex` - groupFooter의 index
 *
 */
declare type GroupFooterCellSpanCallback$1 = (grid: GridBase$1, layout: CellLayoutColumnItem$1, itemIndex: number, footerIndex: number) => number;
/**
 * @public
 * footer의 사용자 지정 span
 *
 * @remarks
 * footer, headerSummary, groupFooter의 셀을 사용자가 span시키기 위한 rowspan, colspan을 지정한다.
 * footerCount가 지정되면 rowspan은 무시된다.
 */
interface UserSpan {
    /**
     * rowspan
     */
    rowspan: number;
    /**
     * colspan
     */
    colspan: number;
    /**
     * footerCount
     */
    footerCount: number;
}
/**
 * @public
 * 그룹 레이아웃 정보 모델
 *
 * @remarks
 * 실제 컬럼이 아닌 화면 상에서 보이는 컬럼 묶음이다.
 *
 * {@link CellLayoutItem} 을 상속한다.
 *
 * [상위 클래스]
 *
 * {@link CellLayoutItem}
 *
 * @example
 * ```js
 * {
 *     name: "companyGroup",
 *     items: [
 *         {
 *             column: "Country",
 *             cellSpan: 3
 *         },
 *         20,20,
 *         {
 *             column: "CompanyName",
 *             cellSpan: 3
 *         },
 *         20,20,
 *     ],
 *     header: true
 * },
 * ```
 */
interface CellLayoutGroupItem$1 extends CellLayoutItem$1 {
    /**
     * 셀 배치 방향
     */
    direction?: ColumnLayoutDirection;
    /**
     * 너비 조정 가능 여부
     */
    resizable?: boolean;
    /**
     * 이동 가능 여부
     */
    movable?: boolean;
    /**
     * 하위 레이아웃의 헤더 숨김 여부
     */
    hideChildHeaders?: boolean;
    /**
     * 하위 레이아웃의 이동여부
     */
    childColumnMovable?: boolean;
    /**
     * 하위 레이아웃 아이템들
     *
     * @remarks
     * 문자열 형태로 입력 시 해당 값을 {@link CellLayoutColumnItem.column | column} 으로 설정한 {@link CellLayoutColumnItem} 을 생성한다.
     *
     * 숫자 형태로 입력시 해당 값을 {@link CellLayoutItem.width | width} 로 설정한 {@link CellLayoutColumnItem} 을 생성한다.
     */
    items?: (LayoutItem | number | string)[];
    /**
     * 헤더의 레이아웃 설정 정보
     *
     * @remarks
     * `string` 또는 `boolean` 으로 {@link CellLayoutHeader.text | text} 또는 {@link CellLayoutHeader.visible | visible} 속성에 부여 가능하다.
     *
     * @example
     *
     * ```js
     *      ...
     *              header: {
     *                  text: 'group1',
     *                  visible: true
     *              },
     *      ...
     *
     *     ...
     *              header: false,
     *      ...
     *
     *     ...
     *              header: 'group3',
     *      ...
     * ```
     */
    header?: CellLayoutHeader$1;
    /**
     * 하위 레이아웃확장 여부
     *
     * @remarks
     *
     * 하위 레이아웃을 접거나 펼쳐서 일부 레이아웃만 보이도록 한다.
     *
     * @defaultValue `false`
     *
     * @example
     *
     * ```js
     * var layout = [ {
     *      name: "group0",
     *      expandable: true,
     *      expanded: true,
     *      header:{text:"2018년도"}
     *      items:[{column: "합계", groupShowMode: "always"},
     *          {column: "1분기", groupShowMode: "expand"},
     *          {column: "2분기", groupShowMode: "expand"},
     *          {column: "3분기", groupShowMode: "expand"},
     *          {column: "4분기", groupShowMode: "expand"}
     *      ]
     * }, { ....
     * }, { ....
     * }]
     * ```
     */
    expandable?: boolean;
    /**
     * 레이아웃 확장 상태
     *
     * @remarks
     * 레이아웃의 확장상태 `true`이면 하위 레이아웃중 {@link CellLayoutItem.groupShowMode}가 `expand`이거나 `always`인 레이아웃만 표시된다.
     * `false`이면 `collapse`이거나 `always`인 레이아웃이 표시된다.
     */
    expanded?: boolean;
}
/**
 * @public
 * 셀 레이아웃 헤더의 설정 정보 모델
 *
 * @remarks
 * `string` 으로 부여시 `text` 에 설정된다.
 *
 * `boolean` 으로 부여시 `visible` 에 설정된다.
 *
 * 따로 `text` 가 설정되지 않은 경우 컬럼 명이 텍스트로 지정된다.
 *
 * @example
 * ```js
 * {
 *      text: 'group1',
 *      visible: true
 * }
 * ```
 */
interface CellLayoutHeader$1 {
    /**
     * 레이아웃 설정 시 보여질 헤더의 텍스트
     */
    text?: string;
    /**
     * 레이아웃 설정 시 적용될 스타일 클래스 명
     */
    styleName?: string;
    /**
     * excel로 export시 적용될 스타일 클래스 명
     */
    exportStyleName?: string;
    /**
     * 표시 여부
     *
     * @remarks
     * 그룹 헤더일 때만 적용 가능
     */
    visible?: boolean;
    /**
     * header 셀의 row count
     *
     * @remarks
     * 여러 level의 그룹이 혼재되어있을때 header의 높이를 일치시키기 위해서 사용한다.
     *
     * 그룹 헤더일 때만 적용 가능
     *
     * @example
     * ```js
     * var layout = [{
     *  name:"group0",
     *  items:[
     *      { name:"group0-1", items:["col1", "col2", "col3"] },
     *      { name:"group0-2", items:["col4", "col5", "col6"] }]
     * }, {
     *  name: "group1",
     *  header: {text:"group1", rows:2},
     *  items: ["col7", "col8"]
     * }]
     * ```
     */
    rows?: number;
    /**
     * 툴팁 표시 여부
     *
     * @remarks
     *
     * @defaultValue `undefined`
     */
    showTooltip?: boolean;
}
/**
 * @public
 * 설정된 레이아웃이 {@link CellLayoutColumnItem} 모델일 경우, {@link GridBase.saveColumnLayout} 에서 반환되는 오브젝트
 *
 * @remarks
 * {@link LayoutInfo} 의 한 종류이다.
 *
 * @example
 * ```js
 * {
 *      column: "OrderID",
 *      visible: true,
 *      width: 80
 * }
 * ```
 */
interface ColumnLayoutInfo {
    /**
     * 컬럼명
     */
    column: string;
    /**
     * 표시여부
     */
    visible: boolean;
    /**
     * 컬럼 너비
     */
    width: number;
}
/**
 * @public
 * 설정된 레이아웃이 {@link CellLayoutGroupItem} 모델일 경우, {@link GridBase.saveColumnLayout} 에서 반환되는 오브젝트
 *
 * @remarks
 * {@link LayoutInfo} 의 한 종류이다.
 *
 * @example
 * ```js
 * {
 *    name: "countryGroup"
 *    items: [
 *        {column: "Country", visible: true, width: 100},
 *        {column: "Phone", visible: true, width: 100}
 *    ]
 *    visible: true,
 *    direction: "horizontal",
 *    width: 250,
 *    header: {visible: true, text: "Country Group"}
 * }
 * ```
 */
interface GroupLayoutInfo {
    /**
     * layout 명
     */
    name: string;
    /**
     * 하위 layout 들
     */
    items: (ColumnLayoutInfo | GroupLayoutInfo)[];
    /**
     * 표시 여부
     */
    visible: boolean;
    /**
     * layout 배치 방향
     */
    direction: ColumnLayoutDirection;
    /**
     * 셀 너비
     */
    width: number;
    /**
     * 헤더 레이아웃 정보
     *
     * @remarks
     * [속성 목록]
     *
     * `visible` - 표시 여부
     *
     * `text` - 헤더 텍스트
     */
    header: {
        visible: boolean;
        text: string;
    };
}
/**
 * @public
 * 원하는 형태의 컬럼을 만들 수 있는 레이아웃 아이템 모델의 타입
 *
 * @remarks
 * {@link GridBase.setColumnLayout} 에서 사용된다.
 *
 * [개념 설명]
 *
 * span 은 {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan | html table의 colspan} 과 비슷한 개념이다.
 *
 * span 개수와 컬럼 개수로 영역을 분할하며, `width`와 뒤의 수들을 더한 만큼 영역을 한다.
 *
 * layout 단위로 span 한다. 즉, 다음 layout이 그룹이면 그 그룹 전체를 span 한다.
 *
 * 그룹을 벗어나서 span 할 수 없다.
 *
 * 그룹은 span할 수 없다.
 *
 * 왼쪽에서 오른쪽으로, 위에서 아래로 진행한다.
 *
 * 상위 layout부터 먼저 span 한다(top-down).
 *
 * 그룹이 다음 layout들을 span 한 경우 새로 추가된 셀들을 하위 layout들에 배분한다.
 *
 * (배분 방식: 하위 layout의 cell 개수 비율에 따라 마지막 layout부터 배분한다.)
 *
 * 행 병합 상태일 경우 span  하려는 다음 layout들과 행 어긋남이 없어야 한다.
 *
 * fixed, rightFixed 경계를 넘어갈 수 없다.
 *
 * @example
 * ```js
 * [
 *        {
 *            name: "companyGroup",
 *            items: [
 *                {
 *                    column: "Country",
 *                    cellSpan: 3
 *                },
 *                20,20,
 *                {
 *                    column: "CompanyName",
 *                    cellSpan: 3
 *                },
 *                20,20,
 *            ],
 *            header: true
 *        },
 *        ...
 *    ];
 * ```
 */
declare type LayoutItem = CellLayoutGroupItem$1 | CellLayoutColumnItem$1;
/**
 * @public
 * {@link GridBase.saveColumnLayout} 에서 반환되는 레이아웃의 정보 모델
 *
 * @remarks
 * ```js
 * // array of LayoutInfo
 * [
 *      {column: "OrderID", visible: true, width: 80},
 *      {column: "CustomerID", visible: true, width: 90},
 *      {
 *          name: "companyGroup"
 *          items: [
 *              {
 *                  name: "countryGroup"
 *                  items: [
 *                      {column: "Country", visible: true, width: 100},
 *                      {column: "Phone", visible: true, width: 100}
 *                  ]
 *                  visible: true,
 *                  direction: "horizontal",
 *                  width: 250,
 *                  header: {visible: true, text: "Country Group"}
 *              },
 *              {column: "CompanyName", visible: true, width: 100}
 *          ]
 *          visible: true,
 *          direction: "vertical",
 *          width: 250,
 *          header: {visible: true, text: "Company Group"}
 *      },
 *      {column: "EmployeeID", visible: true, width: 90}
 * ]
 * ```
 */
declare type LayoutInfo$1 = ColumnLayoutInfo | GroupLayoutInfo;

/**
 * {@link ExportBaseOptions.done | done} 을 설정하기 위한 내보내기를 완료할 때 수행될 콜백의 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `data` - target이 `stream`인 경우 전달된다.
 */
declare type ExportSimpleCallback = (data?: string) => void;
/**
 * {@link ExportBaseOptions | 그리드 내보내기 설정}에서 필드 별로 출력 시 수행될 콜백을 지정하기 위한 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `index` - 인덱스
 *
 * `name` - 필드명
 *
 * `value` - 입력된 값
 *
 * [반환값] - 내보내기 될 값
 */
declare type ExportValueCallback = (index: number, name: string, value: any) => any;
/**
 * {@link ExportBaseOptions | 그리드 내보내기 설정}에서 showProgress가 true일때 수행될 콜백을 지정하기 위한 형식
 *
 * @remarks
 * [매개변수 목록]
 * `grid` - 현재 export를 진행중인 grid, zip파일을 생성중인 경우 null이 전달된다.
 *
 * `work` - Grid가 엑셀을 생성하면서 호출되는 경우 `process`, zip파일을 생성하면서 호출되는 경우 `zip`이 전달된다. jsZIP이 generateAsync지원하는 경우 호출된다.
 *
 * `max` - maxPosition
 *
 * `position` - 현재 진행되고 있는 position
 */
declare type ProgressCallback = (grid: GridBase$1, work: string, max: number, position: number) => any;
/**
 * @public
 * 사용자가 출력 셀을 추가할때 사용되는 콜백 {@link GridExportOptions.userCells}이 있는 경우 수행되지 않는다.
 *
 * @remarks
 * [매개변수 목록]
 * `grid` - 현재 export를 진행중인 grid
 *
 * `rowCount` - sheet의 행수
 *
 * `colCount` - sheet의 컬럼수
 *
 * `name` - sheet의 name
 *
 * [반환값] - {@link UserExportCell}의 배열
 *
 * @example
 * ```js
 * var callback = function(grid, rowCount, colCount, sheetName) {
 *  return [{row:3, col: colCount -3, mergeCol: 3, text:"열의 마지막에 표시", styles:{textAlign:"right"}}]
 * }
 * gridView.exportGrid({"type":"excel", "target":"local", "yOffset":4, userCellsCallback: callback});
 * ```
 */
declare type UserCellsCallback = (grid: GridBase$1, rowCount: number, columnCount: number, sheetName: string) => UserExportCell[];
/**
 * 그리드를 외부 문서로 내보내기 할 때의 종류
 *
 * @remarks
 * {@link ExportBaseOptions."type"} 에서 사용된다.
 */
declare enum ExportType {
    /**
     * 엑셀
     */
    EXCEL = "excel",
    /**
     * CSV
     */
    CSV = "csv"
}
/**
 * 그리드를 외부 문서로 내보내기 할 때의 대상
 */
declare enum ExportTarget {
    /**
     * 로컬에 직접 저장
     */
    LOCAL = "local",
    /**
     * 서버를 경유해서 저장
     */
    REMOTE = "remote",
    /**
     * 콘솔에 내보내기
     */
    STREAM = "stream"
}
/**
 * @internal
 * 그리드와 상관없이 export에 관련된 속성만 남기고 exportOptions으로 이동.
 */
declare class ExportBaseOptions$1 extends Base {
    private _fileName;
    private _type;
    private _target;
    private _datetimeFormat;
    private _numberFormat;
    private _booleanFormat;
    private _booleanFormatter;
    constructor(source: Object);
    datetimeCallback: ExportValueCallback;
    numberCallback: ExportValueCallback;
    booleanCallback: ExportValueCallback;
    objectCallback: ExportValueCallback;
    textCallback: ExportValueCallback;
    start: number;
    count: number;
    replaceCrText: string;
    replaceLfText: string;
    seperator: string;
    get type(): ExportType;
    set type(value: ExportType);
    get target(): ExportTarget;
    set target(value: ExportTarget);
    url: string;
    done: ExportSimpleCallback;
    showProgress: boolean;
    progressMessage: string;
    prepareProgress: number;
    progressCallback: ProgressCallback;
    params: ConfigObject;
    get fileName(): string;
    set fileName(value: string);
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    get booleanFormat(): string;
    set booleanFormat(value: string);
    get numberFormat(): string;
    set numberFormat(value: string);
    get booleanFormatter(): BooleanFormatter;
}

/**
 * @public
 * 그리드 및 데이터 내보내기에 관한 설정들의 기반 모델
 *
 * @remarks
 * {@link GridExportOptions}, {@link DataExportOptions} 가 하위 모델이다.
 *
 * [하위 클래스]
 *
 * {@link GridExportOptions}
 *
 * {@link DataExportOptions}
 */
interface ExportBaseOptions {
    /**
     * 내보내기를 할 타입
     */
    type: ExportType | string;
    /**
     * 내보내기 할 대상 / 경로
     *
     * @defaultValue {@link ExportTarget.LOCAL}
     */
    target?: ExportTarget | string;
    /**
     * 그리드가 내보내는 문서 스트림을 전송 받은 후 다시 사용자 컴퓨터에 내려 주는 서버의 url
     */
    url?: string;
    /**
     * Datetime 필드의 값이 `null` 일 때 표현되는 값
     *
     * @defaultValue `''`
     */
    nullDateText?: string;
    /**
     * 내보내기 시 파일 명
     *
     * @example
     * `'gridExportSample.xlsx'`
     */
    fileName?: string;
    /**
     * @alpha
     *
     * @defaultValue `10`
     */
    prepareProgress?: number;
    /**
     * 내보내기 시 프로그레스 바 표시여부
     *
     * @defaultValue `false`
     */
    showProgress?: boolean;
    /**
     * 프로그레스 바 사용 시 표시될 메시지
     * @remarks
     *
     * @defaultValue `'csv'`: `'Exporting...'`, `'excel'`: `null`
     */
    progressMessage?: string;
    /**
     * 사용자 Progress Bar를 위한 callback
     * @remarks
     * progressCallback이 설정되면 Grid내부의 progressBar는 표시되지 않는다.
     *
     */
    progressCallback?: ProgressCallback;
    /**
     * 내보내기를 완료할 때 수행 될 콜백
     *
     * @remarks
     * {@link ExportBaseOptions.target} 이 {@link ExportTarget.STREAM} 인경우 Base64로 encoding된 Data가 전달된다.
     */
    done?: ExportSimpleCallback;
    /**
     * target이 "remote"일때 서버로 전달될 parameters
     *
     * @remarks
     * target이 remote일때 서버로 전달되어야 할 추가 정보가 있는 경우 사용한다.
     *
     * @example
     * ```js
     * var params = {
     *   userId: "userId",
     *   param1: "param1",
     *   param2: "param2"
     * }
     * gridView.exportGrid({type:"excel", target:"local", params:params})
     * ```

     */
    params?: ConfigObject;
}
/**
 * @public
 * 그리드 및 데이터 내보내기에 관한 설정들의 공통 모델
 *
 * @remarks
 * {@link ExportBaseOptions} 를 상속한다.
 * {@link GridExportOptions}, {@link DataExportOptions} 가 하위 모델이다.
 *
 * [상위 클래스]
 *
 * {@link ExportBaseOptions}
 *
 * [하위 클래스]
 *
 * {@link GridExportOptions}
 *
 * {@link DataExportOptions}
 */
interface ExportOptions extends ExportBaseOptions {
    /**
     * Boolean 형식일 때의 서식
     */
    booleanFormat?: string;
    /**
     * datetime 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    datetimeCallback?: ExportValueCallback;
    /**
     * number 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    numberCallback?: ExportValueCallback;
    /**
     * boolean 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    booleanCallback?: ExportValueCallback;
    /**
     * object 필드 출력 시 수행될 콜백
     *
     * @eventProperty
     */
    objectCallback?: ExportValueCallback;
    /**
     * text 필드 출력 시 수행될 콜백
     *
     * @remarks
     * text 타입으로 된 시간값을 내보내기 하였을 때, 엑셀에서 연산을 가능할 수 있게 하기위해 만들어졌다.
     *
     * @eventProperty
     */
    textCallback?: ExportValueCallback;
    /**
     * 내보내기를 시작할 행
     *
     * @defaultValue `0`
     */
    start?: number;
    /**
     * 내보내기 할 행 수
     *
     * @remarks
     * `-1` 로 지정하면 전체 행이 내보내기 된다.
     * @defaultValue `-1`
     */
    count?: number;
    /**
     * 구분자
     *
     * @remarks
     * csv로 export시 구분자
     */
    seperator?: string;
    /**
     * cr(Carriage Return)가 있는 경우 치환할 문자열
     *
     * @defaultValue `null`
     */
    replaceCrText?: string;
    /**
     * lf(Line Feed)가 있는 경우 치환할 문자열
     *
     * @defaultValue `null`
     */
    replaceLfText?: string;
}
/**
 * 그리드 내보내기에 관한 설정 모델
 *
 * @remarks
 * {@link ExportOptions} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link ExportOptions}
 */
interface GridExportOptions extends ExportOptions {
    /**
     * 내보내기 시 엑셀 문서의 제목
     */
    documentTitle?: DocumentTitle;
    /**
     * 내보내기 시 엑셀 문서의 부제목
     */
    documentSubtitle?: DocumentTitle;
    /**
     * 내보내기 시 엑셀 문서의 꼬릿말
     */
    documentTail?: DocumentTitle;
    /**
     * 컬럼 그룹을 해제하고 엑셀로 내보내기 할 것인지의 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    linear?: boolean;
    /**
     * 숨겨진 컬럼들도 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    allColumns?: boolean;
    /**
     * 숨겨진 행들도 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     *
     * @defaultValue `true`
     */
    allItems?: boolean;
    /**
     * 체크한 행들만 엑셀로 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @remarks
     * 그룹핑 된 행이나 {@link TreeView} 에서는 지원하지 않는다.
     *
     * @defaultValue `false`
     */
    onlyCheckedItems?: boolean;
    /**
     * 엑셀로 내보내기 시 페이징되어 보이지 않는 데이터를 포함한 모든 데이터를 내보내기 할 것인지의 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    pagingAllItems?: boolean;
    /**
     * 그리드 인디케이터 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    indicator?: string;
    /**
     * 그리드 체크바 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    checkBar?: string;
    /**
     * 그리드 헤더 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    header?: string;
    /**
     * 그리드 푸터 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     *
     */
    footer?: string;
    /**
     * 그리드 Header Summary 영역을 포함시킬 것인지의 여부
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라 포함, `'hidden'` 이면 포함 안함, `'visible'` 이면 포함한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     */
    headerSummary?: string;
    /**
     * 그리드 인디케이터 영역을 내보내기 했을 때, 해당 영역의 값의 표시 방법
     *
     * @remarks
     * `'default'` 일 때는 현재 그리드에 표시된 상태에 따라, `'row'` 이면 행의 고유번호로, `'item'` 이면 1부터 시작하여 표시한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'default'`
     */
    indicatorValue?: string;
    /**
     * 그리드 체크바 영역을 내보내기 했을 때, 체크 마크 값의 표시 방법
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `'v'`
     */
    checkMark?: string;
    /**
     * 행 그룹핑 및 트리 그리드 자료를 내보내기 시 들여쓰기 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    indenting?: boolean;
    /**
     * 엑셀 내보내기 시 병합 해제 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    separateRows?: boolean;
    /**
     * 컬럼의 lookupDisplay 값을 표시된 값으로의 내보내기 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;
    /**
     * 행 그룹핑 된 자료를 내보내기 시 엑셀 왼쪽에 위치한 그룹간 묶음선 표시여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    showLevelOutline?: boolean;
    /**
     * {@link GridFitStyle} 로 적용된 너비로 내보내기 여부
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     *
     */
    applyFitStyle?: boolean;
    /**
     * Dynamic Styles 을 적용하여 내보내기 것인지의 여부
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    applyDynamicStyles?: boolean;
    /**
     * fixed된 컬럼 또는 row가 있는 경우 틀고정 여부
     *
     * @remarks
     * fixed Column 또는 fixed Row가 있으면 엑셀로 내보내기 할때 `틀고정`을 설정한다.
     *
     * @defaultValue `false`
     */
    applyFixed?: boolean;
    /**
     * expandable이 설정된 컬럼을 export할때 expand여부
     *
     * @remarks
     * 화면의 expand상태에 상관없이 접거나 펼친 상태로 export할때 설정한다.
     *
     * @defaultValue `ignore`
     */
    layoutExpand?: ExportLayoutExpand | string;
    /**
     * 엑셀 sheet 명
     *
     * @remarks
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    sheetName?: string;
    /**
     * {@link SeriesColumn | 시리즈}컬럼을 내보내기 할 것인지의 여부
     *
     * @remarks
     * `true`로 지정하면 `sparkLine`, `sparkColumn`, `sparkWinLoss` 컬럼들이 내보내기 된다.
     *
     * 스파크 컬럼들이 참조하고 있는 {@link DataColumn}들을 반드시 포함하여 내보내기 해야하며 `DataColumn`의 `name` 속성은 반드시 지정되어 있어야 한다.
     *
     * 또한 `DataColumn`은 참조한 순서대로 표시되어 있어야 한다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     *
     */
    exportSeriesColumn?: boolean;
    /**
     * 엑셀로 내보내기 하고자 하는 컬럼의 배열
     *
     * @remarks
     * `visible`이 `false`이지만 내보내기를 하고 싶은 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    showColumns?: string[];
    /**
     * 엑셀로 내보내기 안하고자 하는 컬럼을 배열
     *
     * @remarks
     * `visible`이 `true`이지만 내보내기를 하고 싶지 않은 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    hideColumns?: string[];
    /**
     *
     * 엑셀의 hidden Column
     *
     * @remarks
     * 엑셀로 export되었을때 hidden상태로 내보내기 되는 컬럼을 지정한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    hiddenColumns?: string[];
    /**
     * LinkCellRenderer의 url을 내보내기 할것인지 여부

     * @remarks
     * `true`로 지정하면 url의 HYPERLINK로 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    exportLink?: boolean;
    /**
     * TemplateCellRenderer를 내보내기 할것인지 여부
     *
     * @remarks
     * `true`로 지정하면 TemplateCellRenderer가 renderering한 HTML에서 Tag를 제거한 문자열을 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     *
     * @defaultValue `false`
     */
    exportTemplate?: boolean;
    /**
     * 엑셀로 내보내기 하려는 모양이 화면과 다를때 사용하는 layout
     *
     * @remarks
     * 원하는 layout을 지정하여 excel로 내보내기 한다.
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    exportLayout?: ConfigObject[];
    /**
     * 내보내기를 할 그리드의 GridBase 컨트롤과 내보내기의 대상이 되는 엑셀 sheet 의 이름
     *
     * @remarks
     * 지정하지 않으면 메소드를 호출한 그리드 인스턴스가 GridBase 컨트롤로 지정되어 `'sheet1'` 에 내보내기된다.
     *
     * {@link ExportBaseOptions."type" | 내보내기 종류}가 {@link ExportType.EXCEL | 엑셀}일 때만 사용 가능하다.
     */
    exportGrids?: {
        grid: GridBase;
        sheetName: string;
    }[];
    /**
     * 왼쪽 여백컬럼의 수를 지정한다.
     *
     * @remarks
     * 그리드를 출력할때 지정된 컬럼수 이후부터 출력한다.
     */
    xOffset?: number;
    /**
     * 왼쪽 여백컬럼의 너비를 지정한다.
     *
     * @remarks
     * pixel단위로 지정한다.
     *
     * @defaultValue `100`
     */
    xOffsetWidth?: number;
    /**
     * 위쪽 여백행의 수를 지정한다.
     *
     * @remarks
     * 그리드를 출력할때 지정된 행수 이후부터 출력한다.
     */
    yOffset?: number;
    /**
     * 엑셀로 내보내기 할때 sheet에 추가할 attribute
     *
     * @remarks
     * json 형식으로 입력된 값을 sheetView element의 attribute로 추가한다.
     *
     * @example
     * ```js
     * var sheetAttrs = {
     *   showGridLines: "0", // 눈금선 감추기
     *   view: "pageBreakPreview" // 페이지 나누기 미리 보기
     * }
     * gridView.exportGrid({type:"excel", target:"local", sheetAttrs:sheetAttrs})
     * ```
     */
    sheetAttrs?: ConfigObject;
    /**
     * 엑셀로 내보내기 할때 스타일 찾기위한 접두어가 있는 경우 사용
     *
     * @remarks
     * 제공된 스타일에 영역을 제한하기 위한 className이 있는 경우 사용한다.
     */
    stylePrefix?: string;
    /**
     * excel로 export할때 image 포함 여부
     *
     * @remarks
     * `true`이면 imageRenderer, iconRenderer를 이용해서 표시한 image를 excel에 포함한다.
     * displayOptions.rowHeight가 -1인경우 셀의 상단에 표시.
     * IE의 경우 Promise 관련 polyFill을 추가해야 한다.
     *
     * @defaultValue `false`
     */
    exportImage?: boolean;
    /**
     * 사용자 지정 출력
     *
     * @remarks
     * export되는 엑셀파일에 그리드 이외의 내용을 출력할때 사용한다.
     *
     * 그리드가 출력하는 영역은 사용을 자제해야한다.
     *
     * @defaultValue `undefined`
     */
    userCells?: UserExportCell[];
    /**
     * 사용자 출력셀을 만들기 위해 호출되는 callback userCells가 지정되어있으면 callback은 무시된다.
     *
     * @remarks
     * 출력되는 column과 row의 갯수를 참조해서 cell의 위치를 변경할때 사용한다.
     *
     * @defaultValue `undefined`
     */
    userCellsCallback?: UserCellsCallback;
    /**
     * 잠긴 셀의 내용과 워크시트 보호
     *
     * @remarks
     * 다른 사용자가 잠긴 셀을 수정하지 못하도록 시트 보호를 설정한다.
     */
    sheetProtect?: boolean;
    /**
     * 시트 보호를 사용할때 해제 암호를 입력한다.
     *
     * @remarks
     * 영문/숫자/특수문자만 입력해야한다. 한글을 입력하는 경우 시트보호를 해제할수 없다.
     */
    protectPassword?: string;
    /**
     * 시트 보호를 사용할때 허용하거나 잠글 속성을 지정한다.
     */
    protectProperties?: SheetProtectProperties;
}
/**
 * @public
 * {@link GridExportOptions} 모델과 {@link GridBase.exportGrid} 를 사용하여 그리드를 내보내기 할 때, Excel 문서의 제목, 부제, 꼬릿말을 설정하기 위한 모델
 *
 * @remarks
 * {@link GridExportOptions.documentTitle}, {@link GridExportOptions.documentSubtitle | documentSubtitle}, {@link GridExportOptions.documentTail | documentTail} 에서 사용된다.
 */
interface DocumentTitle {
    /**
     * 설정할 메시지 (제목) 내용
     *
     * @defaultValue `''`
     */
    message: string;
    /**
     * 엑셀에 출력 여부
     *
     * @defaultValue `true`
     */
    visible: boolean;
    /**
     * 윗 여백 (행)
     *
     * @defaultValue `0`
     */
    spaceTop: number;
    /**
     * 아래 여백 (행)
     *
     * @defaultValue `0`
     */
    spaceBottom: number;
    /**
     * 제목의 전체 높이
     *
     * @remarks
     * 높이를 지정하지 않으면 (`-1`이면) 1행으로 표시된다.
     *
     * @defaultValue `-1`
     */
    height: number;
    /**
     * 셀들에게 적용할 스타일들
     */
    styles?: string;
    /**
     * title에 적용될 className
     * @remarks
     * styleName이 설정되면 styles는 적용되지 않는다.
     */
    styleName?: string;
}
/**
 * @public
 * 엑셀로 export할때 그리드가 출력하는 내용외에 추가적으로 출력할 내용을 지정한다.
 *
 * @remarks
 * 그리드가 출력하는 영역을 덮어쓰는 경우 엑셀파일에 오류가 발생할수 있기 때문에 주의해야 한다.
 * row, col, value는 반드시 지정해야 한다.
 * @example
 * ```js
 * var userCells = [
 *  {row: 0, col: 0, value: "사용자 입력문자열"},
 *  {row: 1, col: 0, styleName: "userCellRed", value: "스타일을 적용"},
 *  {row: 2, col: 0, mergeRow: 1, mergeCol: 3, styleName: "userCellRed", value: "merge를 하고 스타일을 적용."},
 *  {row: 3, col: 0, value: "inline-style", styles: {background:"red", fontSize:"20px"}},
 *  {row: 4, col: 0, value: 12345, format: "#,##0.0_ ", styles: {textAlign:"right"}},
 *  {row: 4, col: 2, value: new Date(2022, 4, 16), format: "[$-F800]dddd, mmmm dd, yyyy", styles: {textAlign:"center"}},
 * ]
 * gridView.exportGrid({"type": "excel", "target": "local", "yOffset": 5, "userCells": userCells});
 * ```
 */
interface UserExportCell {
    /**
     * 출력될 행번호 `0`부터 계산된다.
     */
    row: number;
    /**
     * 출력될 컬럼번호 `0`부터 계산된다.
     */
    col: number;
    /**
     * 출력될 내용
     *
     * @remarks
     * string, numbar, Date, boolean 형태의 값을 입력한다.
     */
    value: any;
    /**
     * 셀에 적용될 className
     */
    styleName?: string;
    /**
     * 셀에 적용될 format을 입력한다.
     */
    format?: string;
    /**
     * 셀에 적용될 스타일
     *
     * @example
     * ```js
     * var styles = {
     *     textAlign: "center",
     *     background: "green",
     *     color: "red"
     * }
     *
     * var styles2 = "text-align:center;background:green;color:red"
     * ```
     *
     */
    styles?: ConfigObject | string;
    /**
     * merge할 경우 row갯수
     */
    mergeRow?: number;
    /**
     * merge할 경우 컬럼갯수
     */
    mergeCol?: number;
    /**
     * 행의 높이를 지정한다.
     *
     * @remarks
     * 이미 출력된 행에 추가되는 경우 출력행의 높이를 유지한다.
     *
     * @defaultValue `-1` 엑셀이 높이를 결정.
     */
    height?: number;
    /**
     * mergeRow가 있는 경우 각행의 높이를 지정한다.
     *
     * @remarks
     * 지정하지 않으면 height가 적용된다.
     */
    heights?: number[];
    /**
     * @internal
     * @remarks
     * 수식.
     */
    formula?: string;
    /**
     * @internal
     * @remarks
     *
     * 잠금
     */
    cellProtectProps?: CellProtectProperties;
}
/**
 * @public
 *
 * 엑셀 시트 보호를 적용시 허용할 속성을 지정한다.
 *
 * @remarks
 * 허용하는 경우 "0" 허용하지 않는 경우 "1"을 입력한다.
 *
 * 속성을 지정하지 않으면 엑셀 기본값으로 설정된다.
 *
 * 셀의 잠금/서식숨기기 속성은 {@link DataColumn.cellProtectProps}또는 {@link ColumnStyleObject.cellProtectProps}를 이용한다.
 *
 * @example
 * ```js
 * gridView.exportGrid({
 *     type: "excel",
 *     target: "local",
 *     sheetProtect: true;
 *     protectProperties: {
 *         selectLockedCells: "0",
 *         selectUnlockedCells: "0"
 *     },
 *     protectPassword: "12345678";
 * })
 * ```
 */
interface SheetProtectProperties {
    /**
     * 셀 서식
     */
    formatCells?: string;
    /**
     * 열 서식
     */
    formatColumns?: string;
    /**
     * 행 서식
     */
    formatRows?: string;
    /**
     * 열 삽입
     */
    insertColumns?: string;
    /**
     * 행 삽입
     */
    insertRows?: string;
    /**
     * 하이퍼링크 삽입
     */
    insertHyperlinks?: string;
    /**
     * 열 삭제
     */
    deleteColumns?: string;
    /**
     * 행 삭제
     */
    deleteRows?: string;
    /**
     * 정렬
     */
    sort?: string;
    /**
     * 자동 필터 사용
     */
    autoFilter?: string;
    /**
     * 피벗 테이블 보고서 사용
     */
    pivotTables?: string;
    /**
     * 객체 편집
     */
    objects?: string;
    /**
     * 시나리오 편집
     */
    scenarios?: string;
    /**
     * 잠긴 셀 선택
     */
    selectLockedCells?: string;
    /**
     * 잠기지 않은 셀 선택
     */
    selectUnlockedCells?: string;
}
/**
 * @public
 *
 * 셀 잠금 또는 셀 숨김을 설정한다.
 *
 * @remarks
 * DataCell영역에만 적용되고 그외 영역은 적용할수 없다.
 * {@link DataColumn.cellProtectProps} 또는 {@link ColumnStyleObject.cellProtectProps}에서 사용한다.
 * {@link GridExportOptions.sheetProtect}을 이용해서 시트 보호를 설정해야 적용된다.
 */
interface CellProtectProperties {
    /**
     * 잠금
     *
     * @remarks
     * 엑셀 셀의 기본 설정은 잠금이다. 입력가능한 컬럼 또는 셀만 `locked`를 `0`으로 설정한다.
     */
    locked?: string;
    /**
     * 수식 숨기기
     *
     * @remarks
     * 셀의 수식을 숨기기 위해서는 `hidden`을 `1`로 설정한다.
     */
    hidden?: string;
}

/**
 * layout Expandable이 true인 layut을 excel로 export할때
 */
declare enum ExportLayoutExpand {
    /**
     * expandable을 무시하고 설정된 layout모양대로 출력한다.
     */
    IGNORE = "ignore",
    /**
     * current 현재모양
     */
    CURRENT = "current",
    /**
     * 펼쳐진 상태로 출력한다.
     */
    EXPAND = "expand",
    /**
     * 접힌 상태로 출력한다.
     */
    COLLAPSE = "collapse"
}

/**
 * [ Spanning ]
 * layout 단위로 span 한다. 즉, 다음 layout이 그룹이면 그 그룹 전체를 span 한다.
 * 그룹을 벗어나서 span할 수 없다.
 * 그룹은 span할 수 없다.
 * 왼쪽에서 오른쪽으로, 위에서 아래로 진행한다.
 * 상위 layout부터 먼저 span 한다(top-down).
 * 그룹이 다음 layout들을 span  한 경우 새로 추가된 셀들을 하위 layout들에 배분한다.
 * (배분 방식: 하위 layout의 cell 개수 비율에 따라 마지막 layout부터 배분한다.)
 *
 * 행 병합 상태일 경우 span  하려는 다음 layout들과 행 어긋남이 없어야 한다.
 * fixed, rightFixed 경계를 넘어갈 수 없다.
 *
 * @internal
 */
declare abstract class CellLayoutItem extends Base {
    static compareLoc(c1: CellLayoutItem, c2: CellLayoutItem): number;
    static getSource(layout: CellLayoutItem): CellLayoutItem;
    private _visible;
    private _width;
    private _fillWidth;
    private _groupShowMode;
    protected _header: CellLayoutHeader;
    private _parent;
    private _index;
    private _vindex;
    protected _row: number;
    protected _col: number;
    protected _hrow: number;
    protected _hcol: number;
    protected _cspan: number;
    protected _hspan: number;
    protected _dspan: number;
    protected _clen: number;
    protected _hlen: number;
    protected _dlen: number;
    private _root;
    private _dataRoot;
    protected _cellWidth: number;
    private _fitWidth;
    private _merged;
    private $_grid;
    private $_fixed;
    private $_rfixed;
    protected _defColSpan: number;
    /**
    column에서 width와 관련된 요소들.
    width => 화면설정시 너비를 결정.
    fillWidth  => fill 일때 차지하는 비율
    displayWidth => layout이 있으면 layout._cellWidth 없으면 width

    layout에서.
    width, => 화면설정시 너비를 결정.
    cellWidth => fit이 아닐때 화면의 너비.
    fitWidth => fit일때 화면의 너비
    fillWidth => fill일때 차지하는 비율

    cellWidth를 이용해서 크기를 읽고 변경한다고 가정.

     */
    constructor();
    protected _doDispose(): void;
    abstract get cols(): number;
    abstract get headerRows(): number;
    abstract get rows(): number;
    abstract get firstColumn(): GridColumn;
    abstract get lastColumn(): GridColumn;
    abstract get first(): CellLayoutItem;
    abstract get last(): CellLayoutItem;
    abstract get boundColumn(): GridColumn;
    abstract get cellWidth(): number;
    abstract set cellWidth(value: number);
    get grid(): GridBase$1;
    get source(): CellLayoutItem;
    /** null */
    get isNull(): boolean;
    /** proxy */
    get isProxy(): boolean;
    /**
     * visible property.
     * 컬럼이 연결된 layout의 경우 column의 visible도 true여야 그리드에 표시된다.
     */
    get visible(): boolean;
    set visible(value: boolean);
    protected $_isVisible(isExport?: boolean): boolean;
    /** header */
    get header(): CellLayoutHeader;
    get owner(): GridCellLayout;
    /** parent */
    get parent(): CellLayoutGroupItem;
    /** group */
    get group(): CellLayoutGroupItem;
    /** root */
    get root(): CellLayoutItem;
    /** isRoot RootCellLayout체크가 아닌 root하위 layout인가이다. group하위이면 false rootLayout하위 이면 true. 헷갈리지 말자. */
    get isRoot(): boolean;
    /** dataRoot */
    get dataRoot(): CellLayoutItem;
    /** index */
    get index(): number;
    /** vindex */
    get vindex(): number;
    set vindex(value: number);
    /** row */
    get row(): number;
    /** col */
    get col(): number;
    /** hrow */
    get hrow(): number;
    /** hcol */
    get hcol(): number;
    /** width */
    get width(): number;
    set width(value: number);
    /** fillWidth */
    get fillWidth(): number;
    set fillWidth(value: number);
    get groupShowMode(): GroupShowMode;
    set groupShowMode(value: GroupShowMode);
    /** cellWidth */
    get domWidth(): number;
    /** distance */
    get distance(): number;
    /** cspan */
    get cspan(): number;
    /** hspan */
    get hspan(): number;
    /** hlen */
    get hlen(): number;
    /** merged */
    get merged(): boolean;
    /** isFixed */
    get isFixed(): boolean;
    /** displayText */
    abstract get displayText(): string;
    protected abstract _isResizable(): boolean;
    protected abstract _isMovable(): boolean;
    abstract clearMergeGrouped(): void;
    load(src: ConfigObject): void;
    isColumn(column: GridColumn): boolean;
    cleanColumns(): void;
    findLayout(column: GridColumn): CellLayoutColumnItem;
    getHeaderSpan(): number;
    getSummarySpan(summaryIndex: number): number;
    getFooterSpan(footerIndex: number): number;
    getDataSpan(): number;
    getGroupFooterSpan(itemIndex: number, footerIndex: number): number;
    getDataColumn(): DataColumn;
    getFooterUserSpan(footerIndex: number): UserSpan;
    getSummaryUserSpan(footerIndex: number): UserSpan;
    protected _createHeader(): CellLayoutHeader;
    protected _headerChanged(): void;
    protected _prepareLayout(grid: GridBase$1, fixed: boolean, rfixed: boolean): void;
    protected _detach(): void;
    protected _getWidth(value: number): number;
    protected _getFillWidth(value: number): number;
    /**
     * 현재 보여지는 기준으로 width를 조정한다.
     * 최상위 layout이고 fiiting이 아니면 width를 변경하는 것과 동일하다.
     * fitting인 경우 layout에 추가된 fill 너비 비율에 맞춰 조정한다.
     * 실제로 변경하는 것은 width이고, _cellWidth, _fitWidth는 계산된다.
     *
     * setter를 통해서 실행된것과 ui에 의해서 실행된것은 fit일때 다르다.
     */
    changeCellWidth(newWidth: number, fitting: boolean, isSet?: boolean): void;
    protected _setFitWidth(value: number): void;
    protected _clearFitWidth(): void;
    protected _changed(): void;
    private $_setMerged;
    protected _propChanged(prop: string, newValue: any, oldValue: any): void;
}
/** @internal */
declare type CellSpanCallback = (grid: GridBase$1, layout: CellLayoutColumnItem, itemIndex: number) => number;
/** @internal */
declare type SummaryCellSpanCallback = (grid: GridBase$1, layout: CellLayoutColumnItem, summaryIndex: number) => number;
/** @internal */
declare type GroupFooterCellSpanCallback = (grid: GridBase$1, layout: CellLayoutColumnItem, itemIndex: number, footerIndex: number) => number;
/** @internal */
declare type GroupFooterUserSpanCallback = (grid: GridBase$1, layout: CellLayoutColumnItem, model: GroupItem, itemIndex: number, footerIndex: number) => UserSpan;
/**
 * 컬럼 레이아웃 설정 정보 모델: interface 로 문서작업
 * @internal
 */
declare class CellLayoutColumnItem extends CellLayoutItem {
    private _mergeRule;
    private _breakMergeOnEmpty;
    private _equalBlank;
    private _equalBlankExpression;
    private _cellSpan;
    private _headerSpan;
    private _summarySpans;
    private _footerSpans;
    private _dataSpan;
    private _groupFooterSpans;
    private _spanCallback;
    private _summarySpanCallback;
    private _footerSpanCallback;
    private _groupFooterSpanCallback;
    private _groupFooterUserSpanCallback;
    private _footerUserSpans;
    private _summaryUserSpans;
    private _groupFooterUserSpans;
    private _column;
    private _columnObj;
    private _mergeRuleObj;
    private _merges;
    private _equalBlankNode;
    private _cellWidths;
    private _cols;
    private _rows;
    constructor(column: string | ValueColumn);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 컬럼
     * @internal
     */
    get column(): string | ValueColumn;
    get cellWidth(): number;
    set cellWidth(value: number);
    /**
     * merges
     * @internal
     */
    get merges(): ColumnMergeManager;
    /**
     * 컬럼 머지할 때의 규칙
     *
     * @remarks
     * `undefined` 이면(기본값) 컬럼의 mergeRule 로 병합한다.
     * `null` 이면 컬럼의 mergeRule 을 무시한다.
     */
    get mergeRule(): string;
    set mergeRule(value: string);
    /**
     * ?
     */
    get breakMergeOnEmpty(): boolean;
    set breakMergeOnEmpty(value: boolean);
    /**
     * @internal
     */
    isBreakMergeOnEmpty(): boolean;
    /**
     * 같은 컬럼의 이전 행의 셀과 값이 동일할때 셀의 묶음 여부
     *
     * @defaultValue `undefined`
     */
    get equalBlank(): boolean;
    set equalBlank(value: boolean);
    /**
     * equalBlankNode
     * @internal
     */
    get equalBlankNode(): ExpressionNode;
    /**
     * blanked
     * @internal
     */
    get blanked(): boolean;
    /**
     * {@link CellLayoutColumnItem.equalBlank | equalBlank } 가 `true`인 경우 같은 값으로 처리할 수식
     *
     * @defaultValue `undefined`
     */
    get equalBlankExpression(): string;
    set equalBlankExpression(value: string);
    /** cellSpan */
    get cellSpan(): number;
    set cellSpan(value: number);
    /** headerSpan */
    get headerSpan(): number;
    set headerSpan(value: number);
    /** summarySpan */
    get summarySpan(): number;
    set summarySpan(value: number);
    /** summarySpans */
    get summarySpans(): number[];
    set summarySpans(value: number[]);
    /** footerSpan */
    get footerSpan(): number;
    set footerSpan(value: number);
    /** footerSpans */
    get footerSpans(): number[];
    set footerSpans(value: number[]);
    /** dataSpan */
    get dataSpan(): number;
    set dataSpan(value: number);
    /** groupFooterSpan */
    get groupFooterSpan(): number;
    set groupFooterSpan(value: number);
    /** groupFooterSpans */
    get groupFooterSpans(): number[];
    set groupFooterSpans(value: number[]);
    /** spanCallback */
    get spanCallback(): CellSpanCallback;
    set spanCallback(value: CellSpanCallback);
    /** summarySpanCallback */
    get summarySpanCallback(): SummaryCellSpanCallback;
    set summarySpanCallback(value: SummaryCellSpanCallback);
    /** footerSpanCallback */
    get footerSpanCallback(): SummaryCellSpanCallback;
    set footerSpanCallback(value: SummaryCellSpanCallback);
    /** groupFooterSpanCallback */
    get groupFooterSpanCallback(): GroupFooterCellSpanCallback;
    set groupFooterSpanCallback(value: GroupFooterCellSpanCallback);
    /** footerUserSpans */
    get footerUserSpans(): UserSpan[];
    set footerUserSpans(value: UserSpan[]);
    /** summaryUserSpans */
    get summaryUserSpans(): UserSpan[];
    set summaryUserSpans(value: UserSpan[]);
    /** groupFooterUserSpans */
    get groupFooterUserSpans(): UserSpan[];
    set groupFooterUserSpans(value: UserSpan[]);
    /** groupFooterUserSpanCallback */
    get groupFooterUserSpanCallback(): GroupFooterUserSpanCallback;
    set groupFooterUserSpanCallback(value: GroupFooterUserSpanCallback);
    /**
     * @internal
     */
    canMerge(): boolean;
    get isNull(): boolean;
    get cols(): number;
    get headerRows(): number;
    get rows(): number;
    get first(): CellLayoutItem;
    get last(): CellLayoutItem;
    get firstColumn(): GridColumn;
    get lastColumn(): GridColumn;
    get boundColumn(): GridColumn;
    get displayText(): string;
    getHeaderSpan(): number;
    getSummarySpan(summaryIndex: number): number;
    getFooterSpan(footerIndex: number): number;
    getFooterUserSpan(footerIndex: number): UserSpan;
    getSummaryUserSpan(summaryIndex: number): UserSpan;
    getGroupFooterUserSpan(item: GroupItem, summaryIndex: number): UserSpan;
    getGroupFooterSpan(itemIndex: number, footerIndex: number): number;
    getDataSpan(): number;
    getDataColumn(): DataColumn;
    protected _createHeader(): CellLayoutHeader;
    protected _isResizable(): boolean;
    protected _isMovable(): boolean;
    isColumn(column: GridColumn): boolean;
    findLayout(column: GridColumn): CellLayoutColumnItem;
    load(src: ConfigObject): void;
    cleanColumns(): void;
    protected $_isVisible(isExport?: boolean): boolean;
    protected _getWidth(value: number): number;
    protected _getFillWidth(value: number): number;
    private _blankNodeRun;
    private _blanked;
    protected _prepareLayout(grid: GridBase$1, fixed: boolean, rfixed: boolean): void;
    toString(): string;
    clearMergeGrouped(): void;
    private $_bindColumn;
    private $_mergeRuleObj;
}
/**
 * Cell Layout 설정 시 배치 방향
 *
 * @remarks
 * {@link CellLayoutGroupItem.direction} 에서 사용된다.
 */
declare enum ColumnLayoutDirection {
    /**
     * 수직적으로 배치
     */
    VERTICAL = "vertical",
    /**
     * 수평적으로 배치
     */
    HORIZONTAL = "horizontal"
}
/** @internal */
declare class CellLayoutHeader extends Base {
    protected _layout: CellLayoutItem;
    private _text;
    protected _rows: number;
    constructor(layout: CellLayoutItem);
    get layout(): CellLayoutItem;
    /** text */
    get text(): string;
    set text(value: string);
    /** styleName */
    get styleName(): string;
    set styleName(value: string);
    /** exportStyleName */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    get rows(): number;
    isVisible(): boolean;
    getDisplayText(): string;
    protected doAssignSimple(source: any): boolean;
    protected _changed(): void;
}
/**
 * 컬럼 그룹의 레이아웃
 * @internal
 */
declare class CellLayoutGroupItem extends CellLayoutItem {
    static getNext(layout: CellLayoutItem): CellLayoutItem;
    static getPrev(layout: CellLayoutItem): CellLayoutItem;
    static isTop(layout: CellLayoutItem): boolean;
    static isBottom(layout: CellLayoutItem): boolean;
    static isLeft(layout: CellLayoutItem): boolean;
    static isRight(layout: CellLayoutItem): boolean;
    private _name;
    private _direction;
    private _items;
    private _resizable;
    private _movable;
    private _hideChildHeaders;
    private _childColumnMovable;
    private _expandable;
    private _expanded;
    private _visibles;
    private _cols;
    private _rows;
    private _headerRows;
    private _expandedLayouts;
    private _collapsedLayouts;
    constructor(name: string, direction: ColumnLayoutDirection);
    /**
     * @internal
     */
    _doDispose(): void;
    /** name */
    get name(): string;
    /** direction */
    get direction(): ColumnLayoutDirection;
    set direction(value: ColumnLayoutDirection);
    /** vertical */
    get vertical(): boolean;
    /** horizontal */
    get horizontal(): boolean;
    /** resizable */
    get resizable(): boolean;
    set resizable(value: boolean);
    /** movable */
    get movable(): boolean;
    set movable(value: boolean);
    /**
     * hideChildHeaders.
     * header.visible이 false면 이 설정은 의미가 없다.
     */
    get hideChildHeaders(): boolean;
    set hideChildHeaders(value: boolean);
    get childColumnMovable(): boolean;
    set childColumnMovable(value: boolean);
    /** count */
    get count(): number;
    /** items */
    get items(): CellLayoutItem[];
    set items(value: CellLayoutItem[]);
    /** visibleCount */
    get visibleCount(): number;
    /** visibles */
    get visibles(): CellLayoutItem[];
    protected $_isVisible(isExport?: boolean): boolean;
    /** expandable */
    get expandable(): boolean;
    set expandable(value: boolean);
    /** expanded */
    get expanded(): boolean;
    set expanded(value: boolean);
    contains(item: CellLayoutItem): boolean;
    indexOf(item: CellLayoutItem): number;
    getItem(index: number): CellLayoutItem;
    getVisible(index: number): CellLayoutItem;
    addColumn(column: ValueColumn, index?: number): void;
    addItem(item: CellLayoutItem, index?: number): void;
    removeColumn(column: ValueColumn): void;
    clear(recursive?: boolean): void;
    removeItem(item: CellLayoutItem): void;
    removeItemAt(index: number): void;
    moveItem(from: number, to: number): void;
    getColumn(grid: GridBase$1, row: number, col: number): GridColumn;
    findItem(column: GridColumn): CellLayoutColumnItem;
    layoutByName(name: string): CellLayoutItem;
    rightOf(layout: CellLayoutItem): CellLayoutItem;
    leftOf(layout: CellLayoutItem): CellLayoutItem;
    nextOf(layout: CellLayoutItem): CellLayoutItem;
    prevOf(layout: CellLayoutItem): CellLayoutItem;
    lowerOf(layout: CellLayoutItem): CellLayoutItem;
    upperOf(layout: CellLayoutItem): CellLayoutItem;
    isExpandable(): boolean;
    expandAll(expanded: boolean, recursive: boolean): void;
    protected _clearFitWidth(): void;
    get cellWidth(): number;
    set cellWidth(value: number);
    get cols(): number;
    get headerRows(): number;
    get rows(): number;
    get first(): CellLayoutItem;
    get last(): CellLayoutItem;
    get firstColumn(): GridColumn;
    get lastColumn(): GridColumn;
    get boundColumn(): GridColumn;
    get displayText(): string;
    protected _createHeader(): CellLayoutHeader;
    load(src: ConfigObject): void;
    findLayout(column: GridColumn): CellLayoutColumnItem;
    cleanColumns(): void;
    protected _isResizable(): boolean;
    protected _isMovable(): boolean;
    protected _setFitWidth(value: number): void;
    protected _prepareLayout(grid: GridBase$1, fixed: boolean, rfixed: boolean): void;
    toString(): string;
    clearMergeGrouped(): void;
    protected _loadItems(source: ConfigObject[]): void;
    protected $_bindColumns(colMap: {
        [key: number]: CellLayoutItem;
    }, columns: ColumnCollection, isExport?: boolean): void;
    private $_parseExpandLayouts;
    private $_parseHeaderCells;
    private $_fillHorz;
    private $_fillVert;
    /**
     * 비어 있는 셀들을 채운다.
     * 바로 아래 자식 item들의 너비/높이를 자신의 높이/너비에 맞춘다.
     */
    private $_adjustHeaderCells;
    private $_parseDataCells;
    /**
     * 비어 있는 셀들을 채운다.
     * 바로 아래 자식 item들의 너비/높이를 자신의 높이/너비에 맞춘다.
     */
    private $_adjustDataCells;
    private $_calcSpans;
    protected $_resetVisibles(isExport?: boolean): void;
    private $_getLeaf;
    private $_collectCellWidths;
    private $_arrangeCellWidths;
    /**
     * 컬럼 상 같은 위치에 있는 셀들의 평균을 셀들의 너비로 지정한다.
     * setLayout시와 resize시 동작이 다르다.
     * setLayout시에는 widths(_cellWidths)를 설정해야하고 resize시에는 설정하지 않아야 한다.
     * columnMove시에는 widths를 설정하지만 기존 column이 가지고 있는 _cellWidth로 설정한다. 재계산하지 않는다.
     * 최초 load와 columnMove에서 발생하는 동작이 다를수 밖에는 없을것이다.
     */
    private $_calcCellWidths;
    protected _childIndexChanged(item: CellLayoutItem): void;
    protected _childWidthChanged(item: CellLayoutItem): void;
    protected _childFillWidthChanged(item: CellLayoutItem): void;
    protected $_checkVisible(item: CellLayoutItem): number;
    private $_collectHorzColumns;
    private $_changeChildVIndex;
    private $_changeChildIndex;
}
/** @internal */
declare class GridCellLayout extends EventAware {
    private _grid;
    private _root;
    private _dirty;
    private _resized;
    private _moveColumn;
    private _headerCells;
    private _dataCells;
    private _cellWidths;
    constructor(grid: GridBase$1);
    _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    /** count */
    get count(): number;
    /** visibleCount */
    get visibleCount(): number;
    get headerRows(): number;
    get dataRows(): number;
    get first(): CellLayoutItem;
    get last(): CellLayoutItem;
    get firstColumn(): GridColumn;
    load(source: ConfigObject[]): GridCellLayout;
    resetColumns(columns: ColumnCollection): void;
    cleanColumns(): void;
    invalidate(): void;
    invalidateIndices(item: CellLayoutItem): void;
    invalidateSize(): void;
    getVisible(index: number): CellLayoutItem;
    add(group: CellLayoutGroupItem | null, column: ValueColumn, index?: number): void;
    remove(group: CellLayoutGroupItem | null, column: ValueColumn): void;
    setColumns(columns: ColumnCollection): void;
    layoutByColumn(column: GridColumn): CellLayoutColumnItem;
    layoutByName(name: string): CellLayoutItem;
    getHeaderCellPos(column: GridColumn): {
        row: number;
        col: number;
    };
    getDataCellPos(column: GridColumn): {
        row: number;
        col: number;
    };
    getDataColumns(visibleOnly?: boolean): DataColumn[];
    collectColumns(columnsOnly: boolean, visibleOnly: boolean, ordered: boolean): GridColumn[];
    collectLayouts(visibleOnly: boolean): CellLayoutItem[];
    collectColumnNames(columnsOnly: boolean, visibleOnly: boolean, groupOnly?: boolean, parent?: string | CellLayoutGroupItem): string[];
    collectDataColumns(c1: CellLayoutItem, c2: CellLayoutItem): DataColumn[];
    getHorzColumns(start?: number, count?: number): ValueColumn[];
    getHomeOf(layout?: CellLayoutItem): CellLayoutItem;
    getEndOf(layout?: CellLayoutItem): CellLayoutItem;
    getTopOf(layout: CellLayoutItem): CellLayoutItem;
    getBottomOf(layout: CellLayoutItem, holdProxy?: boolean): CellLayoutItem;
    getLowerOf(layout: CellLayoutItem): {
        dy: number;
        layout: CellLayoutItem;
    };
    getUpperOf(layout: CellLayoutItem): {
        dy: number;
        layout: CellLayoutItem;
    };
    getRightOf(layout: CellLayoutItem): CellLayoutItem;
    getLeftOf(layout: CellLayoutItem): CellLayoutItem;
    getCellWidths(col: number, cols: number): number;
    getLayout(isExport: boolean, fit: boolean, allColumns: boolean, includes?: string[], excludes?: string[], layoutExpand?: ExportLayoutExpand): LayoutInfo$1[];
    expandAll(expand: boolean, recursive: boolean): void;
    protected _changed(): void;
    private $_clear;
    $_refresh(columns: ColumnCollection, minCellWidth: number): void;
    $_refresh2(columns: ColumnCollection, minCellWidth: number): void;
    $_prepareMerges(grid: GridBase$1): void;
    $_prepareLayout(grid: GridBase$1, fixedCols: number, rightCols: number): void;
    private $_parseCells;
    private $_parseHeaderCells;
    private $_parseDataCells;
    private $_calculateCellWidths;
    private $_clearFitWidths;
    protected _columnsChanged(columns: ColumnCollection): void;
    protected _columnChanged(column: GridColumn): void;
    protected _itemIndexChanged(item: CellLayoutItem): void;
    protected _itemWidthChanged(item: CellLayoutItem): void;
    protected _itemFillWidthChanged(item: CellLayoutItem): void;
    protected _clearMergeGrouped(): void;
    /**
     * change될때는 이미 계산된 root._cellWidths만 변경한다.
     * 변경후 group의 너비도 수정한다.
     */
    private $_changeCellWidths;
    private $_calcGroupWidths;
}

/** @internal */
declare class DragTracker extends Base {
    private _container;
    private _name;
    private _active;
    private _completed;
    private _dragging;
    private _startX;
    private _startY;
    private _currentX;
    private _currentY;
    constructor(container: VisualContainer, name: string);
    /** container */
    get container(): VisualContainer;
    /** name */
    get name(): string;
    /** active */
    get active(): boolean;
    /** dragging */
    get dragging(): boolean;
    /** startWhenCreated */
    get startWhenCreated(): boolean;
    /** completed */
    get completed(): boolean;
    /**
     * linkable proprerty.
     * 다른 그리드에서 진행 가능한 tracker.
     */
    get linkable(): boolean;
    /** tracker가 종료된후 click event를 발생할것인가
     *
    */
    get clickable(): boolean;
    get scrollable(): boolean;
    activate(): void;
    deactivate(): void;
    start(eventTarget: HTMLElement, x: number, y: number, event?: MouseEvent | TouchEvent): boolean;
    drag(eventTarget: HTMLElement, x: number, y: number): boolean;
    cancel(): void;
    drop(eventTarget: HTMLElement, x: number, y: number): void;
    getRequest(): EditRequest;
    getNextRequest(x: number, y: number): EditRequest;
    protected get currentX(): number;
    protected get currentY(): number;
    protected _showFeedback(x: number, y: number): void;
    protected _moveFeedback(x: number, y: number): void;
    protected _hideFeedback(): void;
    protected _doActivate(): void;
    protected _doDeactivate(): void;
    protected _doStart(eventTarget: HTMLElement, x: number, y: number, event: MouseEvent | TouchEvent): boolean;
    protected _doDrag(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCanceled(x: number, y: number): void;
    protected _canAccept(eventTarget: HTMLElement, x: number, y: number): boolean;
    protected _doCompleted(eventTarget: HTMLElement, x: number, y: number): void;
    protected _doEnded(): void;
}

/** @internal */
interface FormItemContainer {
    itemVisibleChanged(item: FormItem$1): void;
    itemChanged(item: FormItem$1): void;
}
/** @internal */
interface ColumnBinder {
    getColumnObject(column: string): ValueColumn;
    getDataFieldIndex(field: string): number;
}
/** @internal */
declare class Form extends EventAware implements FormItemContainer {
    static readonly CHANGED = "onFormChanged";
    private _modal;
    private _header;
    private _footer;
    private _body;
    private _items;
    private _itemChanged;
    private _visibleChanged;
    private _visibleItems;
    constructor();
    _doDispose(): void;
    itemVisibleChanged(item: FormItem$1): void;
    itemChanged(item: FormItem$1): void;
    /** header */
    get header(): FormHeader$1;
    /** footer */
    get footer(): FormFooter$1;
    /** body */
    get body(): FormBody$1;
    /** itemCount */
    get itemCount(): number;
    /** visibleItemCount */
    get visibleItemCount(): number;
    load(source: ConfigObject): void;
    getItem(index: number): FormItem$1;
    getVisibleItem(index: number): FormItem$1;
    protected _changed(): void;
    private $_loadItems;
    private $_refreshItems;
    private $_resetvisibles;
    private $_prepareLayout;
}
/** @internal */
declare class FormObject extends Base {
    constructor();
    _doDispose(): void;
    protected _changed(): void;
}
/** @internal */
interface FormCell {
    displayText: string;
}
/** @internal */
declare abstract class FormSection extends FormObject {
    private _visible;
    private _styleName;
    private _owner;
    constructor(owner: Form);
    _doDispose(): void;
    /** owner */
    get owner(): Form;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** styleName */
    get styleName(): string;
    protected _changed(): void;
    protected abstract _getDefaultStyle(): string;
}
/** @internal */
declare class FormHeader$1 extends FormSection {
    private static readonly STYLE_NAME;
    private _height;
    private _labelCell;
    private _valueCell;
    constructor(owner: Form);
    _doDispose(): void;
    /** height */
    get height(): number;
    set height(value: number);
    /** labelCell */
    get labelCell(): FormCell;
    set labelCell(value: FormCell);
    /** valueCell */
    get valueCell(): FormCell;
    set valueCell(value: FormCell);
    protected _getDefaultStyle(): string;
}
/** @internal */
declare class FormBody$1 extends FormSection {
    private static readonly STYLE_NAME;
    private _minRowHeight;
    constructor(owner: Form);
    _doDispose(): void;
    /** minRowHeight */
    get minRowHeight(): number;
    set minRowHeight(value: number);
    protected _getDefaultStyle(): string;
}
/** @internal */
declare class FormFooter$1 extends FormSection {
    private static readonly STYLE_NAME;
    private _height;
    private _popupMenu;
    private _popupMenuName;
    constructor(owner: Form);
    _doDispose(): void;
    /** height */
    get height(): number;
    set height(value: number);
    /** popupMenu */
    get popupMenu(): ConfigObject[] | string;
    set popupMenu(value: ConfigObject[] | string);
    getPopupMenuName(grid: GridBase$1): string;
    protected _getDefaultStyle(): string;
}
/** @internal */
declare abstract class FormItem$1 extends Base {
    private _visible;
    private _height;
    protected _group: FormItemContainer;
    private _vindex;
    constructor();
    _doDispose(): void;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** vindex */
    get vindex(): number;
    canEdit(): boolean;
    private $_attached;
    protected _changed(): void;
    protected _headerChanged(): void;
    private $_refresh;
    /**
     * row는 FormView가 넘긴다.
     */
    private $_prepareLayout;
    protected _doPrepare(form: Form, binder: ColumnBinder, row: number): void;
}
/** @internal */
declare class FormItemHeader extends FormObject {
    private _text;
    private _owner;
    constructor(owner: FormValueItem);
    _doDispose(): void;
    /** text */
    get text(): string;
    set text(value: string);
    /** owner */
    get owner(): FormValueItem;
    /** displayText */
    get displayText(): string;
    protected doAssignSimple(src: any): boolean;
    protected _changed(): void;
}
/** @internal */
declare abstract class FormValueItem extends FormItem$1 {
    private _renderer;
    private _header;
    constructor();
    _doDispose(): void;
    /** header */
    get header(): FormItemHeader;
    /** value */
    abstract get displayLabel(): string;
    /** renderer */
    get renderer(): any;
    set renderer(value: any);
    /** value */
    abstract get value(): any;
    /** valueChanged */
    get valueChanged(): boolean;
    assignFrom(src: any): void;
}

/** @internal */
declare class Size {
    width: number;
    height: number;
    static readonly EMPTY: Size;
    static empty(): Size;
    static create(w?: number, h?: number): Size;
    constructor(width?: number, height?: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Size;
    equals(sz: Size): boolean;
    setEmpty(): Size;
    set(width: number, height: number): Size;
    round(): Size;
    toString(): string;
}

declare enum DateProperty {
    YEAR = 0,
    HALF = 1,
    QUARTER = 2,
    MONTH = 3,
    WEEK = 4,
    DAY = 5,
    HOUR = 6
}
/** @internal */
declare class DateTimeConverter {
    private static readonly DEFAULT_FORMAT;
    static readonly Default: DateTimeConverter;
    static getSimpleDateNull(date: any): Date | null;
    static getDateProperty(d: Date, type: DateProperty): number;
    private _format;
    private _amText;
    private _pmText;
    private _baseYear;
    constructor(format: string);
    /** format */
    get format(): string;
    set format(value: string);
    /**
     * 1. trim()한다.
     * 2. 이어진 space는 하나의 space로 간주한다.
     * 3. 일 구분자는 ".", "/", "-" 셋 중 하나면 된다.
     */
    getDate(str: string): Date;
    getDateNull(s: string): Date | null;
    getText(d: Date | number): string;
    daysOfYear(d: Date): number;
    daysOfPriorYears(y: number): number;
    toExcelDate(d: Date): number;
    private parseDateFormatTokens;
    private parseDateValueTokens;
    private validateDateFormat;
    private parse;
}

/**
 * @internal
 */
declare class GridBaseOptions extends Base {
    private _grid;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    protected _changed(): void;
    protected _invalidateOwner(): void;
    protected _layoutOwner(): void;
    protected _refreshOwner(): void;
    protected _invalidateEditor(): void;
}

/**
 * row block 마스크를 설정하기 위한 콜백
 *
 * @remarks
 *
 * {@link DisplayOptions.rowBlockCallback} 에서 사용된다.
 * {@link DisplayOptions.rowBlockType} 이 {@link RowMaskType.NONE} 이면 반영되지 않는다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 선택 된 행의 인덱스
 *
 * [반환값] - Row Block Mask 를 적용시킬 행의 범위, `start`: 시작 행, `end`: 끝 행
 *
 * @example
 * ```js
 * const f = function(grid, itemIndex) {
 *     let billNo;
 *     let ds = grid.getDataSource();
 *     let fld = ds.getFieldIndex("text1");
 *     let dataRow = grid.getDataRow(itemIndex);
 *     if (dataRow >= 0) {
 *         billNo = ds.getValue(dataRow, fld);
 *     } else {
 *         billNo = null;
 *     }
 *
 *     let top = Math.min(grid.getTopItem(), itemIndex);
 *     let full = top + grid.fullItemCount();
 *     let startNo = top + full;
 *     let endNo = -1;
 *     let check1 = false;
 *
 *     for (let i = top; i <= full; i++) {
 *         dataRow = grid.getDataRow(i);
 *         if (dataRow < 0) {
 *             continue;
 *         }
 *
 *         let cBillNo = ds.getValue(dataRow, fld);
 *
 *         if (cBillNo === billNo) {
 *             startNo = Math.min(startNo, i), endNo = Math.max(endNo, i);
 *             check1 = true;
 *         } else {
 *             if (check1) {
 *                 break;
 *             }
 *         }
 *     };
 *
 *     if (startNo <= endNo && endNo > 0) {
 *         console.log(startNo)
 *         console.log(endNo);
 *         return { start: startNo, end: endNo };
 *     }
 * }
 * ```
 */
declare type RowBlockCallback = (grid: GridBase$1, itemIndex: number) => {
    start: number;
    end: number;
};
/**
 * livescroll 을 미적용 할 때 스크롤 위치를 알려주는 화면에 표시되는 메시지를 반환하는 콜백 형식
 *
 * @remarks
 * {@link DisplayOptions.scrollMessageCallback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `isVertical` - 수직 스크롤 여부
 *
 * `itemIndex` - 스크롤 위치에 있는 아이템의 인덱스
 *
 * [반환값] - 화면에 표시되는 메시지의 텍스트
 *
 * @example
 * ```js
 * const f = function(grid, vertical, itemIndex) {
 *     let msg = grid.getValue(itemIndex, "area3name");
 *     return "<span style='color:blue;font-size:20px'>itemIndex = " + msg+"</span>";
 * }
 * ```
 */
declare type ScrollMessageCallback = (grid: GridBase$1, isVertical: boolean, itemIndex: number) => string;
/**
 *
 * 행의 높이를 반환하는 콜백형식
 *
 * @remarks
 * number 또는 number[]형태로 행의 높이를 지정한다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `type` - row의 {@link ItemType | type}
 *
 * `itemIndex` - row의 itemIndex
 *
 * [반환값] - 행의 높이, 여러줄로 이루어진 행의 경우 배열로 반환하면 각각 지정된다.
 */
declare type RowHeightCallback = (grid: GridBase$1, type: ItemType, itemIndex: number) => number | number[];
/**
 * @internal
 */
declare class DisplayOptions$1 extends GridBaseOptions implements DisplayOptions {
    /**
     * @internal
     */
    static readonly MIN_TABLE_ROW_HEIGHT = 20;
    private _refreshMode;
    private _columnResizable;
    private _columnMovable;
    private _minCellWidth;
    private _defaultColumnWidth;
    private _fitStyle;
    private _fitStyleIncludeFixed;
    private _rowResizable;
    private _eachRowResizable;
    private _autoClearHeights;
    private _rowHeight;
    private _refCalcHeights;
    private _dataHeights;
    private _minTableRowHeight;
    private _minRowHeight;
    private _maxRowHeight;
    private _hscrollBar;
    private _vscrollBar;
    private _liveScroll;
    private _scrollDuration;
    private _hscrollDuration;
    private _hintDelay;
    private _rowChangeDelay;
    private _horzPageScroll;
    private _emptyMessage;
    private _showEmptyMessage;
    private _focusVisible;
    private _focusType;
    private _rowFocusType;
    private _wheelEnabled;
    private _wheelScrollLines;
    private _wheelScrollHorz;
    private _wheelAccelDelay;
    private _wheelAccelScroll;
    private _wheelDeltaY;
    private _wheelEventPropagate;
    private _rightClickable;
    private _remergeWhenColumnMoved;
    private _editItemMerging;
    private _showInnerFocus;
    private _toastZIndex;
    private _popupDropdownCount;
    private _selectionMode;
    private _selectionStyle;
    private _selectionDisplay;
    private _spanSelecting;
    private _rowHoverType;
    private _rowBlockType;
    private _rowBlockCallback;
    private _showEmptyTooltip;
    private _showChangeMarker;
    private _scrollMessageCallback;
    private _showNativeEditButton;
    private _baseZindex;
    private _useAlternateRowStyle;
    private _useFocusClass;
    private _watchDisplayChange;
    private _syncGridHeight;
    private _rowHeightCallback;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /** 그리드를 다시 그릴 때의 모드 */
    get refreshMode(): RefreshMode;
    set refreshMode(value: RefreshMode);
    /** 컬럼 너비 변경 가능 여부 */
    get columnResizable(): boolean;
    set columnResizable(value: boolean);
    /** 컬럼 위치 변경 가능 여부 */
    get columnMovable(): boolean;
    set columnMovable(value: boolean);
    /** 컬럼 너비의 기본값 */
    get defaultColumnWidth(): number;
    set defaultColumnWidth(value: number);
    /** 그리드의 너비에 맞춰 컬럼 너비를 조정하는지에 대한 양식 */
    get fitStyle(): GridFitStyle;
    set fitStyle(value: GridFitStyle);
    /** fitStyle시 fixed영역도 포함할것인지 여부. */
    get fitStyleIncludeFixed(): boolean;
    set fitStyleIncludeFixed(value: boolean);
    /** 전체적인 행 높이 조절 가능 여부 */
    get rowResizable(): boolean;
    set rowResizable(value: boolean);
    /** 각 행 높이 조절 가능 여부 */
    get eachRowResizable(): boolean;
    set eachRowResizable(value: boolean);
    /**
     * rowHeight 속성이 변경될 때 개별 아이템마다 설정된 높이를 삭제할 지 여부.
     */
    get autoClearHeights(): boolean;
    set autoClearHeights(value: boolean);
    /**
     * rowHeight가 -1일때 행을 다시 그릴때 계산된 높이를 참조할것인가.
     */
    get refCalcHeights(): boolean;
    set refCalcHeights(value: boolean);
    /**
     * 행 높이
     * 0 이면 그리드의 폰트와 Padding 스타일을 고려해서 적절한 값으로 행들의 높이를 찾는다.
     * 0보다 큰 값이면 지정한 값이 행들의 높이가 된다.
     */
    get rowHeight(): number;
    set rowHeight(value: number);
    /**
     * DataRow tr의 높이
     *
     * 여러행으로 구성된 데이터 Row의 TR별 높이를 배열로 지정한다.
     * 실제 행보다 배열이 작으면 minRowHeight로 지정된다.
     * dataHeights가 설정되면 rowResizable, rowHeight는 무시된다.
     * rowHeight가 -1인경우 dataHeights는 무시된다.
     */
    get dataHeights(): number[];
    set dataHeights(value: number[]);
    /** Table 행 (TR) 최소 높이 */
    get minTableRowHeight(): number;
    set minTableRowHeight(value: number);
    /** 행 최소 높이 */
    get minRowHeight(): number;
    set minRowHeight(value: number);
    /**
     * 행 최대 높이
     */
    get maxRowHeight(): number;
    set maxRowHeight(value: number);
    /** 셀 최소 너비 */
    get minCellWidth(): number;
    set minCellWidth(value: number);
    /** 수평 스크롤 바 표시 여부 */
    get hscrollBar(): boolean;
    set hscrollBar(value: boolean);
    /** 수직 스크롤 바 표시 여부 */
    get vscrollBar(): boolean;
    set vscrollBar(value: boolean);
    /** 스크롤 중 수직 스크롤 바 표시 여부 */
    get liveScroll(): boolean;
    set liveScroll(value: boolean);
    /** 수직 스크롤 지연 시간 */
    get scrollDuration(): number;
    set scrollDuration(value: number);
    /** 수평 스크롤 지연 시간 */
    get hscrollDuration(): number;
    set hscrollDuration(value: number);
    /** 툴팁 지연 시간 */
    get hintDelay(): number;
    set hintDelay(value: number);
    /** 데이터 행 위치 변경의 지연 시간 */
    get rowChangeDelay(): number;
    set rowChangeDelay(value: number);
    /** 키보드를 이용해서 수평이동시 페이지 단위 스크롤
     * 페이지 단위로 이동하기 때문에 화면갱신 횟수가 줄어들고 속도가 빨라진것처럼 보이도록 한다.
    */
    get horzPageScroll(): boolean;
    set horzPageScroll(value: boolean);
    /** 그리드에 표시되는 데이터 행이 한 건도 없을 때 표시되는 메세지 */
    get emptyMessage(): string;
    set emptyMessage(value: string);
    /** 그리드에 표시되는 데이터 행이 한 건도 없을 때 메시지 표시 여부 */
    get showEmptyMessage(): boolean;
    set showEmptyMessage(value: boolean);
    /**
     * focus의 보임 여부
     *
     * @defaultValue true
     */
    get focusVisible(): boolean;
    set focusVisible(value: boolean);
    /** focusView의 표시형태 */
    get focusType(): FocusType;
    set focusType(value: FocusType);
    /** 행의 focus 종류 */
    get rowFocusType(): RowMaskType;
    set rowFocusType(value: RowMaskType);
    /** 휠 가능 여부 */
    get wheelEnabled(): boolean;
    set wheelEnabled(value: boolean);
    /** 한 번에 스크롤 되는 행 갯수 */
    get wheelScrollLines(): number;
    set wheelScrollLines(value: number);
    /** 휠로 수평 스크롤 했을 때 위치 이동 변동 값 (속도) */
    get wheelScrollHorz(): number;
    set wheelScrollHorz(value: number);
    /** 수직 스크롤 시 가속을 위한 최소 시간 */
    get wheelAccelDelay(): number;
    set wheelAccelDelay(value: number);
    /** {@link wheelAccelDelay} 만큼이 지연 되었을 경우, 해당 속성 만큼 스크롤을 가속한다.
     * 숫자: 아이템 개수
     * 문자열: 백분율 ex) 50%
     */
    get wheelAccelScroll(): number | string;
    set wheelAccelScroll(value: number | string);
    /** touchPad를 이용한 스크롤시 delay */
    get wheelDeltaY(): number;
    set wheelDeltaY(value: number);
    /** 그리드 내 발생한 휠 이벤트 외부 방출 여부 */
    get wheelEventPropagate(): boolean;
    set wheelEventPropagate(value: boolean);
    /** 마우스 오른쪽 버튼 사용 가능 여부 */
    get rightClickable(): boolean;
    set rightClickable(value: boolean);
    /**
     * 컬럼 위치가 변경됐을 때 병합을 다시 시도할 지 여부.
     */
    get remergeWhenColumnMoved(): boolean;
    set remergeWhenColumnMoved(value: boolean);
    /** Merged Row Grouping 또는 Cell Merging상태에서 셀 편집시 편집 중인 행의 분리 여부. */
    get editItemMerging(): boolean;
    set editItemMerging(value: boolean);
    /** Merged Cell에서 개별 셀 영역 표시 여부 */
    get showInnerFocus(): boolean;
    set showInnerFocus(value: boolean);
    /** 표시되는 Toast 창의 zIndex 지정 */
    get toastZIndex(): number;
    set toastZIndex(value: number);
    /** 팝업이나 컨텍스트 메뉴에 한 화면에 표시되는 목록들의 개수 */
    get popupDropdownCount(): number;
    set popupDropdownCount(value: number);
    /** 선택 영역의 모드 */
    get selectionMode(): SelectionMode;
    set selectionMode(value: SelectionMode);
    /** 선택 영역의 스타일 */
    get selectionStyle(): SelectionStyle;
    set selectionStyle(value: SelectionStyle);
    /** 선택 영역의 디스플레이 */
    get selectionDisplay(): SelectionDisplay;
    set selectionDisplay(value: SelectionDisplay);
    /** 사용자 선택 시 false이면 span 상태를 무시하고 셀 단위로 선택한다. */
    get spanSelecting(): boolean;
    set spanSelecting(value: boolean);
    /** hovering 시 행 선택 영역 표시를 보여준다. */
    get rowHoverType(): RowMaskType;
    set rowHoverType(value: RowMaskType);
    /** rowBlock 사용시 선택 영역 표시범위. */
    get rowBlockType(): RowMaskType;
    set rowBlockType(value: RowMaskType);
    /**
     * 사용자 지정 {@link DisplayOptions.rowBlockType | rowBlockType} 을 설정하기 위한 콜백
     *
     * @defaultValue null
     *
     */
    get rowBlockCallback(): RowBlockCallback;
    set rowBlockCallback(value: RowBlockCallback);
    /** 데이터와 무관하게 툴팁을 보여줄 건지에 대한 여부 */
    get showEmptyTooltip(): boolean;
    set showEmptyTooltip(value: boolean);
    /** 변경 마커를 보여줄지에 대한 여부 */
    get showChangeMarker(): boolean;
    set showChangeMarker(value: boolean);
    /**
     * liveScroll: `false` 일때 스크롤 위치를 알려주는 view에 표시되는 메세지를 return 하는 callback
     */
    get scrollMessageCallback(): ScrollMessageCallback;
    set scrollMessageCallback(value: ScrollMessageCallback);
    /**
     * Native 드랍다운 편집기(date, list)일 때 셀 우측에 edit button을 표시할 것인 지 여부.
     */
    get showNativeEditButton(): boolean;
    set showNativeEditButton(value: boolean);
    /**
     * editor / editorButton의 zIndex를 설정한다.
     * @defaultValue `2000`
     */
    get baseZindex(): number;
    set baseZindex(value: number);
    /**
     * 짝수행의 className에 "rg-alternate-row" 추가를 설정한다.
     */
    get useAlternateRowStyle(): boolean;
    set useAlternateRowStyle(value: boolean);
    /** useFocusClass */
    get useFocusClass(): boolean;
    set useFocusClass(value: boolean);
    /** editButton의 높이를 변경한다. */
    get editButtonHeight(): number;
    set editButtonHeight(value: number);
    /** container의 display가 변경되는 경우 자동으로 화면을 갱신 */
    get watchDisplayChange(): boolean;
    set watchDisplayChange(value: boolean);
    /** container의 높이를 높여서 data가 모두 보이도록 한다. */
    get syncGridHeight(): SyncGridHeight;
    set syncGridHeight(value: SyncGridHeight);
    /** 개별행의 높이를 가져오는 callback */
    get rowHeightCallback(): RowHeightCallback;
    set rowHeightCallback(value: RowHeightCallback);
}

/**
 * @internal
 * Toast View 표시 여부와 메시지를 지정할 수 있는 설정 모델
 *
 * @remarks
 * 대량 데이터셋의 정렬/필터링/그룹핑시 화면이 멈춰있는 상태일 때 진행 중임을 알려줄 수 있다.
 */
declare class ToastOptions$1 extends Base implements ToastOptions {
    private _message;
    private _visible;
    private _zIndex;
    private _styleName;
    constructor(source?: any);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 토스트에 표시할 메시지
     *
     * @defaultValue sorting/filtering/grouping 에 따라 다름
     */
    get message(): string;
    set message(value: string);
    /**
     * 표시 여부
     */
    get visible(): boolean;
    set visible(value: boolean);
    /**
     * 토스트 창의 zIndex
     *
     * @defaultValue `3000`
     */
    get zIndex(): number;
    set zIndex(value: number);
    /**
     * 토스트 창의 스타일 클래스명
     *
     * @defaultValue `'rg-toast'`
     */
    get styleName(): string;
    set styleName(value: string);
    /**
     * @internal
     */
    assignFrom(source: any): void;
}
/** @internal */
declare class ToastManager extends Base {
    private _container;
    private _toast;
    private _active;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** visible */
    get visible(): boolean;
    show(options: any, force: boolean, action: () => void): void;
    close(): void;
}

/**
 * 사용자 지정 자동필터링 생성 시 카데고리 분류 모델
 *
 * @remarks
 * {@link CategoryCallback} 에서 반환되어야 하는 모델의 형태이다.
 *
 * 실제 {@link FilterAutomatingOptions} 의 category callback 들을 설정할 때 사용된다.
 *
 * @example
 *
 * ```js
 * // Date 일 경우
 * [
 *     {
 *         text: "2019년도",
 *         childs: [
 *             {
 *                 text: "2사분기",
 *                 childs: [
 *                     {
 *                         text: "6월",
 *                         childs: [
 *                             {text: "2019-06-11", year: 2019, month: 5, day: 11},
 *                             {text: "2019-06-12", year: 2019, month: 5, day: 12},
 *                             {text: "2019-06-18", year: 2019, month: 5, day: 18},
 *                             {text: "2019-06-27", year: 2019, month: 5, day: 27},
 *                             {text: "2019-06-30", year: 2019, month: 5, day: 30}
 *                         ],
 *                         year: 2019,
 *                         quarter: 1,
 *                         month: 5
 *                     }
 *                 ],
 *                 year: 2019,
 *                 quarter: 1
 *             },
 *             {
 *                 text: "3사분기",
 *                 childs: [
 *                     {
 *                         text: "7월",
 *                         childs: [
 *                             {text: "2019-07-03", year: 2019, month: 6, day: 3},
 *                             {text: "2019-07-07", year: 2019, month: 6, day: 7},
 *                             {text: "2019-07-17", year: 2019, month: 6, day: 17},
 *                             {text: "2019-07-21", year: 2019, month: 6, day: 21}
 *                         ],
 *                         year: 2019,
 *                         quarter: 1,
 *                         month: 6
 *                     },
 *                     {
 *                         text: "8월",
 *                         ...
 *                     }
 *                 ],
 *                 year: 2019,
 *                 quarter: 2
 *             },
 *             {
 *                 text: "4사분기",
 *                 childs: [
 *                     {
 *                         text: "10월",
 *                         childs: [
 *                             ...
 *                         ],
 *                         year: 2019,
 *                         quarter: 3,
 *                         month: 9
 *                 }
 *                 ],
 *                 year: 2019,
 *                 quarter: 3
 *             },
 *         ],
 *         year: 2019,
 *     },
 *     {
 *         text: '2020년도',
 *         ...
 *     }
 * ]
 *
 * [
 *     {text: "2019-06-11", year: 2019, month: 5, day: 11}
 *     {text: "2019-06-12", year: 2019, month: 5, day: 12}
 *     {text: "2019-06-18", year: 2019, month: 5, day: 18},
 *         ...
 *     {text: "2021-12-27", year: 2021, month: 12, day: 27}
 * ]
 *
 * // Text 일 경우
 *
 * [
 *     {text: "A ~ C", values: [
 *         "Adrian", "Adrienne", "Aladdin", "Alden", "Alea", "Alexa", "Amber",
 *         "Amy", "Arsenio", "Beatrice", "Benedict", "Benjamin", "Blaze", "Brennan",
 *     ]},
 *     {text: "D ~ F", values: [...]},
 *     {text: "G ~ I", values: [...]},
 *     {text: "J ~ L", values: [...]}
 * ]
 *
 * [
 *     {text: "Adrian", value: "Adrian"},
 *     {text: "Adrienne", value: "Adrienne"},
 *     {text: "Aladdin", value: "Aladdin"},
 *     {text: "Alden", value: "Alden"},
 *     {text: "Alea", value: "Alea"}
 * ]
 *
 * // Number 일 경우
 * [
 *     {text: "0 ~ 25", values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]},
 *     {text: "25 ~ 50", values: [...]},
 *     {text: "50 ~ 75", values: [...]},
 *     {text: "75 ~ 100", values: [...]}
 * ]
 *
 * [
 *     {text: "0 ~ 1", values: [0]},
 *     {text: "1 ~ 2", values: [1]},
 *     {text: "2 ~ 3", values: [2]},
 *     {text: "3 ~ 4", values: [3]},
 *     {text: "4 ~ 5", values: [4]},
 *     {text: "5 ~ 6", values: [5]},
 *     {text: "6 ~ 7", values: [6]},
 *         ...
 *     {text: "99 ~ 100", values: [99]}
 * ]
 * ```
 */
interface FilterCategory {
    /**
     * 필터 선택 상자의 아이템들에 표시되는 텍스트
     */
    text: string;
    /**
     * 하위 그룹의 아이템
     */
    childs?: FilterCategory[];
    /**
     * 빈 값의 아이템인지의 여부
     */
    empty?: boolean;
    /**
     * 값
     *
     * @remarks
     * {@link FilterAutomatingOptions.textCategoryCallback} 을 설정할 때 사용된다.
     */
    value?: any;
    /**
     * 값들
     *
     * @remarks
     * {@link FilterAutomatingOptions.textCategoryCallback}, 또는 {@link FilterAutomatingOptions.numberCategoryCallback} 을 설정할 때 사용된다.
     */
    values: any[];
    /**
     * 연도 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     */
    year?: number;
    /**
     * 분기 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     *
     * `0`부터 `3`까지 각각 1, 2, 3, 4분기를 의미한다.
     */
    quarter?: number;
    /**
     * 월 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     *
     * `0`부터 `11`까지 각각 1, 2, ..., 12월를 의미한다.
     */
    month?: number;
    /**
     * 일 정보
     *
     * @remarks
     * {@link FilterAutomatingOptions.dateCategoryCallback} 을 설정할 때 사용된다.
     */
    day?: number;
}
/**
 * 컬럼 필터링에 관련된 설정 정보
 *
 * @remarks
 * {@link GridBase.onFilteringChanged} 나 {@link GridBase.getColumnFilter} 같은 필터 관련 메소드에서 사용된다.
 *
 * {@link GridBase.setColumnFilters} 같이 설정을 위한 형식일 때에는, 원하는 정보만 넣으면 된다.
 */
interface ColumnFilter$1 {
    /**
     * 이름
     */
    name: string;
    /**
     * 표현식
     */
    criteria: string;
    /**
     * 필터를 결정하는 콜백
     *
     * @remarks
     * `true`: 필터링 대상일 때, `false`: 필터링 제외 대상일 때
     * @eventProperty
     */
    callback?: FilterCallback;
    /**
     * 필터 선택 상자에 표시되는 문자열
     *
     * @remarks
     * `null`이면 `name`이 표시된다.
     */
    text?: string;
    /**
     * 설명
     */
    description?: string;
    /**
     * 필터활성화 여부
     */
    active?: boolean;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 태그
     */
    tag?: string;
}

/**
 * 컬럼 필터링과 관련된 설정 모델
 *
 * @internal
 */
declare class FilteringOptions$1 extends GridBaseOptions implements FilteringOptions {
    private _enabled;
    private _handleVisibility;
    private _commitBeforeFiltering;
    private _selector;
    private _automating;
    private _toast;
    private _includeParentItem;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 필터 핸들이나 Indicator Head를 클릭으로 필터 상자 표시 가능 여부
     *
     * @defaultValue `true`
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    get handleVisibility(): HandleVisibility;
    set handleVisibility(value: HandleVisibility);
    /**
     * 필터링 전에 commit 할 건지의 여부
     *
     * @defaultValue `true`
     */
    get commitBeforeFiltering(): boolean;
    set commitBeforeFiltering(value: boolean);
    /**
     * TreeView 에서 검색된 데이터 행의 부모 행도 표시할지의 여부
     *
     * @defaultValue `true`
     */
    get includeParentItem(): boolean;
    set includeParentItem(value: boolean);
    /**
     * 필터 선택 상자에 대한 설정 모델
     */
    get selector(): FilterSelectorOptions$1;
    /**
     * 자동 필터링에 대한 설정 모델
     */
    get automating(): FilterAutomatingOptions$1;
    /**
     * toast 관련 설정
     *
     * @defaultValue `{visible: false, message: "Filtering..."}`
     */
    get toast(): ToastOptions$1;
    /**
     * @internal
     */
    assignFrom(source: ConfigObject): void;
}
/**
 * 사용자가 검색창에 입력한 내용을 필터로 만들기 위한 콜백
 */
declare type UserFilterAddCallback = (grid: GridBase$1, column: GridColumn, text: string) => any;
/**
 * @internal
 */
declare class FilterSelectorOptions$1 extends GridBaseOptions implements FilterSelectorOptions {
    private _listHeight;
    private _showButtons;
    private _partialSearch;
    private _excludeCheck;
    private _filterReset;
    private _filtersResetText;
    private _acceptText;
    private _cancelText;
    private _allCheckText;
    private _searchedCheckText;
    private _showEmptyFilter;
    private _emptyFilterText;
    private _searchPlaceholder;
    private _closeWhenClick;
    private _maxWidth;
    private _width;
    private _minWidth;
    private _textToTitle;
    private _searchIgnoreCase;
    private _style;
    private _userFilterAddCallback;
    constructor(grid: GridBase$1);
    /**
     * 컬럼 필터 목록의 높이
     *
     * @defaultValue `100`
     */
    get listHeight(): number;
    set listHeight(value: number);
    /**
     * 컬럼 필터의 선택 상자의 푸터 버튼 표시 여부
     *
     * @defaultValue `false`
     */
    get showButtons(): boolean;
    set showButtons(value: boolean);
    /**
     * 필터 검색 상자 표시 여부
     *
     * @defaultValue `true`
     */
    get partialSearch(): boolean;
    set partialSearch(value: boolean);
    /**
     * 필터의 선택 상자의 확인 버튼의 문구
     *
     * @defaultValue `'확인'`
     */
    get acceptText(): string;
    set acceptText(value: string);
    /**
     * 필터의 선택 상자의 취소 버튼의 문구
     *
     * @defaultValue `'취소'`
     */
    get cancelText(): string;
    set cancelText(value: string);
    /**
     * 전체 선택 탭의 문구
     *
     * @defaultValue `'(전체선택)'`
     */
    get allCheckText(): string;
    set allCheckText(value: string);
    /**
     * 자동 필터 생성 시 값 없음 필터 생성 여부
     *
     * @defaultValue `true`
     */
    get showEmptyFilter(): boolean;
    set showEmptyFilter(value: boolean);
    /**
     * 자동 필터 생성 시 값 없음 필터 탭의 문구
     *
     * @defaultValue `'(값 없음)'`
     */
    get emptyFilterText(): string;
    set emptyFilterText(value: string);
    /**
     * 검색 박스의 placeholder
     *
     * @defaultValue `'검색...'`
     */
    get searchPlaceholder(): string;
    set searchPlaceholder(value: string);
    /**
     * 검색 이후 적용하고자 하는 탭을 클릭하여 필터를 적용할 때, 검색 범위에 없는 필터들을 비활성화 할지의 여부
     *
     * @alpha
     * @defaultValue `true`
     */
    get excludeCheck(): boolean;
    set excludeCheck(value: boolean);
    /**
     * 검색 후 전체 선택 대신에 보여지는 문구
     *
     * @defaultValue `'(조회 전체 선택)'`
     */
    get searchedCheckText(): string;
    set searchedCheckText(value: string);
    /**
     * 필터 검색창에 입력한 내용을 토대로 사용자 지정 필터를 등록하기 위한 콜백
     * @alpha
     *
     * @remarks
     * Ctrl + Enter 로 등록 요청한다.
     */
    get userFilterAddCallback(): UserFilterAddCallback;
    set userFilterAddCallback(value: UserFilterAddCallback);
    /**
     * 스타일 클래스 명
     */
    get style(): string;
    set style(value: string);
    /**
     * 필터를 활성화 하였을 때 창 닫힘 여부
     *
     * @remarks
     * {@link FilterSelectorOptions.showButtons | showButtons} 가 `false` 일 경우, 필터를 선택 하였을 때 창이 닫힌다.
     * {@link FilterSelectorOptions.showButtons | showButtons} 에 `true`로 설정하여 확인 / 취소 버튼이 생겼을 경우에는 확인 / 취소 버튼 동작 시 창이 닫힌다.
     *
     */
    get closeWhenClick(): boolean;
    set closeWhenClick(value: boolean);
    /**
     * 필터 초기화 버튼 유무
     */
    get filterReset(): boolean;
    set filterReset(value: boolean);
    /**
     * 필터 초기화 텍스트
     */
    get filtersResetText(): string;
    set filtersResetText(value: string);
    /**
     * 필터 최대 너비
     */
    get maxWidth(): number;
    set maxWidth(value: number);
    /**
     * 필터 너비
     *
     * @remarks
     * 0 인경우 style 파일에 지정된 너비 적용
     * -1 인 경우 filter Text너비를 계산해서 적용
     * 0 이상인 경우 지정된 너비 적용.
     *
     * @defaultValue `0`
     */
    get width(): number;
    set width(value: number);
    /**
     * 필터 선택창의 최소너비.
     * width가 0인경우 적용되지 않는다.
     *
     */
    get minWidth(): number;
    set minWidth(value: number);
    /** textToTitle */
    get textToTitle(): boolean;
    set textToTitle(value: boolean);
    /** searchIgnoreCase */
    get searchIgnoreCase(): boolean;
    set searchIgnoreCase(value: boolean);
}
/**
 * 자동 필터링 시 사용자 지정 분류를 위한 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `column` - 자동 필터링이 걸려있는 컬럼
 *
 * `values` - 전체 값들
 *
 * [반환값] - 카데고리 분류 모델의 배열 형태
 *
 * @example
 *
 * ```js
 * const f = function(column, values) {
 *      const emptyText = '빈 아이템'
 *      if (!values) {
 *          return null;
 *      }
 *      const valids = values.filter(function (el) { return el != undefined && el != null; });
 *      const min = Math.min.apply(null, valids);
 *      const vlen = values.length;
 *      let unit;
 *      if (vlen > 15) {
 *          const groupCount = Math.min(Math.round(vlen / 5)), 10);
 *          unit = Math.round(vlen / groupCount);
 *      } else {
 *          unit = 1;
 *      }
 *      let categories = [];
 *      let gvals = [];
 *      let gindex = 0;
 *      let gmin = min;
 *      let isEmpty = false;
 *      for (let i = 0; i < vlen; i++) {
 *          const v = values[i];
 *          if (v === undefined || v === null) {
 *              isEmpty = true;
 *              continue;
 *          }
 *          if (i == gindex + unit || i === vlen - 1) {
 *              categories.push({ text: gmin + ' ~ ' + v, values: gvals });
 *              gvals = [v];
 *              gindex = i;
 *              gmin = v;
 *          } else {
 *              gvals.push(v);
 *          }
 *      }
 *      if (isEmpty) {
 *          categories.push({ text: emptyText, empty: true });
 *      }
 *      return categories;
 * }
 * ```
 *
 */
declare type CategoryCallback = (column: DataColumn, values: any[]) => FilterCategory[];
/**
 * 자동 필터링에 관한 옵션
 *
 * @internal
 */
declare class FilterAutomatingOptions$1 extends GridBaseOptions implements FilterAutomatingOptions {
    private _dateCategorize;
    private _numberCategorize;
    private _textCategorize;
    private _dateCategoryCallback;
    private _numberCategoryCallback;
    private _textCategoryCallback;
    private _dateYearFormat;
    private _dateQuarterFormat;
    private _dateMonthFormat;
    private _dateDayFormat;
    private _lookupDisplay;
    private _filteredDataOnly;
    constructor(grid: GridBase$1);
    /**
     * 날짜를 분류할 것인지의 여부
     * @defaultValue `true`
     */
    get dateCategorize(): boolean;
    set dateCategorize(value: boolean);
    /**
     * 수를 분류할 것인지의 여부
     * @defaultValue `true`
     */
    get numberCategorize(): boolean;
    set numberCategorize(value: boolean);
    /**
     * 텍스트를 분류할 것인지의 여부
     * @defaultValue `false`
     */
    get textCategorize(): boolean;
    set textCategorize(value: boolean);
    /**
     * 날짜를 분류하기 위한 콜백
     */
    get dateCategoryCallback(): CategoryCallback;
    set dateCategoryCallback(value: CategoryCallback);
    /**
     * 수를 분류하기 위한 콜백
     */
    get numberCategoryCallback(): CategoryCallback;
    set numberCategoryCallback(value: CategoryCallback);
    /**
     * 문자열을 분류하기 위한 콜백
     */
    get textCategoryCallback(): CategoryCallback;
    set textCategoryCallback(value: CategoryCallback);
    /**
     * 탭에 표시되는 날짜 형식
     *
     * @defaultValue `'YYYY년도'`
     */
    get dateYearFormat(): string;
    set dateYearFormat(value: string);
    /**
     * 탭에 표시되는 분기 형식
     *
     * @defaultValue `'Q분기'`
     */
    get dateQuarterFormat(): string;
    set dateQuarterFormat(value: string);
    /**
     * 탭에 표시되는 월 형식
     *
     * @defaultValue `'M월'`
     */
    get dateMonthFormat(): string;
    set dateMonthFormat(value: string);
    /**
     * 탭에 표시되는 일 형식
     *
     * @defaultValue `'YYYY-MM-DD'`
     */
    get dateDayFormat(): string;
    set dateDayFormat(value: string);
    /**
     * Column의 lookupDisplay가 true일때 value대신 label을 표시한다.
     *
     * @remarks
     * Data가 많은 경우 속도가 느려질수 있다.
     *
     * @defaultValue `false`
     */
    get lookupDisplay(): boolean;
    set lookupDisplay(value: boolean);
    /**
     * filterSelector에 filtering된 data만 보여질것인지 여부.
     */
    get filteredDataOnly(): boolean;
    set filteredDataOnly(value: boolean);
}

/**
 * 데이터 drop 시 모드
 */
declare enum DataDropMode {
    /**
     * 복사
     */
    COPY = "copy",
    /**
     * 이동
     */
    MOVE = "move"
}
/**
 * 그리드 간 drag and drop 을 시작할 때 발생하는 콜백 형식
 *
 * @remarks
 * `false` 반환 시 drag and drop 이 취소된다.
 * {@link DataDropOptions.dragCallback} 에서 쓰인다.
 *
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * [반환값] - drag and drop 가능 여부
 *
 * @example
 * ```js
 * gridView.dataDropOptions.dragCallback = function (source, sourceItems, target, targetItem) {
 *     return targetItem % 2 == 0;
 * }
 * ```
 */
declare type DataDragCallback = (source: GridBase$1, sourceItems: number[], target: GridBase$1, targetItem: number) => boolean;
/**
 * 그리드 간 drag and drop 했을 때 발생하는 콜백 형식
 *
 * @remarks
 * {@link DataDropOptions.callback} 에서 사용 된다.
 *
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * @example
 * ```js
 * gridView.dataDropOptions.callback = function (source, sourceItems, target, targetItem) {
 *     alert('row from ' + sourceItems + ' to ' + targetItem);
 *     for (var i = 0; i < sourceItems.length; i++) {
 *         var r = source.getDataRow(sourceItems[0]);
 *         var ds = source.getDataSource();
 *         var row = ds.getJsonRow(r)
 *         if (targetItem >= target.getItemCount()) {
 *             ds.addRow(row);
 *         } else {
 *             r = target.getDataRow(targetItem);
 *             target.getDataSource().insertRow(r, row);
 *         }
 *     }
 * }
 * ```
 */
declare type DataDropCallback = (source: GridBase$1, sourceItems: number[], target: GridBase$1, targetItem: number) => void;
/**
 * 그리드 간 drag and drop 으로 이동 / 복사를 할 때 적용되는 규칙을 반환하는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * [반환값] - {@link FieldMap} 오브젝트
 *
 * @example
 * ```js
 * gridView.dataDropOptions.fieldMapCallback = function (source, sourceItems, target, targetItem) {
 *     if (targetItem % 2 == 0) {
 *         return {
 *             Country: "Country",
 *             CompanyName: "ShipAddress",
 *             EmployeeID: "ShipPostalCode"
 *         }
 *     }
 * }
 * ```
 */
declare type DropFieldMapCallback = (source: GridBase$1, sourceItems: number[], target: GridBase$1, targetItem: number) => FieldMap;
/**
 * drag 중인 item 의 label 텍스트를 결정하기 위한 콜백의 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `source` - 드래그한 아이템이 있던 GridBase 컨트롤
 *
 * `sourceItems` - 드래그한 그리드의 아이템들의 인덱스
 *
 * `target` - 드랍할 GridBase 컨트롤
 *
 * `targetItem` - 드랍할 그리드에서의 아이템 인덱스
 *
 * [반환값] - 레이블의 텍스트
 *
 * @example
 * ```js
 * gridView.dataDropOptions.labelCallback = function (source, sourceItems, target, targetItem) {
 *     return sourceItems.length + " 개의 행";
 * }
 * ```
 */
declare type DataDragLabelCallback = (source: GridBase$1, sourceItems: number[], target: GridBase$1, targetItem: number) => string;
/**
 * {@link DataDropOptions.fieldMap} 에서 사용되는 옮길 그리드의 필드명 - 옮김을 받은 그리드의 필드명 쌍 형식
 *
 * @remarks
 * `'*':'*'` 로 필드명이 동일한 필드끼리 매핑할 수 있다.
 *
 * @example
 * ```js
 * {
 *      'CompanyName': 'ShipAddress',
 *      '*': '*'
 * }
 * ```
 */
interface FieldMap {
    [fieldName: string]: string;
}
/**
 * 다른 그리드에서 drag 된 data를 처리하는 방식에 대한 설정들.
 * callback이 지정된 않은 경우,
 * fieldMap이나 fieldMapCallback을 지정하지 않으면 field명이 같은 필드들의 값을
 * dropMode에 따라 이동/복사한다.
 *
 * @internal
 */
declare class DataDropOptions$1 extends GridBaseOptions implements DataDropOptions {
    private _dragCallback;
    private _callback;
    private _dropMode;
    private _fieldMap;
    private _fieldMapCallback;
    private _proxyLabel;
    private _labelCallback;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * drag 시작할 때 발생하는 콜백
     */
    get dragCallback(): DataDragCallback;
    set dragCallback(value: DataDragCallback);
    /**
     * drop 했을 때 발생하는 콜백
     */
    get callback(): DataDropCallback;
    set callback(value: DataDropCallback);
    /**
     * drop 모드
     */
    get dropMode(): DataDropMode;
    set dropMode(value: DataDropMode);
    /** 필드명 - 필드명 쌍 */
    get fieldMap(): FieldMap;
    set fieldMap(value: FieldMap);
    /** 필드명 - 필드명 쌍을 반환하는 콜백 */
    get fieldMapCallback(): DropFieldMapCallback;
    set fieldMapCallback(value: DropFieldMapCallback);
    /** proxyLabel */
    get proxyLabel(): string;
    set proxyLabel(value: string);
    /** labelCallback */
    get labelCallback(): DataDragLabelCallback;
    set labelCallback(value: DataDragLabelCallback);
    getEnabled(grid: GridBase$1, sourceItems: number[], targetItem: number): boolean;
    getLabel(grid: GridBase$1, sourceItems: number[], targetItem: number): string;
}

/** @internal */
declare class GridObject extends EventAware {
    protected _grid: GridBase$1;
    private _dirty;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** owner  */
    get owner(): GridBase$1;
    /** dirty */
    get dirty(): boolean;
    clean(): void;
    invalidate(): void;
    refreshOwner(): void;
    protected _changed(): void;
    protected _doChanged(): void;
}
/** @internal */
declare abstract class VisualObject extends GridObject {
    private _visible;
    constructor(grid: GridBase$1);
    /** @internal */
    protected _doDispose(): void;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** @internal */
    protected _doChanged(): void;
    /** @internal */
    protected _visibleChanged(): void;
}

/**@internal */
declare abstract class EditCommand extends Base {
    constructor();
    protected _doDispose(): void;
    undo(): void;
    redo(redoing: boolean): any;
    execute(): any;
}
/**@internal */
interface EditCommandStackOwner {
    editCommandStackChanged(stack: EditCommandStack, undoable: boolean, redoable: boolean): void;
}
/**@internal */
declare class EditCommandStack extends EventAware {
    private _owner;
    private _commands;
    private _current;
    private _undoing;
    private _redoing;
    constructor(owner: EditCommandStackOwner);
    protected _doDispose(): void;
    /** owner */
    get owner(): EditCommandStackOwner;
    /** length */
    get length(): number;
    /** canUndo */
    get canUndo(): boolean;
    /** canRedo */
    get canRedo(): boolean;
    /** undoing */
    get undoing(): boolean;
    /** redoing */
    get redoing(): boolean;
    undo(): void;
    redo(redoing?: boolean): any;
    execute(command: EditCommand): any;
    flush(): void;
    protected _changed(): void;
    private $_shrink;
}

/**@internal */
declare class DummyEditItem extends GridRow {
    private _target;
    private _state;
    private _started;
    private _checkDiff;
    private _strictDiff;
    constructor(rs: ItemProvider, target: GridItem, index: number, dataRow: number, state: ItemState);
    /** values */
    get values(): any[];
    set values(value: any[]);
    beginEdit(checkDiff: boolean, strictDiff: boolean): void;
    setValue(field: number, value: any): void;
    get resizable(): boolean;
    get itemState(): ItemState;
    get editable(): boolean;
    getData(field: number): any;
    setData(field: number, value: any): void;
    getRowData(): RowValues;
    getRowObject(): RowObject;
    _clearDisplayLevels(): void;
}
/**@internal */
declare class EditItem extends GridRow {
    private _target;
    private _state;
    private _values;
    private _changeValues;
    private _started;
    private _checkDiff;
    private _strictDiff;
    private _invalidFields;
    private _index2;
    constructor(rs: ItemProvider, target: GridItem, index: number, dataRow: number, state: ItemState);
    /** values */
    get values(): RowValues | RowObject;
    set values(vals: RowValues | RowObject);
    get invalidFields(): number[];
    beginEdit(checkDiff: boolean, strictDiff: boolean): void;
    setValue(field: number, value: any): void;
    get resizable(): boolean;
    get itemState(): ItemState;
    get level(): number;
    getData(field: number): any;
    setData(field: number, value: any): void;
    getRowData(): RowValues;
    getRowObject(): RowObject;
    isEdited(field: number): boolean;
    protected _setChecked(checked: boolean): void;
    _clearDisplayLevels(): void;
}
/**@internal */
declare abstract class EditableItemProvider extends ProxyItemProvider implements DataSourceClient {
    private static readonly UPDATE_STARTED;
    private static readonly APPEND_STARTED;
    private static readonly INSERT_STARTED;
    private static readonly CELL_EDITED;
    private static readonly CELL_UPDATED;
    private static readonly COMMITTING;
    private static readonly COMMITTED;
    private static readonly CANCELED;
    private static readonly COMMIT_REQUEST;
    private static readonly CANCEL_REQUEST;
    private _checkDiff;
    private _checkCellDiff;
    private _strictDiff;
    private _undoable;
    private _cancelWhenLastUndo;
    private _orgItem;
    private _editingItem;
    private _dummyEditItem;
    private _editingState;
    private _insertMode;
    private _modified;
    private _commiting;
    private _saveDs;
    private _commands;
    constructor(source: ItemProvider, indexing: boolean);
    protected _doDispose(): void;
    isDataEditing(): boolean;
    cancelDataEditing(): void;
    commitDataEditing(): void;
    editCommandStackChanged(stack: EditCommandStack, undoable: boolean, redoable: boolean): void;
    /** checkDiff */
    get isCheckDiff(): boolean;
    set isCheckDiff(value: boolean);
    /** checkCellDiff */
    get isCheckCellDiff(): boolean;
    set isCheckCellDiff(value: boolean);
    /** strictDiff */
    get isStrictDiff(): boolean;
    set isStrictDiff(value: boolean);
    /** editingItem */
    get editingItem(): GridItem;
    /** updating */
    get isUpdating(): boolean;
    /** inserting */
    get isInserting(): boolean;
    /** appending */
    get isAppending(): boolean;
    /** undoable */
    get undoable(): boolean;
    set undoable(value: boolean);
    /** cancelWhenLastUndo */
    get cancelWhenLastUndo(): boolean;
    set cancelWhenLastUndo(value: boolean);
    /** canUndo */
    get canUndo(): boolean;
    /** canRedo */
    get canRedo(): boolean;
    /** undoing */
    get undoing(): boolean;
    /** redoing */
    get redoing(): boolean;
    isEditing(item?: GridItem): boolean;
    isEdited(item: GridItem): boolean;
    setDiffs(check: boolean, cell: boolean, strict: boolean): void;
    edit(item: GridItem): boolean;
    editData(item: GridItem, field: number, value: any): boolean;
    appendDummy(): void;
    append(defaultValues: any[]): boolean;
    insert(item: GridItem, defaultValues: any[], shift: boolean, ctrl: boolean): boolean;
    cancelDummy(): void;
    cancel(): void;
    commit(mergeEdit: boolean): boolean;
    execute(command: EditCommand): any;
    undo(): void;
    redo(): void;
    clearCommandStack(all?: boolean): void;
    abstract remove(item: GridItem): void;
    abstract getRemovableRows(items: number[]): number[];
    abstract removeRows(rows: number[]): void;
    abstract updateRows2(rows: {
        [dataRow: number]: DataValues;
    }): any;
    revert(item: any): void;
    revertAll(items: any[]): void;
    protected _checkEditing(): void;
    protected _checkNotEditing(): void;
    protected _beginUpdate(item: GridItem): void;
    protected _doBeginUpdate(item: GridItem): GridItem;
    private _beginAppendDummy;
    protected _doBeginAppendDummy(): DummyEditItem;
    private _beginAppend;
    protected _doBeginAppend(defaultValues: RowValues): GridItem;
    private _beginInsert;
    protected _doBeginInsert(item: GridItem, defaultValues: RowValues, shift?: boolean, ctrl?: boolean): GridItem;
    protected _updateEditingRow(orgItem: GridItem): boolean;
    protected _insertEditingRow(appending: boolean): boolean;
    private _cancelDummyEdit;
    private _cancelEdit;
    protected _doCancelDummyEdit(): void;
    protected _doCancelEdit(state: ItemState, orgItem: GridItem): void;
    private _commitEdit;
    protected _doCommitEdit(state: ItemState, orgItem: GridItem): boolean;
    protected abstract _doCompleteUpdate(orgItem: GridItem, mergeEdit: boolean): boolean;
    protected abstract _doCompleteInsert(appending: boolean): boolean;
    protected _editItemCellEdited(item: GridItem, field: number): void;
    protected _editItemCellUpdated(item: GridItem, field: number, oldValue: any, newValue: any): void;
    protected $_editingItem(): GridItem;
    protected $_dummyItem(): DummyEditItem;
    fireUpdateStarted(item: GridItem): void;
    fireAppendStarted(item: GridItem): void;
    fireInsertStarted(item: GridItem): void;
    fireItemCellEdited(item: GridItem, field: number): void;
    fireItemCellUpdated(item: GridItem, field: number, oldValue: any, newValue: any): void;
    fireItemCommitting(item: GridItem): void;
    fireCommitted(item: GridItem): void;
    fireCanceled(): void;
    fireCommitRequest(): void;
    fireCancelRequest(): void;
    onItemProviderReset(rs: ItemProvider): void;
    onItemProviderRefresh(rs: ItemProvider): void;
    onItemProviderRefreshClient(rs: ItemProvider): void;
    onItemProviderItemInserted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemDeleted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemUpdated(rs: ItemProvider, item: GridItem): void;
    onItemProviderCommandStackChanged(rs: ItemProvider, undoable: boolean, redoable: boolean): void;
}
/**@internal */
declare abstract class EditableItemProviderImpl extends EditableItemProvider {
    private _insertRow;
    constructor(source: ItemProvider, indexing: boolean);
    protected _doDispose(): void;
    get itemCount(): number;
    getItem(index: number, dataOnly?: boolean): GridItem;
    getItems(index: number, count: number): GridItem[];
    protected _doBeginUpdate(item: GridItem): EditItem;
    protected _doBeginAppendDummy(): DummyEditItem;
    protected _doBeginAppend(defaultValues: RowValues): EditItem;
    protected _doBeginInsert(item: GridItem, defaultValues: RowValues, shift: boolean, ctrl: boolean): EditItem;
    protected _doCompleteUpdate(orgItem: GridItem, mergeEdit: boolean): boolean;
    protected _doCompleteInsert(appending: boolean): boolean;
    remove(item: GridItem): void;
    revert(item: number | GridItem): void;
    revertAll(items: number[]): void;
    getRemovableRows(items: number[]): number[];
    removeRows(rows: number[]): void;
    updateRows2(rows: {
        [dataRow: number]: DataValues;
    }): void;
    private _createDummyEditItem;
    private _createEditItem;
}

interface GridSummarizer {
    getCount(field: number): number;
    getSum(field: number): number;
    getMax(field: number): number;
    getMin(field: number): number;
    getAvg(field: number): number;
    getVar(field: number): number;
    getVarp(field: number): number;
    getStdev(field: number): number;
    getStdevp(field: number): number;
    getDataAvg(field: number): number;
    getDataCount(field: number): number;
}

/** @internal */
declare class GridItemProvider extends EditableItemProviderImpl {
    private _groupSorting;
    private _groupSortDirection;
    private _groupSortCase;
    private _rs;
    private _groupedProvider;
    private _summarizer;
    constructor(indexing: boolean, footerCounter?: GroupFooterCounter);
    _doDispose(): void;
    /** maxRowCount */
    get maxRowCount(): number;
    set maxRowCount(value: number);
    /** hideDeleted */
    get hideDeleted(): boolean;
    set hideDeleted(value: boolean);
    /** inclusiveFiltering */
    get inclusiveFiltering(): boolean;
    set inclusiveFiltering(value: boolean);
    /** summaryMode */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /** groupSummaryMode */
    get groupSummaryMode(): SummaryMode;
    set groupSummaryMode(value: SummaryMode);
    /** sortMode */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    /** filterMode */
    get filterMode(): FilterMode;
    set filterMode(value: FilterMode);
    /** grouped */
    get grouped(): boolean;
    /** mergedGrouped */
    get mergedGrouped(): boolean;
    /** groupList */
    /** groupLevels */
    get groupLevels(): number;
    get groupByFieldCount(): number;
    /** groupByFields */
    get groupByFields(): number[];
    /** expandWhenGrouping */
    set expandWhenGrouping(value: boolean);
    /** summarizer */
    get summarizer(): GridSummarizer;
    canGrouping(fields: number[]): boolean;
    getFieldDomain(field: number): any[];
    isFiltered(field: number): boolean;
    addFilter(field: number, refFiter: ColumnFilter): void;
    removeFilter(field: number, filter: ColumnFilterRun): void;
    clearFilters(field: number): void;
    clearAllFilters(): void;
    beginFiltering(): void;
    endFiltering(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    setHideDeletedRows(value: boolean): void;
    orderBy(fields: number[], directions: SortDirection[], cases: SortCase[]): void;
    getSortFields(): number[];
    getSortDirections(): SortDirection[];
    getSortCases(): SortCase[];
    setLabelComparer(comparer: any): void;
    groupBy(fields: number[], sorting?: boolean, direction?: SortDirection, textCase?: SortCase): void;
    groupByMode(fields: number[], mergeMode: boolean): void;
    addGroupBy(index: number, field: number, sorting: boolean): void;
    removeGroupBy(field: number, includeLower: boolean): void;
    isGroupedField(field: number): boolean;
    getGroupLevel(field: number): number;
    set isGroupSorting(value: boolean);
    expand(group: GroupItem, recursive: boolean, force: boolean, level: number): void;
    collapse(group: GroupItem, recursive: boolean, force: boolean): void;
    collapseAll(recursive: boolean): void;
    expandAll(recursive: boolean, level: number): void;
    setPaging(paging: boolean, pageSize: number, pageCount: number, pageSource: any): void;
    get page(): number;
    setPage(value: number, startRow: number): void;
    get pageCount(): number;
    set pageCount(value: number);
    getPageOfDataRow(dataRow: number): number;
    getDisplayItemIndex(item: GridItem): number;
    getCheckedRows(allRows: boolean): number[];
    set checkableExpression(expr: string);
    set checkableCallback(callback: any);
    resetCheckables(): void;
    applyCheckables(): void;
    setCheckFieldIndex(field: number): void;
    getFirstRow(): GridRow;
    getLastRow(): GridRow;
    getPrevRow(item: GridItem): GridRow;
    getNextRow(item: GridItem): GridRow;
    getGroupItem(id: number): GridItem;
    getJsonRows(): object[];
    get rowCount(): number;
    get visibleRowCount(): number;
    get sorted(): boolean;
    get movable(): boolean;
    getAllItems(): GridItem[];
    getPagingAllItems(): GridItem[];
    findItem(fields: any, values: any, options: any, startIndex: any, endIndex: any): any;
    findCell(fields: any, value: any, options: any, startIndex: number, endIndex: number, startFieldIndex: number): any;
    checkItems(items: GridItem[], checked: boolean, checkEvent: boolean): void;
    checkItem(item: GridItem, checked: boolean, exclusive: boolean, checkEvent: boolean): void;
    checkAll(checked: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent: boolean, groupCheckable: boolean): void;
    setItemChecked(item: GridItem, checked: boolean): boolean;
    getItemChecked(item: GridItem, checked: boolean): boolean;
    getItemOfRow(dataRow: number, force: boolean): GridItem;
    protected _doBeginUpdate(item: GridItem): EditItem;
    protected _doBeginAppendDummy(): DummyEditItem;
    protected _doBeginAppend(defaultValues: any): EditItem;
    protected _doBeginInsert(item: GridItem, defaultValues: any[], shift: boolean, ctrl: boolean): EditItem;
    protected _doCancelDummyEdit(): void;
    protected _doCancelEdit(state: ItemState, orgItem: GridItem): void;
    protected _doCommitEdit(state: ItemState, orgItem: GridItem): boolean;
    onGroupedItemProviderGrouping(rs: ItemProvider, fields: number[]): boolean;
    onGroupedItemProviderGrouped(rs: ItemProvider): void;
    onGroupedItemProviderExpand(rs: ItemProvider, group: GroupItem): boolean;
    onGroupedItemProviderExpanded(rs: ItemProvider, group: GroupItem): void;
    onGroupedItemProviderCollapse(rs: ItemProvider, group: GroupItem): boolean;
    onGroupedItemProviderCollapsed(rs: ItemProvider, group: GroupItem): void;
    onItemProviderFilterAdded(rs: ItemProvider, field: number, criteria: string): void;
    onItemProviderFilterRemoved(rs: ItemProvider, field: number, filter: ColumnFilter): void;
    onItemProviderFilterCleared(rs: ItemProvider, field: number): void;
    onItemProviderFilterAllCleared(rs: ItemProvider): void;
    onItemProviderFiltered(rs: ItemProvider, filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    onItemProviderSort(rs: ItemProvider, fields: number[], directions: SortDirection[]): void;
    onItemProviderSorted(rs: ItemProvider): void;
    onItemProviderDataLoadComplated(rs: ItemProvider): void;
}

/**@internal */
declare class DataRowExpressionRuntime extends ExpressionRuntime {
    private static readonly ID_ROW;
    private static readonly ID_DATAROW;
    private static readonly ID_CHECKED;
    private static readonly ID_VALUE;
    private static readonly ID_VALUES;
    private static readonly ID_STATE;
    private static readonly ID_COUNT;
    private static readonly ID_DCOUNT;
    private static readonly IDENTS;
    private _item;
    private _group;
    private _dataSource;
    private _fieldCount;
    constructor();
    protected _doDispose(): void;
    /** index */
    get index(): number;
    /** item */
    get item(): GridItem;
    setDataSource(value: DataSource): void;
    setItem(item: GridItem): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
}
/**@internal */
declare class DataCellExpressionRuntime extends ExpressionRuntime {
    private static readonly ID_VALUE;
    private static readonly ID_ROW;
    private static readonly ID_DATA_ROW;
    private static readonly ID_INDEX;
    private static readonly ID_FIELD;
    private static readonly ID_CHECKED;
    private static readonly ID_STATE;
    private static readonly ID_TAG;
    private static readonly ID_BASE;
    private static readonly ID_VALUES;
    private static readonly ID_COUNT;
    private static readonly ID_DCOUNT;
    private static readonly ID_CHANGED_CELL;
    private static readonly ID_LOOKUP_EXISTS;
    private static readonly IDENTS;
    private _cell;
    private _item;
    private _dataSource;
    private _fieldCount;
    private _grid;
    constructor();
    protected _doDispose(): void;
    setDataSource(value: DataSource): void;
    setCell(value: ValueCell, item: GridItem): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
}

/**
 * 행 스타일 변경을 위한 콜백
 *
 * @remarks
 * 스타일 클래스 명을 반환해야한다.
 *
 * {@link GridBase.setRowStyleCallback} 에서 쓰인다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `item` - 행 아이템
 *
 * `fixed` - 고정행 여부
 *
 * [반환값] - 스타일 클래스 명 또는 {@link RowStyleObject} 객체
 *
 * @example
 * ```js
 * const f = function(grid, item, fixed) {
 *      if (fixed) {
 *          return 'custom-fixed-row';
 *      }
 *      else if (item.isDataRow) {
 *          var val =
 *          return 'custom-data-row';
 *      }
 * }
 * gridView.setRowStyleCallback(f)
 * ```
 */
declare type RowStyleCallback = (grid: GridBase$1, item: GridItem, fixed: boolean) => string | RowStyleObject;
/** @internal */
declare class GridBody extends VisualObject {
    private static readonly ROW_STYLE;
    private static readonly ALTERNATE_ROW_STYLE;
    private static readonly FIXED_ROW_STYLE;
    private static readonly CHECKED_ROW_STYLE;
    static readonly STATE_ROW_STYLES: {
        created: string;
        deleted: string;
        createAndDeleted: string;
        updated: string;
    };
    private _cellStyleCallback;
    private _rowStyleCallback;
    private _cellButtonWidth;
    private _cellButtonHeight;
    private _editButtonWidth;
    private _editButtonHeight;
    private _errorIconWidth;
    private _errorIconHeight;
    private _ds;
    private _dataCell;
    private _hiddenCell;
    private _literalCell;
    private _seriesCell;
    private _mergedCell;
    private _rowRuntime;
    private _cellRuntime;
    private _showChangeMarker;
    private _formatter;
    private _buttonHeight;
    private _cs;
    private _rowCs;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** rowRuntime */
    get rowRuntime(): DataRowExpressionRuntime;
    /** cellRunTime */
    get cellRunTime(): DataCellExpressionRuntime;
    /** cellStyleCallback */
    get cellStyleCallback(): CellStyleCallback;
    set cellStyleCallback(value: CellStyleCallback);
    /** rowStyleCallback */
    get rowStyleCallback(): RowStyleCallback;
    set rowStyleCallback(value: RowStyleCallback);
    /** cellButtonWidth */
    get cellButtonWidth(): number;
    set cellButtonWidth(value: number);
    /** cellButtonHeight */
    get cellButtonHeight(): number;
    set cellButtonHeight(value: number);
    /** editButtonWidth */
    get editButtonWidth(): number;
    set editButtonWidth(value: number);
    /** editButtonHeight */
    get editButtonHeight(): number;
    set editButtonHeight(value: number);
    /** errorIconWidth */
    get errorIconWidth(): number;
    set errorIconWidth(value: number);
    /** errorIconHeight */
    get errorIconHeight(): number;
    set errorIconHeight(value: number);
    /** _buttonHeight */
    get buttonHeight(): number;
    private $_resetButtonHeight;
    getCell(index: CellIndex, merged: boolean): ValueCell;
    getCellAt(item: GridItem, column: GridColumn, merged: boolean): ValueCell;
    getHidden(index: CellIndex, hiddenRow: GridItem): ValueCell;
    getCellSimple(index: CellIndex, merged: boolean): ValueCell;
    getIndexCellStyle(index: CellIndex, addDefaultStyle?: boolean): ColumnStyle;
    getCellStyle(model: GridCell, cs: ColumnStyle, merged?: boolean, addDefaultStyle?: boolean): ColumnStyle;
    getCellFormatters(column: ValueColumn, cf: CellFormatter, index?: CellIndex, cs?: ColumnStyle): CellFormatter;
    getRowStyle(item: GridItem, fixed: boolean, isExport?: boolean, dynamicStyles?: boolean): RowStyle;
    private _prepareUpdate;
}

/** @internal */
declare class ContentPane extends LayerElement {
    constructor(doc: Document, name?: string);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    measure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    layoutContent(lm: GridLayoutManager, width: number, height: number): void;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(lm: GridLayoutManager, width: number, height: number): void;
}
/** @internal */
declare class DataContentPane extends ContentPane {
}

/**
 * 마우스 오른쪽 클릭을 통해 표시되는 팝업 메뉴의 설정 모델
 *
 * @remarks
 * 이미 만들어진 객체일 때는 {@link MenuItem} 의 형식의 객체다.
 *
 * @remarks
 * 인디케이터 등에서 지정하거나, {@link GridBase.addPopupMenu | addPopupMenu()} 로 설정 가능하다.
 *
 * @example
 * ```js
 *  let menu = [{
 *      label: "menu1 입니다.",
 *      children: [{
 *          label: "submenu1 입니다."
 *      }, {
 *          label: "submenu2 입니다."
 *      }]
 *  }, {
 *      label: "menu2 입니다",
 *  }, {
 *      label: "-"
 *  }, {
 *      label: "menu3 입니다",
 *      type: "check",
 *      checked: true,
 *      tag: "check_menu"
 *  }, {
 *      label: "group menu",
 *      children: [{
 *          label: "group1 - 첫번째",
 *          type: "radio",
 *          group: "group1",
 *          checked: true
 *      }, {
 *          label: "group1 - 두번째",
 *          type: "radio",
 *          group: "group1"
 *      }, {
 *          label: "group1 - 세번째",
 *          type: "radio",
 *          group: "group1"
 *      }]
 *  }];
 * ```
 */
interface PopupMenuItem$1 {
    /**
     * 팝업 메뉴에서 해당 아이템의 표시 텍스트
     */
    label?: string;
    /**
     * 클릭 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 표시 여부
     *
     * @defaultValue `true`
     */
    visible?: boolean;
    /**
     * 메뉴 아이템의 유형
     *
     * @defaultValue {@link MenuItemType.NORMAL}
     */
    type?: MenuItemType;
    /**
     * 하위 메뉴 아이템들
     */
    children?: PopupMenuItem$1[];
    /**
     * 그룹 명
     */
    group?: string;
    /**
     * 체크 여부
     *
     * @remarks
     * {@link PopupMenuItem."type" | type} 이 {@link MenuItemType.CHECK | check} 또는 {@link MenuItemType.RADIO | radio} 일 때 활성화된다.
     */
    checked?: boolean;
    /**
     * 태그
     */
    tag?: any;
    /**
     * 메뉴 아이템을 클릭했을 때 호출되는 콜백
     *
     * @eventProperty
     */
    callback?: MenuItemClick;
}
/**
 * 메뉴 항목 관련 설정 정보 모델
 *
 * @remarks
 * {@link PopupMenuItem} 형식을 이용하여 생성한 객체를 {@link GridBase.onMenuItemClicked} 와 {@link GridBase.onContextMenuItemClicked} 으로 콜백을 지정할 때 매개변수로 사용된다.
 *
 * 또는 {@link GridBase.addPopupMenu} 사용 시  {@link PopupMenuItem.callback | callback} 의 매개변수 중 `menuItem`의 형식이다.
 *
 * @example
 * ```js
 * gridView.addPopupMenu("menu1", [
 *         {
 *              label: "alpha",
 *              callback: function(grid, menuItem, index) {
 *                  console.log("aa")
 *                  console.log(menuItem); // 해당 형식의 객체
 *                  console.log(clickData);
 *              }
 *         },
 *         {label: "beta"},
 *         {label: "gamma"}
 * ]);
 * ```
 */
interface MenuItem {
    /**
     * 메뉴 항목 형태
     */
    type: MenuItemType;
    /**
     * 표시 여부
     */
    visible: boolean;
    /**
     * 클릭 가능 여부
     */
    enabled: boolean;
    /**
     * 메뉴에 표시될 명칭
     */
    label: string;
    /**
     * 메뉴의 그룹, type이 "radio"일때 동일 그룹내에서 하나만 선택
     */
    group: string;
    /**
     * type이 "check"나 "radio"일때 체크 여부
     */
    checked: boolean;
    /**
     * 태그
     */
    tag: any;
    /**
     * 클릭 했을 때 호출되는 콜백
     * @eventProperty
     */
    menuItemClick: MenuItemClick;
    /**
     * 부모: MenuItem 객체
     */
    parent: MenuItem;
}
/**
 * 아이템의 정보 모델
 *
 * @remarks
 * {@link GridBase.getModel}, {@link GridBase.getModelAs} 등으로 아이템의 모델을 반환할 때의 형식이다.
 *
 * 아이템의 모델을 반환 할 때, 해당 method 에 `extended` 매개변수가 `true` 냐 `false` 냐에 따라 반환되는 모델의 형식이 다를 수 있다.
 *
 * @example
 * ```js
 * let model = gridView.getModelAs(3, 'row'); // GridItem 모델 반환
 * ```
 */
interface GridItem$1 {
    /**
     * 종류
     */
    type: undefined | 'row' | 'group' | 'tree' | 'footer';
    /**
     * 아이템 id
     */
    id: number;
    /**
     * 부모의 id
     */
    parentId: number;
    /**
     * 그리드 상에서의 순서
     */
    index: number;
    /** @deprecated */
    /**
     * 그리드 상에서의 순서
     *
     * @remarks
     * RealGridJS와 호환성을 위해서 남겨둔 속성
     */
    itemIndex: number;
    /**
     * 행 고유번호
     */
    dataRow: number;
    /**
     * 체크 여부
     */
    checked: boolean;
    /**
     * 하위 아이템의 개수
     */
    count?: number;
    /**
     * 펼쳐짐 여부
     *
     * @remarks
     * {@link TreeView} 의 아이템일나 그룹 아이템일 때 해당 정보를 얻을 수 있다.
     */
    expanded?: boolean;
    /**
     * 푸터 id
     */
    footerId?: number;
    /**
     * 자신의 부모를 기준으로한 자신의 순서
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    childIndex?: number;
    /**
     * 수준
     *
     * @remarks
     * {@link TreeView} 의 행이라면 트리의 수준이다.
     *
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    level?: number;
    /**
     * 그룹아이템일 경우 처음 아이템
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    firstItem?: GridItem$1;
    /**
     * 그룹아이템일 경우 처음 데이터 아이템
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    firstDataItem?: GridItem$1;
    /**
     * 그룹아이템일 경우 하위 행들의 인덱스
     *
     * @remarks
     * `extended` 가 `true` 여야 정보를 얻을 수 있다.
     */
    dataRows?: number[];
}

declare type RowBarCellStyleCallback = (grid: GridBase$1, type: string, index: number) => string;
/** @internal */
declare abstract class SectionObject extends VisualObject {
    private _displayOrder;
    private _headText;
    private _footText;
    private _sumText;
    private _popupMenu;
    private _popupMenuName;
    private _visChanged;
    private _cellStyleCallback;
    private _headCell;
    private _footCell;
    private _sumCell;
    constructor(grid: GridBase$1);
    /** displayOrder */
    get displayOrder(): number;
    set displayOrder(value: number);
    /** headText */
    get headText(): string;
    set headText(value: string);
    /** footText */
    get footText(): string;
    set footText(value: string);
    /** sumText */
    get sumText(): string;
    set sumText(value: string);
    /** popupMenu */
    get popupMenu(): PopupMenuItem$1[] | string;
    set popupMenu(value: PopupMenuItem$1[] | string);
    get popupMenuName(): string;
    set popupMenuName(value: string);
    get visChanged(): boolean;
    set visChanged(value: boolean);
    get cellStyleCallback(): RowBarCellStyleCallback;
    set cellStyleCallback(value: RowBarCellStyleCallback);
    abstract getCell(index: CellIndex): GridCell;
    getHeadCell(): StyledCell;
    getFootCell(): StyledCell;
    getSumCell(): StyledCell;
    abstract getHeadStyleName(): string;
    abstract getFootStyleName(): string;
    abstract getSumStyleName(): string;
    abstract getCellType(): GridCellType;
    protected abstract get staticOrder(): number;
    protected _createHeadCell(): StyledCell;
    protected _createFootCell(): StyledCell;
    protected _createSumCell(): StyledCell;
    protected _visibleChanged(): void;
}

/** @internal */
declare class GridLayoutManager extends Base {
    private _grid;
    private _rs;
    private _refreshMode;
    private _leftPos;
    private _rightFixed;
    private _footerCount;
    private _headerSummaryCount;
    private _cellLayouts;
    private _layoutCount;
    private _fixedLayoutCount;
    private _rightLayoutCount;
    private _firstLayout;
    private _lastLayout;
    private _layoutsLength;
    private _layouts;
    private _layoutPoints;
    private _fixedLayoutPoints;
    private _rightLayoutPoints;
    private _cellCount;
    private _fixedCellCount;
    private _rightCellCount;
    private _firstCell;
    private _lastCell;
    private _startCell;
    private _endCell;
    private _cellPoints;
    private _fixedCellPoints;
    private _rightCellPoints;
    private _trs;
    private _rowGrouped;
    private _items;
    private _topIndex;
    private _itemCount;
    private _fixedItemCount;
    private _fullItemCount;
    private _fixedItemPoints;
    private _itemPoints;
    private _fixedTableRowCount;
    private _tableRowCount;
    private _fixedTableRowPoints;
    private _tableRowPoints;
    private _fixedTableItemPoints;
    private _tableItemPoints;
    private _fixedDataHeight;
    private _dataRowHeights;
    private _dataHeight;
    private _fixedBarWidth;
    private _rightBarWidth;
    private _fixedBarHeight;
    private _topContentBounds;
    private _leftContentBounds;
    private _sideContentBounds;
    private _contentBounds;
    private _fixedContentBounds;
    private _rightContentBounds;
    private _rowBarBounds;
    private _headerBounds;
    private _fixedHeaderBounds;
    private _rightHeaderBounds;
    private _summaryBounds;
    private _fixedSummaryBounds;
    private _rightSummaryBounds;
    private _footerBounds;
    private _fixedFooterBounds;
    private _rightFooterBounds;
    private _headBounds;
    private _sumBounds;
    private _footBounds;
    private _itemsBounds;
    private _fixedWidth;
    private _rightWidth;
    private _fixedHeight;
    private _dataBounds;
    private _bodyBounds;
    private _nonFixedBounds;
    private _gridBounds;
    private _fixedBodyBounds;
    private _rightBodyBounds;
    private _autoRowHeights;
    private _minRowHeight;
    private _minItemHeight;
    private _maxHeight;
    private _itemHeight;
    private _hscrolled;
    private _vscrolled;
    private _hscrollBar;
    private _vscrollBar;
    private _scrollBarWidth;
    private _scrollBarHeight;
    private _scrollWidth;
    private _clientRect;
    private _fitStyle;
    private _fitStyleChanged;
    private _oldSyncHeight;
    private _fitSyncChanged;
    private _reqScrollBarWidth;
    private _reqScrollBarHeight;
    private _focusIndex;
    private _prevFocused;
    private _fitSyncHeight;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    /** footerCount */
    get footerCount(): number;
    /** headerSummaryCount */
    get headerSummaryCount(): number;
    /** vscrollBar */
    get vscrollBar(): boolean;
    /** hscrollBar */
    get hscrollBar(): boolean;
    /** scrollBarWidth */
    get scrollBarWidth(): number;
    /** scrollBarHeight */
    get scrollBarHeight(): number;
    /** dataBounds */
    get dataBounds(): Rectangle;
    /** bodyBounds */
    get bodyBounds(): Rectangle;
    /** fixedBodyBounds */
    get fixedBodyBounds(): Rectangle;
    /**
     * 상단 영역, 하단 영역 제외. 고정 영역까지 제외, 스크롤바드르 제외한 영역.
     */
    get gridBounds(): Rectangle;
    /** headerBounds */
    get headerBounds(): Rectangle;
    /** summaryBounds */
    get summaryBounds(): Rectangle;
    /** footerBounds */
    get footerBounds(): Rectangle;
    /** topContentBounds */
    get topContentBounds(): Rectangle;
    /** leftContentBounds */
    get leftContentBounds(): Rectangle;
    /** rowBarBounds */
    get rowBarBounds(): Rectangle;
    /** sideContentBounds */
    get sideContentBounds(): Rectangle;
    /** contentBounds */
    get contentBounds(): Rectangle;
    /** fixedContentBounds */
    get fixedContentBounds(): Rectangle;
    /** nonFixedBounds */
    get nonFixedBounds(): Rectangle;
    /** rightContentBounds */
    get rightContentBounds(): Rectangle;
    /** headBounds */
    get headBounds(): Rectangle;
    /** sumBounds */
    get sumBounds(): Rectangle;
    /** footBounds */
    get footBounds(): Rectangle;
    /** fixedWidth */
    get fixedWidth(): number;
    /** rightWidth */
    get rightWidth(): number;
    /** defaultItemHeight */
    get defaultItemHeight(): number;
    /** topIndex */
    get topIndex(): number;
    /** itemCount */
    get itemCount(): number;
    /** fixedItemCount */
    get fixedItemCount(): number;
    /** fullItemCount */
    get fullItemCount(): number;
    /** fixedTableRowCount */
    get fixedTableRowCount(): number;
    /** tableRowCount */
    get tableRowCount(): number;
    /** trs */
    get trs(): number;
    /** leftPos */
    get leftPos(): number;
    /** cellLayouts */
    get cellLayouts(): GridCellLayout;
    /** layoutCount */
    get layoutCount(): number;
    /** fixedLayoutCount */
    get fixedLayoutCount(): number;
    /** rightLayoutCount */
    get rightLayoutCount(): number;
    /** firstLayout */
    get firstLayout(): number;
    /** lastLayout */
    get lastLayout(): number;
    /** rightFirstLayout */
    get rightFirstLayout(): number;
    /** layoutsLength */
    get layoutsLength(): number;
    /** cellCount */
    get cellCount(): number;
    /** fixedCellCount */
    get fixedCellCount(): number;
    /** rightCellCount */
    get rightCellCount(): number;
    /** firstCell */
    get firstCell(): number;
    /** lastCell */
    get lastCell(): number;
    /** startCell */
    get startCell(): number;
    /** endCell */
    get endCell(): number;
    /** isColumnFitted */
    get isColumnFitted(): boolean;
    /** _scrollWidth */
    get scrollWidth(): number;
    /** fixedBarWidth */
    get fixedBarWidth(): number;
    /** rightBarWidth */
    get rightBarWidth(): number;
    /** fixedHeight */
    get fixedHeight(): number;
    /** fixedBarHeight */
    get fixedBarHeight(): number;
    /** rowGrouped */
    get rowGrouped(): boolean;
    /** mergedRowGrouped */
    get mergedRowGrouped(): boolean;
    /** rowGroupFields */
    get rowGroupFields(): number[];
    /** rowGroupLevels */
    get rowGroupLevels(): number;
    /**
     * 스크롤바를 제외한 그리드 전체 영역.
     */
    get clientRect(): Rectangle;
    get headerRows(): number;
    get headerSummaryRows(): number;
    get footerRows(): number;
    get topPanelVisible(): boolean;
    get minRowHeight(): number;
    get minItemHeight(): number;
    get fitStyle(): GridFitStyle;
    syncHeight(): boolean;
    fitSyncHeight(): boolean;
    getStartCell(): number;
    getEndCell(): number;
    getLayout(index: number): CellLayoutItem;
    getLayoutBounds(index: number): Rectangle;
    getLayoutWidth(index: number): number;
    getPositionToVIndex(pos: number): number;
    getFixedLayoutWidth(index: number): number;
    getRightLayoutWidth(index: number): number;
    getCellIndex(x: number): number;
    getHorzColumnIndex(layout: CellLayoutItem): number;
    getLeftCell(): number;
    getCellPoint(index: number): number;
    getCellWidth(index: number): number;
    getCellWidth2(index: number, len: number): number;
    getFixedCellPoint(index: number): number;
    getFixedCellWidth(index: number): number;
    getFixedCellWidth2(index: number, len: number): number;
    getRightCellPoint(index: number): number;
    getRightCellWidth(index: number): number;
    getRightCellWidth2(index: number, len: number): number;
    private $_getItems;
    getItem(index: number): GridItem;
    getDataRowHeights(trs: number): number[];
    protected _calcDefaultRowHeight(grid: GridBase$1): number;
    measure(bounds: Rectangle, leftPos: number, topIndex: number, scrollBarWidth: number, scrollBarHeight: number): void;
    layout(bounds: Rectangle): void;
    getItemHeight(item: GridItem): number;
    getTableItemHeight(row: number): number;
    getTableItemIndex(y: number): number;
    getTableItemTop(row: number): number;
    getTableItemBottom(row: number): number;
    getItemBounds(row: number): Rectangle;
    getItemRect(row: number, fixed?: boolean): Rectangle;
    getTableItemBounds(row: number): Rectangle;
    /**
     * calcItemPoints()로 계산된 높이를 리턴한다.
     * 즉, cell rendering 시 참조하는 높이.
     * 자동 높이인 경우 렌더링을 완료하기 전에 행의 실제 높이를 미리 알 수 없다.
     * layout()이 완료된 후에는 getTableRowHeight()를 사용해야 한다.
     */
    getTableRowHeightFixed(row: number, count: number): number;
    getTableRowHeight(row: number, count: number): number;
    getTableRowBounds(row: number, span: number): Rectangle;
    getTableRowIndex(y: number): number;
    /**
     * 사용자 수평 스크롤시 전체 layout없이 contentPane만 이동시킨다.
     */
    setLeftPos(bounds: Rectangle, pos: number): void;
    isMergedCell(index: CellIndex): boolean;
    getMergeRoom(index: CellIndex): ColumnMergeRoom;
    getHeaderCellAt(x: number, y: number, proxy?: boolean): CellLayoutItem;
    getHeaderCellRect(layout: CellLayoutItem, inclueChildren?: boolean): Rectangle;
    getLayoutRect(index: number): Rectangle;
    getDataRect(layout: CellLayoutItem): Rectangle;
    getBodyView(index: CellIndex | CellLayoutItem): GridBodyElement;
    mouseToIndex(target: HTMLTableCellElement, x: number, y: number, index: CellIndex): CellIndex;
    mouseToIndexEx(target: HTMLTableCellElement, x: number, y: number, index: CellIndex): CellIndex;
    cellIsVisible(index: CellIndex): boolean;
    clearFocusRequest(): void;
    focusIsVisible(index?: CellIndex): boolean;
    makeCellVisible(index: CellIndex): void;
    isAutoRowHeights(): boolean;
    isRowGrouped(): boolean;
    scrollToNextCell(): number;
    scrollToPrevCell(): number;
    needRelayout(): boolean;
    /**
     * 왼쪽 고정 영역의 cell layout들에 포함된 tabel cell들의 너비를 계산한다.
     * 고정 영역에 포함된 layout이 없어도 이 함수는 먼저 호출되어야 한다.
     */
    private $_calcFixedCellPoints;
    /**
     * 비고정 영역의 cell layout들에 포함된 tabel cell들의 너비를 계산한다.
     */
    private $_calcCellPoints;
    /**
     * 우측 고정 영역의 cell layout들에 포함된 tabel cell들의 너비를 계산한다.
     */
    private $_calcRightCellPoints;
    /**
     * 좌위 고정 영역들을 제외하고 데이터셀들을 표시할 수 있는 수평 영역의 크기를 계산한다.
     */
    private $_calcScrollWidth;
    private $_calcLeftPos;
    private $_checkFitting;
    private $_fitColumns;
    private $_measureTopPane;
    protected _doMeasureTopPane(grid: GridBase$1, bounds: Rectangle): void;
    /**
     * 모델 속성을 기준으로 기본 높이들을 계산한다.
     * $_adjustLayout 에서 실제 높이로 맞춘다.
     */
    private $_measureViewHeights;
    private $_sortSections;
    private _sectionObjects;
    get sectionObjects(): SectionObject[];
    private $_measureLeftPane;
    protected _measureSidePane(grid: GridBase$1): void;
    private $_measureFixedPane;
    private $_measureRightPane;
    private $_measureContentPane;
    getRowHeightOfCallback(grid: GridBase$1, index: number): number;
    private $_getItemHeight;
    private $_calcItemPoints;
    private $_updateScrollInfo;
    private $_recalcScrollInfo;
    private $_adjustVerticals;
    private $_adjustHorizontals;
    private $_calcTableRowPoints;
    protected _doMeasure(bounds: Rectangle, scrollBarWidth: number, scrollBarHeight: number): void;
    private $_layoutTopPane;
    protected _doLayoutTopPane(grid: GridBase$1, pane: ContentPane): void;
    private $_layoutLeftPane;
    protected _layoutSidePane(grid: GridBase$1, pane: ContentPane): void;
    protected _prepareItems(autoRowHeights?: boolean): void;
    private $_layoutFixedPane;
    private $_layoutRightPane;
    private $_layoutContentPane;
    protected $_layoutWatingPane(grid: GridBase$1, pane: ContentPane): void;
    protected _doLayout(grid: GridBase$1, bounds: Rectangle): void;
    private $_adjustHeader;
    protected _adjustLayout(grid: GridBase$1, bounds: Rectangle): void;
    private $_layoutBodyRows;
    private $_adjustTableRowHeights;
    private $_fillBottomFixed;
    private $_fillBottomAuto;
    private $_prepareColumnMerges;
    private $_checkColumnMerging;
}

/** @internal */
declare abstract class GridElement extends VisualElement {
    constructor(doc: Document, name?: string);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    measure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    layoutContent(lm: GridLayoutManager): void;
    protected _getCssSelector(): string;
    protected _getCssDisplay(): string;
    protected _doDraw(element: HTMLElement): void;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doPrepareContent(lm: GridLayoutManager): void;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doRender(dom: HTMLElement): void;
}
/** @internal */
interface GridItemElement {
    itemIndex: number;
}
/** @internal */
declare abstract class VisualObjectElement extends GridElement {
    protected _ff: boolean;
    protected _chromium: boolean;
    protected _textProp: string;
    private _model;
    private _cursor;
    constructor(doc: Document, model: VisualObject, name?: string);
    protected _doDispose(): void;
    /** model */
    get model(): VisualObject;
    setCursor(value: string): void;
}

/** @internal */
declare class Point {
    x: number;
    y: number;
    static empty(): Point;
    static create(x?: number, y?: number): Point;
    constructor(x?: number, y?: number);
    /** isEmpty */
    get isEmpty(): boolean;
    clone(): Point;
    equals(sz: Point): boolean;
    setEmpty(): Point;
    set(x: number, y: number): Point;
    round(): Point;
    toString(): string;
}

/** @internal */
declare abstract class TableBaseElement extends VisualObjectElement {
    private _table;
    private _thead;
    private _tbody;
    private _explicitWidth;
    constructor(doc: Document, model: VisualObject, name?: string);
    protected _doDispose(): void;
    get tableRowCount(): number;
    getCellPoint(td: HTMLTableCellElement, p?: Point): Point;
    protected _getTableHidden(): boolean;
    protected _getTableCaption(): string;
    protected _createDom(doc: Document): HTMLElement;
    protected _initDom(dom: HTMLElement): void;
    protected _doPrepareContent(lm: GridLayoutManager): void;
    protected _doDraw(element: HTMLElement): void;
    protected _getExplicitWidth(lm: GridLayoutManager): number;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    protected _doPrepareTable(lm: GridLayoutManager): void;
    protected _doPrepareTableHead(lm: GridLayoutManager, head: HTMLTableSectionElement): void;
    protected abstract _doPrepareTableRows(lm: GridLayoutManager, body: HTMLTableSectionElement): void;
    protected _prepareTableRowCells(lm: GridLayoutManager, row: HTMLTableRowElement): number;
    protected _isFixedHeight(lm: GridLayoutManager): boolean;
    protected _getMinRowHeight(lm: GridLayoutManager): number;
    protected abstract _isDataTable(): boolean;
    protected _doPrepareTableRow(lm: GridLayoutManager, index: number, tindex: number, tr: HTMLTableRowElement): void;
    protected _doRenderTable(body: HTMLTableSectionElement): void;
    private _renderRow;
    private _renderCell;
    protected abstract _getTableRowCount(lm: GridLayoutManager): number;
    /**
     * @param row -1이면 head row의 cell 개수.
     */
    protected abstract _getCellCount(lm: GridLayoutManager): number;
    protected abstract _getCellWidth(lm: GridLayoutManager, col: number): number;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doDrawRow(row: number, dom: HTMLTableRowElement): void;
    protected _doDrawCell(row: number, col: number, dom: HTMLElement): void;
    protected _getTableRow(lm: GridLayoutManager, row: number): HTMLTableRowElement;
    protected _getTableRows(lm: GridLayoutManager, row: number, count: number): HTMLTableRowElement[];
    protected _getTableCell(row: number, col: number): HTMLTableCellElement;
    protected getCellContent(row: number, col: number): HTMLElement;
    protected getContentAt(index: CellIndex): HTMLElement;
    protected abstract _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
}
/** @internal */
declare abstract class SimpleTableElement extends TableBaseElement {
    protected _isDataTable(): boolean;
    protected _doPrepareTableRows(lm: GridLayoutManager, body: HTMLTableSectionElement): void;
    protected _getTableRowCount(lm: GridLayoutManager): number;
}
/** @internal */
declare abstract class DataTableElement extends TableBaseElement {
    protected _trCount: number;
    protected _trs: number;
    protected _isDataTable(): boolean;
    protected _getTrs(lm: GridLayoutManager): number;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected $_getTableIndex(lm: GridLayoutManager, row: number): number;
    protected _getTableRow(lm: GridLayoutManager, row: number): HTMLTableRowElement;
    protected _doPrepareTableRows(lm: GridLayoutManager, body: HTMLTableSectionElement): void;
    private $_prepareFixedBar;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _getCellContent(td: HTMLTableCellElement): HTMLElement;
    protected _updateCellContent(grid: GridBase$1, cell: GridCell, td: HTMLTableCellElement): void;
    protected _doUpdateCellContent(grid: GridBase$1, cell: GridCell, dom: HTMLElement): void;
}

/**
 * dom을 생성하지 않고, table row로 대체한다.
 * @internal
 */
declare abstract class ItemElement extends GridElement implements GridItemElement {
    protected _item: GridItem;
    protected _domIndex: number;
    protected _trs: number;
    protected _fixedHeight: boolean;
    constructor(doc: Document, name?: string);
    protected _doDispose(): void;
    /** itemIndex */
    get itemIndex(): number;
    updateItem(item: GridItem, domIndex: number, trs: number, fixedHeight: boolean): void;
    clearContent(lm: GridLayoutManager, trs: number): void;
    protected _createDom(): HTMLElement;
    protected $_getDefaultRenderer(grid: GridBase$1, model: ValueCell): string;
    protected _changed(): void;
    protected _getTableRow(lm: GridLayoutManager, row: number): HTMLElement;
    protected _getTableRows(lm: GridLayoutManager): HTMLElement[];
    protected _getCellContent(col: number): HTMLElement;
}
/** @internal */
declare class RowElement extends ItemElement {
    static isExpander(elt: HTMLElement): boolean;
    constructor(doc: Document, name?: string);
    resetButtons(grid: GridBase$1, oldCell: BodyTableCell, newCell: BodyTableCell): void;
    moveCellButtons(lm: GridLayoutManager, cell: BodyTableCell, itemIndex: number): void;
    cellRefresh(grid: GridBase$1, body: GridBody, model: ValueCell, column: ValueColumn, bcell: BodyTableCell): void;
    clearContent(lm: GridLayoutManager, trs: number): void;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _getFirstCell(lm: GridLayoutManager): number;
    protected _getLastCell(lm: GridLayoutManager): number;
    protected _getStartCell(lm: GridLayoutManager): number;
    protected _getEndCell(lm: GridLayoutManager): number;
    protected _createRenderer(grid: GridBase$1, model: ValueCell, type: string, cfg1: any, cfg2: any): DataCellRenderer;
    protected $_getRenderer(grid: GridBase$1, model: ValueCell, cs: ColumnStyle, dcol: ValueColumn, cell: BodyTableCell): DataCellRenderer;
    protected $_getCellWidth2(lm: GridLayoutManager, index: number, count: number): number;
    protected $_clearAriaProperty(td: HTMLTableCellElement): void;
    protected _renderDataCell(grid: GridBase$1, body: GridBody, model: ValueCell, cs: ColumnStyle, cell: BodyTableCell, dcol: ValueColumn): void;
    protected _clearDataCell(bcell: BodyTableCell): void;
    protected _updateDataCell(grid: GridBase$1, lm: GridLayoutManager, body: GridBody, model: ValueCell, dcol: ValueColumn, bcell: BodyTableCell, render?: boolean): void;
    private $_getButtonVisible;
    private $_buttonWidth;
    private $_editButtonWidth;
    private $_editButtonCount;
    private $_editButtonVerti;
    private $_errorWidth;
    /**
     * cellButton 등의 변수로 cache하면,
     * Auto row heights의 경우 뒷부분의 trow를 남겨 놓는데,
     * 그 것을 다시 사용하게 되면서 cache가 깨지게 된다.
     * 대신 td.childElementCount를 이용해서 구현한다.
     */
    private $_setButtons;
    private $_setButtonZIndex;
}

/**
 * @internal
 */
declare class TextFormatter {
    private static readonly Formatters;
    static getFormatter(format: string): TextFormatter;
    private _format;
    private _pattern;
    private _replace;
    constructor(format: string);
    get format(): string;
    getText(text: string): string;
    $_parse(fmt: string): void;
}

/** @internal */
declare class HeaderCell extends GridCell {
    private _text;
    private _template;
    private _itemOffset;
    private _itemGap;
    private _checkLocation;
    private _checked;
    private _showTooltip;
    private _tooltip;
    private _edgeMark;
    constructor();
    protected _doDispose(): void;
    /** text */
    get text(): string;
    set text(value: string);
    /** template */
    get template(): string;
    set template(value: string);
    /** itemOffset */
    get itemOffset(): number;
    set itemOffset(value: number);
    /** itemGap */
    get itemGap(): number;
    set itemGap(value: number);
    /** checkLocation */
    get checkLocation(): ColumnHeaderItemLocation;
    set checkLocation(value: ColumnHeaderItemLocation);
    /** checked */
    get checked(): boolean;
    set checked(value: boolean);
    /** showTooltip */
    get showTooltip(): boolean;
    set showTooltip(value: boolean);
    /** tooltip */
    get tooltip(): string;
    set tooltip(value: string);
    /** edgeMark */
    get edgeMark(): EdgeMark;
    set edgeMark(value: EdgeMark);
}
/**
 * 헤더 영역의 설정 모델
 *
 * @internal
 */
declare class GridHeader$1 extends VisualObject implements GridHeader {
    private _minRowHeight;
    private _minHeight;
    private _height;
    private _heights;
    private _resizable;
    private _itemOffset;
    private _itemGap;
    private _showSelection;
    private _showTooltip;
    private _sortWidth;
    private _sortHeight;
    private _filterWidth;
    private _filterHeight;
    private _popupWidth;
    private _popupHeight;
    private _expanderWidth;
    private _expanderHeight;
    private _checkWidth;
    private _checkHeight;
    private _showPopupMenu;
    private _styleName;
    private _exportStyleName;
    private _cell;
    private _calcHeights;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** 헤더 개별행의 최소 높이 */
    get minRowHeight(): number;
    set minRowHeight(value: number);
    /** 헤더의 최소 높이 */
    get minHeight(): number;
    set minHeight(value: number);
    /**
     * 헤더의 높이
     * 1. `0`: 기본 스타일로 tr의 높이를 계산해서 지정(table row의 최소 높이가 됨),
     *    전체 헤더 높이가 커지면 row들이 다 표시되도록 element container의 높이를 보정한다.
     * 2. `0` 초과: 지정한 높이로 전체 높이를 설정, tr 높이는 minRowHeight 높이로 설정한다.
     *    container 높이가 tr들의 높이합보다 큰 경우 배분한다.
     *    container 높이를 보정하지 않는다.
     * 3. `0` 미만: 브라우저가 계산한 높이
     *
     * heights 속성에 각 table row의 높이를 지정할 수 있다.
     *
     * 전체 높이가 minHeight보다 작을 수 없다.
     * 개별 tr의 높이는 minRowHeight보다 작을 수 없다.
     *
     */
    get height(): number;
    set height(value: number);
    /** 헤더의 현재 표시 높이. */
    get displayHeight(): number;
    /** 개별 헤더 행의 높이 */
    get heights(): number[];
    set heights(value: number[]);
    /** 높이 변경 가능 여부 */
    get resizable(): boolean;
    set resizable(value: boolean);
    /** 헤더 테두리와 체크박스나 이미지와의 간격 */
    get itemOffset(): number;
    set itemOffset(value: number);
    /** text와 체크박스나 이미지와의 간격 */
    get itemGap(): number;
    set itemGap(value: number);
    /** 툴팁 표시 여부 */
    get showTooltip(): boolean;
    set showTooltip(value: boolean);
    /**
     * 선택 상태 표시 여부
     *
     * @remarks
     * `true` 시 데이터 선택 영역에 맞춰 관련된 셀들에 선택 상태를 표시한다.
     *
     * @defaultValue `false`
     */
    get showSelection(): boolean;
    set showSelection(value: boolean);
    /** 헤더의 정렬 핸들 너비 */
    get sortWidth(): number;
    set sortWidth(value: number);
    /** 헤더의 정렬 핸들 높이 */
    get sortHeight(): number;
    set sortHeight(value: number);
    /**헤더의 필터 핸들 너비 */
    get filterWidth(): number;
    set filterWidth(value: number);
    /** 헤더의 필터 핸들 높이 */
    get filterHeight(): number;
    set filterHeight(value: number);
    /** 헤더의 팝업 메뉴 핸들 너비 */
    get popupWidth(): number;
    set popupWidth(value: number);
    /** 헤더의 팝업 메뉴 핸들 높이 */
    get popupHeight(): number;
    set popupHeight(value: number);
    /** 헤더의 expander 메뉴 핸들 너비 */
    get expanderWidth(): number;
    set expanderWidth(value: number);
    /** 헤더의 expander 메뉴 핸들 높이 */
    get expanderHeight(): number;
    set expanderHeight(value: number);
    /** 헤더에 popupMenuName이 설정된 경우 popupButton을 표시한다. */
    get showPopupMenu(): HandleVisibility;
    set showPopupMenu(value: HandleVisibility);
    /** 헤더의 체크 박스 너비 */
    get checkWidth(): number;
    set checkWidth(value: number);
    /** 헤더의 체크 박스 높이 */
    get checkHeight(): number;
    set checkHeight(value: number);
    /** styleName */
    get styleName(): string;
    set styleName(value: string);
    /** exportStyleName */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    setCalcHeights(heights: number[]): void;
    getCalcHeights(): number[];
    getCell(layout: CellLayoutItem): HeaderCell;
    getStyleName(): string;
}

/** @internal */
declare class HeaderTableCell extends TableCell {
    check: HTMLInputElement;
    sort: HTMLElement;
    filter: HTMLElement;
    popup: HTMLElement;
    textSpan: HTMLSpanElement;
    expander: HTMLElement;
    rendererClass: string;
    html: string;
    showTooltip: boolean;
    tooltip: string;
    sortWidth: number;
    filterWidth: number;
    checkWidth: number;
    popupWidth: number;
    expanderWidth: number;
    marginLeft: number;
    marginRight: number;
    marginTop: number;
    marginBottom: number;
    edgeMarker: HTMLElement;
    edgeMark: EdgeMark;
    constructor(td: HTMLTableCellElement);
    dispose(): void;
    span(): void;
    clear(visible: boolean): HeaderTableCell;
    setText(elt: HTMLElement, value: string): void;
    setHtml(elt: HTMLElement, value: string): void;
    setClassName(value: string): boolean;
    setRendererClassName(div: HTMLElement, value: string): void;
    setDivMarigns(css: CSSStyleDeclaration, left: number, right: number, top: number, bottom: number): void;
    getIndex(index: CellIndex): CellIndex;
    isClickableElt(elt: HTMLElement): boolean;
}
/** @internal */
declare class HeaderElement extends SimpleTableElement {
    private static readonly RENDERER_STYLE;
    static renderCell(model: HeaderCell, dom: HTMLElement): void;
    private _fixedHeight;
    private _minRowHeight;
    private _rowPoints;
    private _cells;
    constructor(doc: Document, model: GridHeader$1);
    protected _doDispose(): void;
    tableCellByCell(cell: HTMLTableCellElement): HeaderTableCell;
    tableCellByLayout(layout: CellLayoutItem): HeaderTableCell;
    tableCellByLayout2(lm: GridLayoutManager, layout: CellLayoutItem): HeaderTableCell;
    layoutByCell(cell: HTMLTableCellElement): CellLayoutColumnItem;
    columnByCell(cell: HTMLTableCellElement): GridColumn;
    getSpanRoot(layout: CellLayoutItem): CellLayoutItem;
    refresh(grid: GridBase$1): void;
    getRowAt(y: number): number;
    getLayoutHeight(layout: CellLayoutItem, cell: HeaderTableCell, includeChildren: boolean): number;
    getLayoutPos(layout: CellLayoutItem): number;
    _getCssSelector(): string;
    _isFixedHeight(): boolean;
    _getMinRowHeight(lm: GridLayoutManager): number;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    private $_refreshHeadTitle;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doRender(dom: HTMLElement): void;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected _getTableRowHeight(lm: GridLayoutManager, row: number): number;
    private $_getCellHeight;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    protected _getCellWidth2(lm: GridLayoutManager, col: number, span: number): number;
    protected _doDrawCell(row: number, col: number, dom: HTMLTableCellElement): void;
    protected _doPrepareTableRow(lm: GridLayoutManager, index: number, tIndex: number, tr: HTMLTableRowElement): void;
    private $_getCellSelector;
    protected _getFirstCell(lm: GridLayoutManager): number;
    protected _getLastCell(lm: GridLayoutManager): number;
    protected _getStartCell(lm: GridLayoutManager): number;
    protected _getEndCell(lm: GridLayoutManager): number;
    private $_refreshCells;
    private $_refreshSpans;
    protected _updateCell(grid: GridBase$1, header: GridHeader$1, model: HeaderCell, cell: HeaderTableCell): void;
    protected _updateGroupCell(grid: GridBase$1, header: GridHeader$1, model: HeaderCell, cell: HeaderTableCell): void;
    private $_canPopupHandleVisible;
    private $_canFilterHandleVisible;
    private $_canSortHandleVisible;
    private $_canCheckHandleVisible;
    private $_canExpanderHandleVisible;
    private $_checkHeight;
    private $_getHeights;
    private $_adjustHeights;
    private $_distributeHeights;
}

/**
 * @internal
 */
declare class TableCell {
    static addEdgeMark(edgeMark: EdgeMark, cell: HeaderTableCell | BodyTableCell, doc: Document): void;
    cell: HTMLTableCellElement;
    layout: CellLayoutItem;
    visible: boolean;
    spanned: boolean;
    rowSpan: number;
    colSpan: number;
    className: string;
    width: number;
    height: number;
    text: any;
    constructor(td: HTMLTableCellElement);
    dispose(): void;
    setColSpan(value: number): TableCell;
    setRowSpan(value: number): TableCell;
    setVisible(value: boolean): TableCell;
    set(colSpan: number, rowSpan: number, visible: boolean): TableCell;
    clear(visible: boolean): TableCell;
    isClickableElt(elt: HTMLElement): boolean;
}
/**
 * @internal
 */
declare class BodyTableCell extends TableCell {
    cellButton: HTMLElement;
    editButtons: HTMLElement[];
    errorIcon: HTMLElement;
    buttons: HTMLElement;
    changedMarker: HTMLElement;
    expander: HTMLElement;
    item: GridItem;
    grouped: boolean;
    rowIndex: number;
    rows: number;
    trow: number;
    tcol: number;
    head: BodyTableCell;
    merged: boolean;
    spanHead: BodyTableCell;
    heighted: boolean;
    buttonsOffset: number;
    template: any;
    marginRight: number;
    style: ColumnStyle;
    renderer2: DataCellRenderer;
    rendererChanged: boolean;
    editor: any;
    valueChanged: boolean;
    mouseEntered: boolean;
    focused: boolean;
    borderBottom: number;
    readonly: boolean;
    editable: boolean;
    error: any;
    errorLevel: ValidationLevel;
    errorWidth: number;
    button: CellButton;
    buttonWidth: number;
    editorType: string;
    editWidth: number;
    numberFormatter: DecimalFormatter;
    datetimeWriter: DateTimeWriter;
    booleanFormatter: BooleanFormatter;
    textFormatter: TextFormatter;
    prefix: string;
    suffix: string;
    edgeMarker: HTMLElement;
    edgeMark: EdgeMark;
    constructor(td: HTMLTableCellElement);
    dispose(): void;
    get dataColumn(): DataColumn;
    reset(td: HTMLTableCellElement): BodyTableCell;
    span(head: BodyTableCell): void;
    refreshFormatters(cs: ColumnStyle): void;
    setClassName(value: string): boolean;
    setEditor(cfg1: any, cfg2: any): void;
    setBorderBottom(value: number): void;
    setMarginRight(dom: HTMLElement, value: number): void;
    isCellButton(dom: any): boolean;
    isEditButton(dom: any): boolean;
    isButton(dom: any): boolean;
    resetButtonClass(): void;
    resetEditClass(button: HTMLElement, cnt: number): void;
    resetErrorClass(): void;
    clearExpander(): void;
    clearButtons(): void;
    getEditIndex(index: CellIndex): CellIndex;
    contains(index: CellIndex): boolean;
    toString(): string;
}
/** @internal */
declare class GridBodyElement extends DataTableElement {
    private _itemViews;
    private _cells;
    private _spanned;
    constructor(doc: Document, model: GridBody);
    protected _doDispose(): void;
    get fixed(): boolean;
    get rightFixed(): boolean;
    get firstCell(): BodyTableCell;
    get lastCell(): BodyTableCell;
    get spanned(): boolean;
    bodyCellByCell(cell: HTMLTableCellElement): BodyTableCell;
    bodyCellAt(index: CellIndex): BodyTableCell;
    layoutByCell(cell: HTMLTableCellElement): CellLayoutColumnItem;
    columnByCell(cell: HTMLTableCellElement): GridColumn;
    cellByLayout(layout: CellLayoutItem, rowFrom?: number, colFrom?: number): BodyTableCell;
    getCellRectAt(lm: GridLayoutManager, index: CellIndex, checkMerging: boolean): Rectangle;
    getCellRect(lm: GridLayoutManager, cell: BodyTableCell, checkMerging: boolean): Rectangle;
    getRowView(item: GridItem): GridElement;
    getRowIndex(tr: number): number;
    getViewIndex(tr: number): number;
    cleanRows(itemCount: number, trowCount: number): void;
    getCheckedLayout(cell: BodyTableCell): BodyTableCell;
    getLowerOf(cell: BodyTableCell): BodyTableCell;
    isBottomCell(cell: BodyTableCell): boolean;
    getUpperOf(cell: BodyTableCell): BodyTableCell;
    isTopCell(cell: BodyTableCell): boolean;
    getNextVisibleCell(index: CellIndex): boolean;
    getPrevVisibleCell(index: CellIndex): boolean;
    tdClone(index: CellIndex): void;
    refreshTdFocused(index: CellIndex, immediate: boolean): void;
    protected _doAttached(parent: VisualElement): void;
    _getCssSelector(): string;
    protected _getTableHidden(): boolean;
    protected _getTableCaption(): string;
    protected _isFixedHeight(lm: GridLayoutManager): boolean;
    protected _getTrs(lm: GridLayoutManager): number;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected $_getTableIndex(lm: GridLayoutManager, row: number): number;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doPrepareTableHead(lm: GridLayoutManager, head: HTMLTableSectionElement): void;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    private $_refreshRowCells;
    layoutRow(info: any, mergeHeads: BodyTableCell[], index: number, tr: number, item: GridItem): void;
    layoutFixedBar(lm: GridLayoutManager, tr: number): number;
    protected _doRender(dom: HTMLElement): void;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _doDrawCell(row: number, col: number, dom: HTMLTableCellElement): void;
    getCellAt(lm: GridLayoutManager, index: CellIndex): BodyTableCell;
    getCellView(lm: GridLayoutManager, index: CellIndex): HTMLTableCellElement;
    spanRight(lm: GridLayoutManager, index: CellIndex): void;
    spanHead(lm: GridLayoutManager, index: CellIndex): void;
    protected _getFirstCell(lm: GridLayoutManager): number;
    protected _getLastCell(lm: GridLayoutManager): number;
    protected _getStartCell(lm: GridLayoutManager): number;
    protected _getEndCell(lm: GridLayoutManager): number;
    private $_removeView;
    private $_borrowView;
    protected createRowElement(): RowElement;
    private $_setFixedBarCellsDisplay;
    private $_setRowCellsDisplay;
    private $_refreshSpans;
    private $_cleanRowViews;
    private $_cutTailBodyCells;
    private $_cleanTableRows;
    private $_resetHeights;
    private $_resetCellStyleHeights;
    private $_resetCellHeights2;
    private $_focusChanged;
    private $_mouseEnteredChanged;
    private $_cellStateChanged;
    private $_buttonZIndexChanged;
    private $_rendererChanged;
}

/** @internal */
declare class ClickData$1 {
    static getData(cellType: GridCellType): ClickData$1;
    static getSub(cellType: GridCellType, subType: GridCellType): ClickData$1;
    static getField(cellType: GridCellType, field: number, fieldName: string): ClickData$1;
    static getItem(cellType: GridCellType, itemIndex: number, dataRow: number): ClickData$1;
    static getLayout(cellType: GridCellType, layout: CellLayoutItem): ClickData$1;
    static getCell(cellType: GridCellType, bodyCell: BodyTableCell): ClickData$1;
    static getGroupFooter(cellType: GridCellType, itemIndex: number, layout: CellLayoutItem): ClickData$1;
    static getSummary(cellType: GridCellType, index: number, layout: CellLayoutItem): ClickData$1;
    static getGroupElt(cellType: GridCellType, groupLevel: number): ClickData$1;
    cellType: GridCellType;
    subType: GridCellType;
    field: number;
    fieldIndex: number;
    fieldName: string;
    itemIndex: number;
    dataRow: number;
    column: string;
    index: number;
    groupLevel: number;
    editable: boolean;
    readOnly: boolean;
}
/** @internal */
declare class GridTool extends VisualTool {
    private _grid;
    private _focusMask;
    private _innerFocusMask;
    private _rowFocusView;
    private _rowBlockMask;
    private _rowBlockStart;
    private _rowBlockEnd;
    protected _skipIndex: CellIndex;
    protected _tempIndex: CellIndex;
    protected _tempInnerIndex: CellIndex;
    constructor(owner: GridContainer, name: string);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    /** focused */
    get focused(): CellIndex;
    setFocused(value: CellIndex, clearSelect: boolean, focusSelect: boolean): boolean;
    layoutChanged(): void;
    resetFocused(): void;
    focusedIndexChanging(newIndex: CellIndex): void;
    focusedIndexChanged(oldIndex: CellIndex, newIndex: CellIndex): void;
    currentRowChanged(oldRow: number, row: number): void;
    getNextRequest(request: EditRequest, hint: any, x: number, y: number): EditRequest;
    protected isMouseEventTarget(elt: VisualElement): boolean;
    _doSetFocus(target?: HTMLElement): void;
    _doFocusLeave(event: Event): void;
    protected _doLayoutChanged(): void;
    private $_resetFocusView;
    private $_resetRowBlockMask;
    protected $_resetFocusButton(index: CellIndex): void;
    protected _doCancel(grid: GridBase$1): void;
    protected _doEnter(grid: GridBase$1, options: EditOptions, focused: CellIndex, event: KeyboardEvent): boolean;
    protected _doTab(grid: GridBase$1, options: EditOptions, focused: CellIndex, ctrl: boolean, shift: boolean, event: any): boolean;
    protected _getNextVisible(grid: GridBase$1, index: CellIndex): void;
    protected _getPrevVisible(grid: GridBase$1, index: CellIndex): void;
    protected _checkReadOnly(index: CellIndex): boolean;
    protected _skipReadOnly(index: CellIndex, dx: number): boolean;
    protected _skipReadOnlyCell(index: CellIndex, dx: number, limit?: CellIndex): boolean;
    protected _commitCancel(item: GridItem, options: EditOptions): boolean;
    protected _doColumnHeaderClicked(event: Event, layout: CellLayoutItem): void;
    protected _editButtonClicked(index: CellIndex, event: Event): void;
}

/** @internal */
declare abstract class SummaryExpressionRuntime extends ExpressionRuntime {
    protected static readonly ID_COUNT = 0;
    protected static readonly ID_SUM = 1;
    protected static readonly ID_MAX = 2;
    protected static readonly ID_MIN = 3;
    protected static readonly ID_AVG = 4;
    protected static readonly ID_VAR = 5;
    protected static readonly ID_VARP = 6;
    protected static readonly ID_STDEV = 7;
    protected static readonly ID_STDEVP = 8;
    protected static readonly ID_DATA_COUNT = 9;
    protected static readonly ID_DATA_AVG = 10;
    protected static readonly IDENTS: {
        [key: string]: number;
    };
    constructor();
    protected _doDispose(): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
    protected abstract _getCount(): number;
    protected abstract _getSum(): number;
    protected abstract _getMax(): number;
    protected abstract _getMin(): number;
    protected abstract _getAvg(): number;
    protected abstract _getVar(): number;
    protected abstract _getVarp(): number;
    protected abstract _getStdev(): number;
    protected abstract _getStdevp(): number;
    protected abstract _getDataCount(): number;
    protected abstract _getDataAvg(): number;
}
/** @internal */
declare class ColumnSummaryRuntime extends SummaryExpressionRuntime {
    private _grid;
    private _ds;
    protected _column: DataColumn;
    private _summarizer;
    private _fieldCount;
    constructor();
    protected _doDispose(): void;
    setColumn(column: DataColumn, summarizer: GridSummarizer): void;
    isIdentifier(token: string): number;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
    protected _getCount(): number;
    protected _getSum(): number;
    protected _getMax(): number;
    protected _getMin(): number;
    protected _getAvg(): number;
    protected _getVar(): number;
    protected _getVarp(): number;
    protected _getStdev(): number;
    protected _getStdevp(): number;
    protected _getDataCount(): number;
    protected _getDataAvg(): number;
}
/** @internal */
declare class RowGroupSummaryRuntime extends ColumnSummaryRuntime {
    private _item;
    constructor();
    protected _doDispose(): void;
    /** item */
    get item(): GroupItem;
    setItem(value: GroupItem): void;
    protected _getCount(): number;
    protected _getSum(): number;
    protected _getMax(): number;
    protected _getMin(): number;
    protected _getAvg(): number;
    protected _getVar(): number;
    protected _getVarp(): number;
    protected _getStdev(): number;
    protected _getStdevp(): number;
    protected _getDataCount(): number;
    protected _getDataAvg(): number;
}

/**
 * @internal
 */
declare class RowGroupBarPane extends DataContentPane {
    private _headView;
    private _footView;
    private _barContainer;
    constructor(doc: Document);
    protected _doDispose(): void;
    get levelCount(): number;
    getLevelIndent(level: number): number;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _getCssSelector(): string;
}
/**
 * @internal
 */
declare class RowGroupHeaderElement extends GridElement implements GridItemElement {
    private _item;
    private _cellView;
    constructor(doc: Document);
    protected _doDispose(): void;
    /** item */
    get item(): GroupItemImpl;
    set item(value: GroupItemImpl);
    /** itemIndex */
    get itemIndex(): number;
    protected _initDom(dom: HTMLElement): void;
    _getCssSelector(): string;
    protected _doLayoutContent(lm: GridLayoutManager): void;
}
/**
 * @internal
 */
declare class RowGroupElement extends LayerElement {
    private _headerPool;
    private _headerViews;
    private _rightHeaderPool;
    private _rightHeaderViews;
    private _footerPool;
    private _footerViews;
    private _fixedFooterPool;
    private _fixedFooterViews;
    private _rightFooterPool;
    private _rightFooterViews;
    protected _bodyView: TableBaseElement;
    protected _fixedView: TableBaseElement;
    protected _rightView: TableBaseElement;
    private _indents;
    constructor(doc: Document, name?: string);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridView$1;
    layout(lm: GridViewLayoutManager): void;
    getHeaderView(item: GridItem): RowGroupHeaderElement;
    protected _initDom(dom: HTMLElement): void;
    protected _getCssSelector(): string;
    protected _doDraw(dom: HTMLElement): void;
    protected _doPrepareContent(lm: GridViewLayoutManager): void;
    private $_prepareIndents;
    protected _doLayoutContent(lm: GridViewLayoutManager): void;
    private $_prepareHeaders;
    /**
     * GridViewLayoutManager에서 호출한다.
     */
    private $_prepareGroupItems;
    /**
     * GridViewLayoutManager에서 호출한다.
     */
    private $_prepareGroupFooters;
    private $_getTableRow;
    private $_getTableCell;
    private $_getFixedTableRow;
    private $_getFixedTableCell;
    private $_getRightTableRow;
    private $_getRightTableCell;
    private $_getBodyCells;
    private $_getFixedBodyCells;
    private $_getRightBodyCells;
}

/**
 * 행 그룹핑에 관련된 설정 모델
 *
 * @remarks
 * 행 그룹핑은 데이터 행들을 하나 이상의 지정한 컬럼의 값을 기준으로 구분 시켜 계층적인 구조로 표시한다.
 *
 * @internal
 */
declare class GroupingOptions$1 extends GridBaseOptions implements GroupingOptions {
    private _enabled;
    private _prompt;
    private _expandWhenGrouping;
    private _summarizing;
    private _commitBeforeGrouping;
    private _commitBeforeExpand;
    private _commitBeforeCollapse;
    private _fixMergedColumns;
    private _toast;
    private _headerClickable;
    constructor(grid: GridView$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 그룹핑 활성화 여부
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    /**
     * 패널에 표시될 메시지
     *
     * @defaultValue `'컬럼 헤더를 이 곳으로 끌어다 놓으면 그 컬럼으로 그룹핑합니다.'`
     */
    get prompt(): string;
    set prompt(value: string);
    /**
     * 그룹핑 시 그룹의 펼침 여부
     *
     * @defaultValue `true`
     */
    get expandWhenGrouping(): boolean;
    set expandWhenGrouping(value: boolean);
    /**
     * ?
     *
     * @defaultValue `true`
     *
     * @alpha
     */
    get summarizing(): boolean;
    set summarizing(value: boolean);
    /**
     * 그룹핑 전 커밋 여부
     *
     * @defaultValue `true`
     */
    get commitBeforeGrouping(): boolean;
    set commitBeforeGrouping(value: boolean);
    /**
     * 그룹 펼치기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    get commitBeforeExpand(): boolean;
    set commitBeforeExpand(value: boolean);
    /**
     * 그룹 접기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    get commitBeforeCollapse(): boolean;
    set commitBeforeCollapse(value: boolean);
    /**
     * 머지 된 컬럼 고정 여부
     * @defaultValue `true`
     * @alpha
     */
    get fixMergedColumns(): boolean;
    set fixMergedColumns(value: boolean);
    /**
     * True면 group header 영역을 더블클릭해서 expand/collapse할 수 있다.
     */
    get headerClickable(): boolean;
    set headerClickable(value: boolean);
    /**
     * toast 관련 설정
     *
     * @defaultValue `{visible: false, message: "Grouping..."}`
     */
    get toast(): ToastOptions$1;
    /**
     * @internal
     */
    protected _changed(): void;
}

/** @internal */
declare class GroupPanelElement extends VisualObjectElement {
    private _minHeight;
    private _messageView;
    private _itemViews;
    private _count;
    private _padHorz;
    private _padVert;
    private _itemGap;
    constructor(doc: Document, model: RowGroup$1);
    protected _doDispose(): void;
    /** minHeight */
    get minHeight(): number;
    set minHeight(value: number);
    _getCssSelector(): string;
    protected _initDom(dom: HTMLElement): void;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doPrepareContent(lm: GridLayoutManager): void;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doDraw(element: HTMLElement): void;
    protected _visibleChanged(): void;
    protected _doSizeChanged(): void;
    private $_prepareItemViews;
}

/**
 * @internal
 */
declare class WaiOptions extends GridBaseOptions {
    private _title;
    private _description;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /**
     *
     */
    get title(): string;
    set title(value: string);
    get description(): string;
    set description(value: string);
    getDescription(): string;
}

/** @internal */
declare class GridView$1 extends GridBase$1 {
    static readonly PAGE_CHANGING = "onGridViewPageChanging";
    static readonly PAGE_CHANGED = "onGridViewPageChanged";
    static readonly PAGE_COUNT_CHANGED = "onGridViewPageCountChanged";
    static readonly GROUPING = "onGridViewGrouping";
    static readonly GROUPED = "onGridViewGrouped";
    static readonly EXPANDING = "onGridViewExpanding";
    static readonly EXPANDED = "onGridViewExpanded";
    static readonly COLLAPSING = "onGridViewCollapsing";
    static readonly COLLAPSED = "onGridViewCollapsed";
    private _rs;
    private _rowGroup;
    private _groupingOptions;
    private _groupPanelView;
    private _groupBarPane;
    private _groupView;
    private _rowGroupSummaryRuntime;
    constructor(container: GridContainer, accessibility: boolean, waiOptions: WaiOptions);
    _doDispose(): void;
    protected _doCreateOtherElements(): void;
    /** maxRowCount */
    get maxRowCount(): number;
    set maxRowCount(value: number);
    /** rowGroup */
    get rowGroup(): RowGroup$1;
    /** groupPanelView */
    get groupPanelView(): GroupPanelElement;
    /** groupBarPane */
    get groupBarPane(): RowGroupBarPane;
    /** groupView */
    get groupView(): RowGroupElement;
    /** groupingOptions */
    get groupingOptions(): GroupingOptions$1;
    /** paged */
    get paged(): boolean;
    /** page */
    get page(): number;
    set page(value: number);
    /** pageCount */
    get pageCount(): number;
    set pageCount(value: number);
    set pageSorting(value: boolean);
    /** rowGroupLevels */
    get rowGroupLevels(): number;
    /** rowGroupFields */
    get rowGroupFields(): number[];
    /** rowGrouped */
    get rowGrouped(): boolean;
    /** mergedRowGrouped */
    get mergedRowGrouped(): boolean;
    /** rowGroupSummaryRuntime */
    get rowGroupSummaryRuntime(): RowGroupSummaryRuntime;
    isTree(): boolean;
    protected _beforeChangeLayout(): void;
    isGrouped(column: DataColumn): boolean;
    isGroupedField(field: number): boolean;
    isSortByLabelColumn(field: number): boolean;
    getGroupLevel(field: number): number;
    groupByFieldNames(fieldNames: string[], sorting?: boolean, direction?: SortDirection): void;
    groupBy(fields: number[], sorting: boolean, direction: SortDirection): void;
    clearGroupBy(): void;
    ungroupBy(): void;
    addGroupBy(index: number, column: DataColumn): void;
    removeGroupByField(field: number): void;
    removeGroupBy(column: DataColumn): void;
    expand(group: GroupItem, recursive: boolean, force: boolean, level: number): void;
    expandAll(recursive: boolean, level: number): void;
    collapse(group: GroupItem, recursive: boolean, force: boolean): void;
    collapseAll(recursive: boolean): void;
    isGroupedColumn(column: DataColumn): boolean;
    getSortFields(): number[];
    getSortDirections(): SortDirection[];
    getSortCases(): SortCase[];
    setPaging(paging: boolean, pageSize?: number, pageCount?: number): void;
    setPage(newPage: number, startItem?: number): void;
    getPageOfDataRow(dataRow: number): number;
    get isLayer(): boolean;
    get summarizer(): GridSummarizer;
    protected _createSidePane(): ContentPane;
    isSidePaneVisible(): boolean;
    protected _createLayoutManager(): GridLayoutManager;
    canGrouping(): boolean;
    protected _canMerge(): boolean;
    get undoable(): boolean;
    set undoable(value: boolean);
    get canUndo(): boolean;
    get canRedo(): boolean;
    get undoing(): boolean;
    get redoing(): boolean;
    undo(): boolean;
    redo(): boolean;
    execute(command: EditCommand): void;
    clearCommandStack(all?: boolean): void;
    getRowView(bodyView: GridBodyElement, item: GridItem): GridElement;
    _doSortItems(fields: number[], directions: SortDirection[], textCases: SortCase[]): void;
    _doColumnFiltersChanged(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    setOptions(source: ConfigObject): void;
    protected _visualObjectChanged(obj: VisualObject): void;
    resetCheckables(): void;
    applyCheckables(): void;
    getCheckedRows(sort: boolean, visibleOnly: boolean, allRows: boolean): number[];
    getCheckedItemIndices(allItems: boolean): number[];
    getCheckedItems(allItems: boolean): GridItem[];
    /**
     * merge된 셀의 itemIndex를 return한다.
     */
    getMergedItems(itemIndex: number, column: string | DataColumn, dataOnly?: boolean, force?: boolean): number[];
    findGroupItem(item: GridItem, field: number): GroupItem;
    getItemOfModel(model: any): GridItem;
    getJsonRows(): object[];
    getIndicatorIndex(item: GridItem): number;
    getFirstRow(): GridItem;
    getLastRow(): GridItem;
    getPrevRow(item: GridItem): GridItem;
    getNextRow(item: GridItem): GridItem;
    canMoveRows(items: GridItem[], checkItems: boolean, target: GridItem): boolean;
    protected _getMoveTarget(eventFrom: EventFrom, items: GridItem[], r: number, delta: number): GridItem;
    protected _doMoveRows(items: GridItem[], before: GridItem): boolean;
    protected _getCellTypeOf(view: TableBaseElement): GridCellType;
    updatePastedRow(item: GridItem, values: any[], strict: boolean): void;
    appendPastedRow(values: any[]): void;
    getSummaryCount(type: SummaryItemType): number;
    protected _createItemSource(): GridItemProvider;
    private $_rowGroupChanged;
    protected _groupingOptionsChanged(options: GroupingOptions$1): void;
    private $_rowGroupAdornmentsChanged;
    private $_getVisibleRootByField;
    private $_clearColumnMergeGrouped;
    protected _doRowGroupMergeModeChanged(): void;
    private $_doRowGroupFooterMergeChanged;
    private $_doGroupBy;
    private $_doAddGroupBy;
    private $_clearGroupedIndices;
    private $_setGroupedIndices;
    private $_firePageChanging;
    private $_firePageChanged;
    private $_firePageCountChanged;
    private $_fireGrouping;
    private $_fireGrouped;
    private $_fireExpanding;
    private $_fireExpanded;
    private $_fireCollapsing;
    private $_fireCollapsed;
    onGroupedItemProviderGrouping(rs: GroupedItemProvider, fields: number[]): boolean;
    onGroupedItemProviderGrouped(rs: GroupedItemProvider): void;
    onGroupedItemProviderExpand(rs: GroupedItemProvider, group: GroupItem): boolean;
    onGroupedItemProviderExpanded(rs: GroupedItemProvider, group: GroupItem): void;
    onGroupedItemProviderCollapse(rs: GroupedItemProvider, group: GroupItem): boolean;
    onGroupedItemProviderCollapsed(rs: GroupedItemProvider, group: GroupItem): void;
}
/**
 * @internal
 */
declare class GridViewLayoutManager extends GridLayoutManager {
    constructor(grid: GridView$1);
    /** panelVisible */
    get panelVisible(): boolean;
    getLevelIndent(level: number): number;
    get grid(): GridView$1;
    get topPanelVisible(): boolean;
    get rowGrouped(): boolean;
    get mergedRowGrouped(): boolean;
    get rowGroupLevels(): number;
    get rowGroupFields(): number[];
    private $_groupView;
    /**
     * layout없이 content만 이동할 때.
     */
    setLeftPos(bounds: Rectangle, pos: number): void;
    protected _prepareItems(autoRowHeights?: boolean): void;
    protected _doMeasureTopPane(grid: GridBase$1, bounds: Rectangle): void;
    protected _doLayoutTopPane(grid: GridBase$1, pane: ContentPane): void;
    protected _doLayout(grid: GridBase$1, bounds: Rectangle): void;
    protected _adjustLayout(grid: GridBase$1, bounds: Rectangle): void;
    isMergedCell(index: CellIndex): boolean;
    private $_layoutRowGroupView;
}

/** @internal */
declare class RowGroupHeaderCell extends GridCell {
    private _rowGroup;
    constructor(rowGroup: RowGroup$1);
    protected _doDispose(): void;
    get text(): string;
    get value(): any;
}
/** @internal */
declare class RowGroupFooterCell extends GridCell {
    private static $_getValue;
    static getValue(item: GridItem, column: DataColumn): any;
    private static $_displayText;
    private _rowGroup;
    private _footerIndex;
    private _value;
    private _error;
    private _errorDetail;
    constructor(rowGroup: RowGroup$1);
    protected _doDispose(): void;
    get footerIndex(): number;
    calculate(item?: GridItem): void;
    getDisplayText(cf: CellFormatter): string;
    getSummary(): ColumnSummary;
    getTemplate(cf: CellFormatter): string;
    get value(): any;
    get level(): number;
    setIndex(index: CellIndex): void;
    private _getSummary;
}
/** @internal */
declare class RowGroupBarCell extends GridCell {
    private _level;
    constructor();
    /** level */
    get level(): number;
    get getText(): string;
    get value(): any;
}
/** @internal */
declare type GroupFooterStyleCallback = (grid: GridBase$1, itemIndex: number, footerIndex: number) => string;
/** @internal */
declare class RowGroupFooter extends Base {
    private _styleName;
    private _exportStyleName;
    private _styleCallback;
    private _cellStyleCallback;
    private $_owner;
    private _index;
    constructor(owner: RowGroupFooterCollection);
    protected _doDispose(): void;
    get index(): number;
    /**
     * styleName.
     */
    get styleName(): string;
    set styleName(value: string);
    /** exportStyleName */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    /**
     * styleCallback.
     */
    get styleCallback(): GroupFooterStyleCallback;
    set styleCallback(value: GroupFooterStyleCallback);
    /**
     * 셀 스타일을 지정하기 위한 콜백
     */
    get cellStyleCallback(): CellStyleCallback;
    set cellStyleCallback(value: CellStyleCallback);
    protected _changed(): void;
}
/** @internal */
interface RowGroupFooterOwner {
    rowGroupFooterChanged(footer?: RowGroupFooter): void;
}
/** @internal */
declare class RowGroupFooterCollection extends Base {
    private _owner;
    private _items;
    constructor(owner: RowGroupFooterOwner);
    protected _doDispose(): void;
    /** owner */
    get owner(): RowGroupFooterOwner;
    /** count */
    get count(): number;
    set count(value: number);
    get(index: number): RowGroupFooter;
    assignFrom(source: any): void;
    private $_itemChanged;
}
/**
 * 행 그룹 Header에 표시되는 Text를 return 하는 Callback
 * @remarks
 * {@link RowGroup.headerCallback} 에서 사용되는 형식이다.
 * {@link RowGroup.headerStatement}가 있는 경우 무시된다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨롤롤
 *
 * `group` - 그룹 아이템
 *
 *
 * @example
 * ```js
 * gridView.rowGroup.headerStatement = undefined;
 * gridView.rowGroup.headerCallback = function(grid, group) {
 *      var ds = grid.getDataSource()
 *      if (group.level === 1) {
 *          return ds.getOrgFieldName(group.groupField) + " - " + group.firstDataItem.getData(group.groupField) + " - " + group.descendantCount + " rows"
 *      } else if (group.level === 2) {
 *          var sum = group.getSum("number");
 *          return isNaN(sum) ? "합계 없음" : ("합계 => "+ sum.toString());
 *      } else {
 *          return "GroupLevel => "+group.level.toString()
 *      }
 * 	}
 * ```
 */
declare type HeaderCallback = (grid: GridView$1, group: GroupItem) => string;
/**
 * 그룹 expander의 visible 여부를 return 하는 callback
 *
 * @remarks
 * {@link RowGroup.expanderVisibleCallback} 에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 * `grid` - GridBase 컨롤롤
 *
 * `group` - 그룹 아이템
 *
 * @example
 * ```js
 * gridView.rowGroup.expanderVisibleCallback = function(grid, group) {
 *      // 2 level인 group만 expander를 표시한다.
 *      return group.level === 2;
 * 	}
 * ```
 */
declare type ExpanderVisibleCallback = (grid: GridView$1, group: GroupItem) => boolean;
/**
 * 행 그룹핑과 관련된 영역들의 표시 방법 등에 대한 설정 모델
 *
 * @remarks
 * 외부에 노출하는 api는 별도의 interface 작성
 *
 * @internal
 *
 */
declare class RowGroup$1 extends VisualObject implements RowGroupFooterOwner, GroupFooterCounter {
    static readonly FOOTER_CELL_STYLE = "rg-rowgroup-footer-cell";
    static readonly FOOTER_CELL_RENDERER = "rg-rowgroup-footer-renderer";
    private _footers;
    private _mergeMode;
    private _sorting;
    private _expandedAdornments;
    private _collapsedAdornments;
    private _createFooterCallback;
    private _indentVisible;
    private _levelIndent;
    private _mergeHeaderIndenting;
    private _mergeFooterIndenting;
    private _headerStatement;
    private _headerCallback;
    private _footerStatement;
    private _mergeExpanderVisibility;
    private _expanderVisibleCallback;
    private _valueForGroupCallback;
    private _headerCell;
    private _footerCell;
    private _barCell;
    private _headerStatementExpr;
    private _footerStatementExpr;
    private _statementRuntime;
    private _counterAware;
    private _footerFormatter;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * @internal
     */
    rowGroupFooterChanged(footer?: RowGroupFooter): void;
    /**
     * @internal
     */
    getGroupFooterCount(group: GroupItem): number;
    /**
     * @internal
     */
    setCounterAware(obj: GroupFooterCounterAware): void;
    /**
     * 그룹핑 된 컬럼의 머지 표현 여부
     *
     * @defaultValue `false`
     */
    get mergeMode(): boolean;
    set mergeMode(value: boolean);
    /**
     * 자동 정렬 여부
     *
     * @remarks
     * `false`로 설정하면 행 그룹 시 자동으로 정렬되지 않고 그리드에 표시된 데이터의 순서대로 행 그룹핑 된다.
     */
    get sorting(): boolean;
    set sorting(value: boolean);
    /**
     * 행 그룹이 펼쳐진 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.BOTH}
     */
    get expandedAdornments(): RowGroupAdornments;
    set expandedAdornments(value: RowGroupAdornments);
    /**
     * 행 그룹이 접힌 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.HEADER}
     */
    get collapsedAdornments(): RowGroupAdornments;
    set collapsedAdornments(value: RowGroupAdornments);
    /**
     * 특정 그룹 푸터의 표시 여부를 지정하기 위한 콜백
     *
     * @remarks
     * {@link RowGroup.mergeMode } 가 `true` 인 경우 일부 그룹 푸터의 표시여부를 지정할 수 있다.
     * 표시하길 원하는 경우 `true` 값을 반환한다.
     */
    get createFooterCallback(): CreateFooterCallback;
    set createFooterCallback(value: CreateFooterCallback);
    /**
     * indent 영역 표시 여부.
     * false인 경우 그룹 헤어 text가 level에 맞춰 levelIndent 배 만큼 들여쓰기로 표시된다.
     *
     * @defaultValue true
     */
    get indentVisible(): boolean;
    set indentVisible(value: boolean);
    /**
     * 그룹 레벨 간 들여쓰기 여백
     * indent를 표시하지 않게 하려면 indentVisible을 false로 지정해야 한다.
     *
     * @defaultValue `20`
     */
    get levelIndent(): number;
    set levelIndent(value: number);
    /**
     * 머지 된 헤더의 들여쓰기 여부
     * @alpha
     * @defaultValue `true`
     */
    get mergeHeaderIndenting(): boolean;
    set mergeHeaderIndenting(value: boolean);
    /**
     * 머지 된 푸터의 들여쓰기 여부
     * @alpha
     * @defaultValue `true`
     */
    get mergeFooterIndenting(): boolean;
    set mergeFooterIndenting(value: boolean);
    /**
     * 그룹핑 된 푸터들 정보
     */
    get footers(): RowGroupFooterCollection;
    setFooters(source: any): void;
    /**
     * 헤더에 표시할 문자열 format
     */
    get headerStatement(): string;
    set headerStatement(value: string);
    get headerCallback(): HeaderCallback;
    set headerCallback(value: HeaderCallback);
    /**
     * footerStatement
     */
    get footerStatement(): string;
    set footerStatement(value: string);
    /**
     * expander 표시 여부
     * @defaultValue ExpanderVisibility.DEFAULT
     */
    get mergeExpanderVisibility(): ExpanderVisibility;
    set mergeExpanderVisibility(value: ExpanderVisibility);
    /** expander 표시 callback */
    get expanderVisibleCallback(): ExpanderVisibleCallback;
    set expanderVisibleCallback(value: ExpanderVisibleCallback);
    /** value를 가공해서 group을 묶는다. */
    get valueForGroupCallback(): ValueForGroupCallback;
    set valueForGroupCallback(value: ValueForGroupCallback);
    /**
     * @internal
     */
    getHeaderCell(item: GroupItem): RowGroupHeaderCell;
    /**
     * @internal
     */
    getFooterCell(index: CellIndex): RowGroupFooterCell;
    getFooterStyleName(item: GridItem): string;
    getFooterCellStyle(model: RowGroupFooterCell, cs: ColumnStyle, applyDefault?: boolean): ColumnStyle;
    getFooterCellFormatters(footer: ColumnSummary, cf: CellFormatter): CellFormatter;
    /**
     * @internal
     */
    getBarCell(index: CellIndex): RowGroupBarCell;
    /**
     * @internal
     */
    getHeaderText(group: GroupItemImpl): string;
    /**
     * @internal
     */
    getFooterText(group: GroupItemImpl): string;
    /**
     * @internal
     */
    protected _doChanged(): void;
    private $_isMultiLine;
    private $_isMergeExpanderVisible;
}

/** @internal */
interface GroupFooterCounter {
    getGroupFooterCount(group: GroupItem): number;
    setCounterAware(obj: GroupFooterCounterAware): void;
}
/** @internal */
interface GroupFooterCounterAware {
    groupfFooterCounterChanged(counter: GroupFooterCounter): void;
}
/**
 * 특정 그룹 푸터의 표시 여부를 지정하기 위한 콜백 형식
 *
 * @remarks
 * {@link RowGroup.createFooterCallback} 에서 사용되는 형식이다.
 *
 * [매개변수 목록]
 * `owner` - GridBase 컨롤롤
 *
 * `group` - 그룹 아이템
 *
 * `footerIndex` - 푸터 콜렉션 내에서의 인덱스
 *
 * @example
 * ```js
 * createFooterCallback: function(owner, group, footerIndex) {
 * 		if (group.level >= 5) { return false }
 * 		if (group.level === 4) {
 * 			let relation2 = owner.getDataSource().getValue(group.firstItem.dataRow, "relation2");
 * 			return relation2 === "친족"
 * 		}
 * 		if (group.level === 3) {
 * 			let relation1 = owner.getDataSource().getValue(group.firstItem.dataRow, "relation1");
 * 			return relation1 === "동일인측"
 * 		}
 * 		return true;
 * 	}
 * ```
 */
declare type CreateFooterCallback = (owner: any, group: GroupItem, footerIndex: number) => boolean;
/**
 * @internal
 *
 * 동일한 값이 아니지만 하나의 그룹으로 묶을때 기준이 되는 값을 개발자가 지정할때 사용한다.
 * field의 dataType과 동일한 dataType으로 return 해야한다.
 *
 * @remarks
 * {@link RowGroup.valueForGroupCallback}에서 사용되는 형식이다.
 * [매개변수 목록]
 * `owner` - GridBase 콘트롤
 *
 * `dataRow` - dataRow
 *
 * `fieldName` - fieldName
 *
 * `value` - value
 *
 * @example
 * ```js
 * valueForGroupCallback = function(grid, dataRow, fieldName, value) {
 *		if (value && fieldName === 'date1') {// 특정 field에만 적용.
            // Date형식의 data를 년도와 월을 이용해서 그룹으로 묶는다.
 *			return new Date(value.getFullYear(), value.getMonth());
 *		};
 *		return value;
 * }
 * ```
 */
declare type ValueForGroupCallback = (owner: any, dataRow: number, fieldName: string, value: any) => any;
/** @internal */
declare class GroupedItemProvider extends ProxyItemProvider implements GroupFooterCounterAware {
    static readonly GROUPING = "onGroupedItemProviderGrouping";
    static readonly GROUPED = "onGroupedItemProviderGrouped";
    static readonly EXPAND = "onGroupedItemProviderExpand";
    static readonly EXPANDED = "onGroupedItemProviderExpanded";
    static readonly COLLAPSE = "onGroupedItemProviderCollapse";
    static readonly COLLAPSED = "onGroupedItemProviderCollapsed";
    private _footerCounter;
    private _expandedAdornments;
    private _collapsedAdornments;
    private _footerCallback;
    private _indentVisible;
    private _expandWhenGrouping;
    private _mergeMode;
    private _summaryMode;
    private _valueForGroupCallback;
    private _callbackOnwer;
    private _visibleItems;
    private _groupFields;
    private _groupSorting;
    private _grouped;
    private _editItem;
    constructor(source: ItemProvider, indexing: boolean);
    protected _doDispose(): void;
    groupfFooterCounterChanged(count: GroupFooterCounter): void;
    private $_footerCounterChanged;
    /** treeMode */
    /** footerCounter */
    get footerCounter(): GroupFooterCounter;
    set footerCounter(value: GroupFooterCounter);
    /** expandedAdornments */
    get expandedAdornments(): RowGroupAdornments;
    set expandedAdornments(value: RowGroupAdornments);
    /** collapsedAdornments */
    get collapsedAdornments(): RowGroupAdornments;
    set collapsedAdornments(value: RowGroupAdornments);
    resetAdornments(callbackOwner: any, model: RowGroup$1, force: boolean): void;
    /** expandWhenGrouping */
    get expandWhenGrouping(): boolean;
    set expandWhenGrouping(value: boolean);
    /** mergeMode */
    get mergeMode(): boolean;
    /** summaryMode */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /** grouped */
    get grouped(): boolean;
    get groupCount(): number;
    get groupSorting(): boolean;
    set groupSorting(value: boolean);
    get visibleRowCount(): number;
    get indentVisible(): boolean;
    canGrouping(fields: number[]): boolean;
    groupBy(fields: number[]): void;
    groupByMode(fields: number[], mergeMode: boolean): void;
    isGroupedField(field: number): boolean;
    getGroupLevel(field: number): number;
    get groupedFields(): number[];
    expand(group: GroupItem, recursive: boolean, force: boolean, level: number): void;
    private $_collapseChild;
    collapse(group: GroupItem, recursive: boolean, force: boolean): void;
    collapseAll(recursive: boolean): void;
    expandAll(recursive: boolean, level: number): void;
    findItem(fields: number[], values: any[], options: SearchOptions$1, startIndex: number, endIndex: number): number;
    findCell(fields: number[], value: any, options: any, startIndex: number, endIndex: number, startFieldIndex: number): any;
    getGroupItem(id: number): any;
    get itemCount(): number;
    getItem(index: number, dataOnly?: boolean): GridItem;
    getItems(index: number, count: number): GridItem[];
    getAllItems(): GridItem[];
    getIndexOfRow(dataRow: number): number;
    getItemOfRow(dataRow: number, force: boolean): GridItem;
    protected _initialize(): void;
    protected _clearItems(): void;
    protected _populateItems(): void;
    _resetItemIndicies(fromIndex: number): void;
    _clearChecked(): void;
    checkAll(checked: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent: boolean, groupCheckable: boolean): void;
    getItemChecked(item: GridItem, checked: boolean): boolean;
    setItemChecked(item: GridItem, checked: boolean): boolean;
    getFirstRow(): GridRow;
    getLastRow(): GridRow;
    getPrevRow(item: GridItem): GridRow;
    getNextRow(item: GridItem): GridRow;
    private $_saveExpand;
    private $_restoreExpand;
    private $_populateItems;
    private $_checkChildren;
    private $_getItem;
    private $_resetVisibleItems;
    private $_buildGroupItems;
    private $_resetDisplayLevels;
    private $_buildGroups;
    private $_buildItems;
    private $_setEditItem;
    private $_setDummyEditItem;
    private fireGrouping;
    private fireGrouped;
    private fireExpand;
    private fireExpanded;
    private fireCollapse;
    private fireCollapsed;
    onItemProviderRefresh(rs: ItemProvider): void;
    onItemProviderItemInserted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemDeleted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemUpdated(rs: ItemProvider, item: GridItem): void;
}

/**
 * 인디케이터에 표시될 내용 종류
 */
declare enum IndicatorValue {
    /**
     * 없음
     */
    NONE = "none",
    /**
     * 행 순서
     */
    INDEX = "index",
    /**
     * 행 고유 번호
     */
    ROW = "row"
}
/**
 * 상태바의 상태 표시 방법
 */
declare enum StateMark {
    /**
     * 이미지
     */
    IMAGE = "image",
    /**
     * 텍스트
     */
    TEXT = "text",
    /**
     * 없음
     */
    NONE = "none"
}
/**
 * @internal
 * 그리드의 인디케이터에 관한 설정 모델
 *
 * @remarks
 * 인디케이터는 행 index를 표시하거나, focus 된 행의 위치 등을 표시한다.
 */
declare class RowIndicator$1 extends SectionObject implements RowIndicator {
    private _displayValue;
    private _zeroBase;
    private _indexOffset;
    private _rowOffset;
    private _minWidth;
    private _maxWidth;
    private _width;
    private _selectable;
    private _mark;
    private _showFocus;
    private _showSelection;
    private _displayWidth;
    private _cell;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 인디케이터 셀들에 표시할 내용
     */
    get displayValue(): IndicatorValue;
    set displayValue(value: IndicatorValue);
    /**
     * 인디케이터 숫자가 0부터 시작할 것인지의 여부
     *
     * @defaultValue `false`
     */
    get zeroBase(): boolean;
    set zeroBase(value: boolean);
    /**
     * 인디케이터에 표시될 숫자와 아이템 인덱스(행 순서)와의 간격
     *
     * @remarks
     * 인디케이터 숫자 = 아이템 인덱스 + indexOffset
     *
     * @defaultValue `0`
     */
    get indexOffset(): number;
    set indexOffset(value: number);
    /**
     * 인디케이터에 표시될 숫자와 데이터 행 고유번호와의 간격을 지정
     *
     * @remarks
     * 인디케이터 숫자 = 데이터 행 번호 + rowOffset
     *
     * @defaultValue `0`
     */
    get rowOffset(): number;
    set rowOffset(value: number);
    /**
     * 최소 너비
     *
     * @defaultValue `32`
     */
    get minWidth(): number;
    set minWidth(value: number);
    /**
     * 최대 너비
     *
     * @defaultValue `0`
     */
    get maxWidth(): number;
    set maxWidth(value: number);
    /**
     * 너비
     *
     * @remarks
     * 해당 값이 0을 초과하면 minWidth와 maxWidth는 무시된다.
     *
     * @defaultValue `0`
     *
     */
    get width(): number;
    set width(value: number);
    /**
     * 실제 표시되는 너비
     * @remarks
     * width가 0인경우 그리드의 itemCount에 따라서 너비가 변경된다.
     * 실제 표시되는 너비를 돌려준다.
     */
    get displayWidth(): number;
    /**
     * 선택 가능 여부
     *
     * @defaultValue `true`
     */
    get selectable(): boolean;
    set selectable(value: boolean);
    /**
     * 인디케이터에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    get mark(): StateMark;
    set mark(value: StateMark);
    /**
     * focus 된 행에 해당하는 셀의 스타일 적용여부 여부
     *
     * @remarks
     * `true`면 focus 된 행에 해당하는 셀을 `'rg-rowindicator-focus'` 스타일로 표시한다.
     *
     * @defaultValue `true`
     */
    get showFocus(): boolean;
    set showFocus(value: boolean);
    /**
     * 데이터 선택 영역에 맞춰 관련된 셀들의 스타일 적용 여부
     *
     * @remarks
     * `true`면 데이터 선택 영역에 맞춰 관련된 셀들을 `'rg-rowindicator-select'` 스타일로 표시한다.
     *
     * @defaultValue `false`
     */
    get showSelection(): boolean;
    set showSelection(value: boolean);
    getCellType(): GridCellType;
    get staticOrder(): number;
    /**
     * @internal
     */
    getCell(index: CellIndex): GridCell;
    /**
     * @internal
     */
    getHeadStyleName(): string;
    /**
     * @internal
     */
    getFootStyleName(): string;
    /**
     * @internal
     */
    getSumStyleName(): string;
}

/**
 * {@link CheckBar} 에서 체크 가능 여부를 결정하는 콜백
 *
 * @remarks
 *
 * [매개변수 목록]
 *
 * `dataSource` - DataProvider 컨트롤
 *
 * `item` - 체크의 대상이 되는 아이템 (행 아이템, 헤더 아이템 등)
 *
 * [반환값] - 체크 가능 여부
 *
 * @example
 * ```js
 * const f = function(dataSource, item) {
 *      if (item.value) {
 *          return item.value !== 'doNotCheck';
 *      }
 *      else {
 *          return false;
 *      }
 * }
 * ```
 */
declare type CheckableCallback = (dataSource: any, item: any) => boolean;
/**
 * @internal
 * 체크바와 관련된 설정 모델
 *
 * @remarks
 * 체크바 영역에서 shift를 누른 상태에서 이전의 행이나 이후의 행을 클릭하면 일괄체크
 */
declare class CheckBar$1 extends SectionObject implements CheckBar {
    private _width;
    private _exclusive;
    private _showAll;
    private _showGroup;
    private _visibleOnly;
    private _checkableOnly;
    private _checkableExpression;
    private _checkableCallback;
    private _syncHeadCheck;
    private _useImages;
    private _checkLocation;
    private _itemGap;
    private _fieldName;
    private _fieldIndex;
    private _mergeRule;
    private _mergeRuleObj;
    private _breakMergeOnEmpty;
    private _merges;
    /**

     */
    private _cell;
    private _merged;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    get width(): number;
    set width(value: number);
    /**
     * 한 행만 체크 가능한지의 여부
     *
     * @defaultValue `false`
     */
    get exclusive(): boolean;
    set exclusive(value: boolean);
    get checkLocation(): ColumnHeaderItemLocation;
    set checkLocation(value: ColumnHeaderItemLocation);
    get itemGap(): number;
    set itemGap(value: number);
    /**
     * 체크바 헤드에 “v” 표시 여부
     *
     * @remarks
     * 표시 후 체크 시 전체 체크
     *
     * @defaultValue `true`
     */
    get showAll(): boolean;
    set showAll(value: boolean);
    /**
     * 행 그룹핑시 그룹 헤더 영역에 체크박스 표시 여부
     *
     * @defaultValue `true`
     */
    get showGroup(): boolean;
    set showGroup(value: boolean);
    /**
     * 체크바 헤드를 체크하여 전체선택 시 보이는 행만 체크할 것인지의 여부
     *
     * @defaultValue `true`
     */
    get visibleOnly(): boolean;
    set visibleOnly(value: boolean);
    /**
     * 체크 가능한 행만 체크할 수 있는지의 여부
     *
     * @remarks
     * checkableExpression 에서 체크 가능 여부를 지정할 수 있다.
     *
     * @defaultValue `true`
     */
    get checkableOnly(): boolean;
    set checkableOnly(value: boolean);
    /**
     * 체크 가능 여부의 수식
     */
    get checkableExpression(): string;
    set checkableExpression(value: string);
    /**
     * checkableCallback
     */
    get checkableCallback(): CheckableCallback;
    set checkableCallback(value: CheckableCallback);
    /**
     * 데이터 영역의 전체 item 체크 상태와 체크바의 헤드 연동 여부
     *
     * @remarks
     * 데이터행의 모든 item이 체크되면 Head영역에도 자동으로 체크가 됨
     *
     * @defaultValue `false`
     */
    get syncHeadCheck(): boolean;
    set syncHeadCheck(value: boolean);
    /**
     * DataProvider의 field와 연동
     *
     * @remarks
     * DataProvider의 field 값에 따라 체크가 표시 되도록 한다.
     * 체크/해제를 하면 DataProvider에도 적용된다.
     *
     * @defaultValue `null`
     */
    get fieldName(): string;
    set fieldName(value: string);
    get fieldIndex(): number;
    /**
     *
     * checkBar의 check를 image로 표시한다.
     *
     * @defaultValue false
     */
    get useImages(): boolean;
    set useImages(value: boolean);
    /**
     * mergeRule
     */
    get mergeRule(): string;
    set mergeRule(value: string);
    /**
     * 빈 셀일 때 머지 중단 여부
     *
     * @defaultValue `false`
     */
    get breakMergeOnEmpty(): boolean;
    set breakMergeOnEmpty(value: boolean);
    getCell(index: CellIndex): GridCell;
    getHeadStyleName(): string;
    getFootStyleName(): string;
    getSumStyleName(): string;
    canMerge(): boolean;
    getCellType(): GridCellType;
    get staticOrder(): number;
    get merges(): CheckBarMergeManager;
    get merged(): boolean;
}
/**
 * @internal
 */
declare class IndexRange extends Base {
    static readonly NULL: IndexRange;
    private static readonly $_TEMP;
    private static $_setRange;
    static create(index1: CellIndex, index2?: CellIndex): IndexRange;
    static temp(index1: CellIndex, index2: CellIndex): IndexRange;
    static createRange(r1: number, r2: number): IndexRange;
    private _row1;
    private _row2;
    constructor();
    get empty(): boolean;
    get r1(): number;
    get r2(): number;
    get top(): number;
    get bottom(): number;
    get firstCell(): CellIndex;
    get lastCell(): CellIndex;
    contains(itemIndex: number): boolean;
    intersectsWith(other: IndexRange): boolean;
}
/**
 * @internal
 */
declare class CheckBarMergeRoom extends GridMergeRoom {
    private static readonly $_rooms;
    static borrow(range: IndexRange, checkBar: CheckBar$1): CheckBarMergeRoom;
    static returnTo(room: CheckBarMergeRoom): void;
    private _checkBar;
    private _head;
    private _tail;
    constructor(range: IndexRange, checkBar: CheckBar$1);
    /** head */
    get head(): number;
    /** tail */
    get tail(): number;
    get scope(): any;
    get group(): GroupItem;
    set group(value: GroupItem);
    getHead(index: CellIndex): CellIndex;
    getTail(index: CellIndex): CellIndex;
    isHead(index: CellIndex): boolean;
    isTail(index: CellIndex): boolean;
    contains(index: CellIndex): boolean;
}
/**
 * @internal
 */
declare class CheckBarMergeManager extends Base {
    static readonly MERGE_ROOMS = "mergeRooms";
    private _checkBar;
    private _flags;
    private _fixedRooms;
    private _rooms;
    private _inited;
    private _fixedCells;
    private _cells;
    private _nextId;
    constructor(checkBar: CheckBar$1);
    protected _doDispose(): void;
    /** count */
    get count(): number;
    clear(): void;
    initialize(count: number): void;
    refreshRooms(first: number, last: number, bFixed: boolean): void;
    getFixedRooms(): CheckBarMergeRoom[];
    getRooms(): CheckBarMergeRoom[];
    scroll(delta: number): void;
    getRoom(index: CellIndex): CheckBarMergeRoom;
    prepareCells(fixedRows: number, rows: number): void;
    refreshCells(fixed: number, top: number): void;
    addFixedCells(row: number, count: number): number;
    addCells(row: number, count: number): number;
    isMerged(row: number, fixedRows: number): boolean;
    isMergeRoot(row: number, fixedRows: number): boolean;
    isHidden(row: number, fixedRows: number): boolean;
    getMerged(row: number, fixedRows: number): number;
    getMerged2(grid: GridBase$1, itemIndex: number, row: number, span: number): number;
    private $_checkFixedMerge;
    private $_checkMerge;
}

/**
 * 그리드의 인디케이터에 관한 설정 모델
 *
 * @remarks
 * 인디케이터는 행 index를 표시하거나, focus 된 행의 위치 등을 표시한다.
 *
 * {@link GridBase.setRowIndicator} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setRowIndicator({zeroBase: true});
 * ```
 */
interface RowIndicator {
    /**
     * 인디케이터 셀들에 표시할 내용
     *
     * @defaultValue {@link IndicatorValue.INDEX}
     */
    displayValue?: IndicatorValue;
    /**
     * 인디케이터 숫자가 0부터 시작할 것인지의 여부
     *
     * @defaultValue `false`
     */
    zeroBase?: boolean;
    /**
     * 인디케이터에 표시될 숫자와 아이템 인덱스(행 순서)와의 간격
     *
     * @remarks
     * 인디케이터 숫자 = 아이템 인덱스 + indexOffset
     *
     * @defaultValue `0`
     */
    indexOffset?: number;
    /**
     * 인디케이터에 표시될 숫자와 데이터 행 고유번호와의 간격을 지정
     *
     * @remarks
     * 인디케이터 숫자 = 데이터 행 번호 + rowOffset
     *
     * @defaultValue `0`
     */
    rowOffset?: number;
    /**
     * 최소 너비
     *
     * @defaultValue `32`
     */
    minWidth?: number;
    /**
     * 최대 너비
     *
     * @defaultValue `0`
     */
    maxWidth?: number;
    /**
     * 너비
     *
     * @remarks
     * `0`인경우 표시되는 내용에 따라 너비가 변경된다.
     *
     * @defaultValue `0`
     *
     */
    width?: number;
    /**
     * 실제 표시되는 너비
     *
     * @remarks
     * `width`가 0일때 rowIndicator의 너비
     */
    displayWidth?: number;
    /**
     * 마우스로 클릭 혹은 드래그 시 선택 영역 지정 가능 여부
     *
     * @remarks
     * {@link DisplayOptions.selectionMode} 가 {@link SelectionMode.NONE} 이 아니고, {@link DisplayOptions.selectionStyle} 이 {@link SelectionStyle | single selection style} 이 아니어야 선택 영역 지정이 가능하다.
     *
     * @defaultValue `true`
     */
    selectable?: boolean;
    /**
     * 인디케이터에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    mark?: StateMark;
    /**
     * focus 된 행에 해당하는 셀의 스타일 적용여부 여부
     *
     * @remarks
     * `true`면 focus 된 행에 해당하는 셀을 `'rg-rowindicator-focus'` 스타일로 표시한다.
     *
     * @defaultValue `true`
     */
    showFocus?: boolean;
    /**
     * 데이터 선택 영역에 맞춰 관련된 셀들의 스타일 적용 여부
     *
     * @remarks
     * `true`면 데이터 선택 영역에 맞춰 관련된 셀들을 `'rg-rowindicator-select'` 스타일로 표시한다.
     *
     * @defaultValue `false`
     */
    showSelection?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem$1[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
}
/**
 * 상태바에 표시될 상태 텍스트들 종류
 *
 */
interface StateTexts {
    /**
     * 행이 생성됨
     *
     * @defaultValue `'C'`
     */
    "created"?: string;
    /**
     * 행이 업데이트 됨
     *
     * @defaultValue `'U'`
     */
    "updated"?: string;
    /**
     * 행이 삭제됨
     *
     * @defaultValue `'D'`
     */
    "deleted"?: string;
    /**
     * 행이 생성 후 삭제됨
     *
     * @defaultValue `'X'`
     */
    "createAndDeleted"?: string;
    /**
     * 아무것도 아님
     *
     * @defaultValue `''`
     */
    "none"?: string;
}
/**
 * 행들의 상태를 표시하는 상태바와 관련된 설정 모델
 *
 * {@link GridBase.setStateBar} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setStateBar({errorVisible: true});
 * ```
 */
interface StateBar$1 {
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    width?: number;
    /**
     * 상태바에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    mark?: StateMark;
    /**
     * 상태 바에 표시될 상태 텍스트들
     *
     * @remarks
     * [기본값들 ({@link RowState} 참고)]
     *
     * `'C'`: stateTexts[RowState.CREATED]
     * `'U'`: stateTexts[RowState.UPDATED]
     * `'D'`: stateTexts[RowState.DELETED]
     * `'X'`: stateTexts[RowState.CREATE_AND_DELETED]
     *
     * @example
     * ```js
     * gridView.setStateBar({
     *      stateTexts :{
     *          "created": "신규",
     *          "updated": "수정",
     *          "deleted": "삭제",
     *          "createAndDeleted": "삭제"
     *      }
     * })
     * ```
     */
    stateTexts?: StateTexts;
    /**
     * 오류가 발생 했을 때 상태바에 오류에 해당하는 스타일을 적용할 것인지의 여부
     *
     * @defaultValue `false`
     */
    errorVisible?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem$1[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
}
/**
 * 체크바와 관련된 설정 모델
 *
 * @remarks
 * 체크바 영역에서 shift를 누른 상태에서 이전의 행이나 이후의 행을 클릭하면 일괄체크
 *
 * {@link GridBase.setCheckBar} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setCheckBar({exclusive: true});
 * ```
 */
interface CheckBar {
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    width?: number;
    /**
     * 한 행만 체크 가능한지의 여부
     *
     * @defaultValue `false`
     */
    exclusive?: boolean;
    /**
     * 체크바 헤드에 “v” 표시 여부
     *
     * @remarks
     * 표시 후 체크 시 전체 체크
     *
     * @defaultValue `true`
     */
    showAll?: boolean;
    /**
     * 행 그룹핑시 그룹 헤더 영역에 체크박스 표시 여부
     *
     * @defaultValue `true`
     */
    showGroup?: boolean;
    /**
     * 체크바 헤드를 체크하여 전체선택 시 보이는 행만 체크할 것인지의 여부
     *
     * @defaultValue `true`
     */
    visibleOnly?: boolean;
    /**
     * 체크 가능한 행만 체크할 수 있는지의 여부
     *
     * @remarks
     * checkableExpression 에서 체크 가능 여부를 지정할 수 있다.
     *
     * @defaultValue `true`
     */
    checkableOnly?: boolean;
    /**
     * 체크 가능 여부의 수식
     */
    checkableExpression?: string;
    /**
     * 체크 가능 여부를 결정하는 콜백
     * @eventProperty
     *
     * @remarks
     * `false` 반환 시 체크가 불가능하다.
     *
     * @example
     * ```js
     * const f = function(dataSource, item) {
     *      if (item.value) {
     *          return item.value !== 'doNotCheck';
     *      }
     *      else {
     *          return false;
     *      }
     * }
     *
     * gridView.setCheckBar({checkableCallback: f});
     * ```
     */
    checkableCallback?: CheckableCallback;
    /**
     * 데이터 영역의 전체 item 체크 상태와 체크바의 헤드 연동 여부
     *
     * @remarks
     * 데이터행의 모든 item이 체크되면 Head영역에도 자동으로 체크가 됨
     *
     * @defaultValue `false`
     */
    syncHeadCheck?: boolean;
    /**
     * checkBox의 위치를 지정한다.
     *
     * @remarks
     * headText가 표시될때 checkBox의 위치를 지정한다. checkBar의 너비 또는 {@link GridHeader.height} 높이를 적절히 변경해야 한다.
     *
     * @defaultValue `top`
     */
    checkLocation?: ColumnHeaderItemLocation;
    /**
     * checkBox와 headText의 간격을 지정한다.
     *
     * @defaultValue `5`
     */
    itemGap?: number;
    /**
     * checkBar의 체크상태를 dataField와 연결한다.
     *
     * @defaultValue `null`
     */
    fieldName?: string;
    /**
     * checkBar의 check를 image를 이용해서 표시한다.
     *
     * @defaultValue `false`
     */
    useImages?: boolean;
    /**
     * 체크바, 상태바, 인디케이터 중에서 보여지는 순서 (인덱스)
     *
     * @remarks
     * 숫자가 작을 수록 왼쪽에 배치된다.
     */
    displayOrder?: number;
    /**
     * head 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    headText?: string;
    /**
     * foot 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    footText?: string;
    /**
     * summary 영역에 표시할 텍스트
     *
     * @defaultValue `null`
     */
    sumText?: string;
    /**
     * 팝업 메뉴
     */
    popupMenu?: PopupMenuItem$1[] | string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * CheckBox 머지 규칙
     *
     * @remarks
     * 지정된 field에서 동일한 값을 가지는 행들의 CheckBox를 묶어서 보여지도록 한다.
     *
     * ```js
     * gridView.checkBar.mergeRule = "values['fieldName']";
     * gridView.checkBar.mergeRule = "values['field1'] + values['field2']";
     * ```
     */
    mergeRule?: string;
}
/**
 * 헤더 영역의 설정 모델
 *
 * @remarks
 * {@link GridBase.setHeader} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setHeader({sortable = false});
 * ```
 */
interface GridHeader {
    /**
     * 헤더 행의 최소 높이
     *
     * @defaultValue `21`
     */
    minRowHeight?: number;
    /**
     * 헤더의 최소 높이
     *
     *  @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 헤더의 높이
     *
     * @remarks
     * 1. `0`: 기본 스타일로 tr의 높이를 계산해서 지정(table row의 최소 높이가 됨),
     *    전체 헤더 높이가 커지면 row들이 다 표시되도록 element container의 높이를 보정한다.
     *
     * 2. `0` 초과: 지정한 높이로 전체 높이를 설정, tr 높이는 minRowHeight 높이로 설정한다.
     *    container 높이가 tr들의 높이합보다 큰 경우 배분한다.
     *    container 높이를 보정하지 않는다.
     *
     * 3. `0` 미만: 브라우저가 계산한 높이
     *
     * heights 속성에 각 table row의 높이를 지정할 수 있다.
     *
     * 전체 높이가 minHeight보다 작을 수 없다.
     *
     * 개별 tr의 높이는 minRowHeight보다 작을 수 없다.
     *
     * @defaultValue `0`
     *
     */
    height?: number;
    /**
     * 헤더가 여러줄일때 각행의 높이
     *
     * @remarks
     * 각 table row의 높이를 지정한다.
     *
     * @example
     *
     * ```js
     * gridView.header.heights = [50, 30, 30]
     * ```
    */
    heights?: number[];
    /**
     * 높이 변경 가능 여부
     *
     * @remarks
     * 사용자가 헤더 왼쪽 셀의 위쪽을 마우스 드래깅해서 헤더의 높이를 변경하게 할 것인지의 여부
     *
     * @defaultValue `false`
     */
    resizable?: boolean;
    /**
     * 헤더 테두리와 체크박스나 이미지와의 간격
     *
     * @defaultValue `2`
     */
    itemOffset?: number;
    /**
     * 텍스트와 체크박스나 이미지와의 간격
     *
     * @defaultValue `2`
     */
    itemGap?: number;
    /**
     * 툴팁 표시 여부
     *
     * @remarks
     * 값이 `undefined`인경우 {@link ColumnHeader.showTooltip}이 `true`인 컬럼의 `tooltip`만 표시된다.
     *
     * @defaultValue `false`
     */
    showTooltip?: boolean;
    /**
     * 선택 영역 표시 여부
     *
     * @remarks
     * `true` 시 데이터 선택 영역에 맞춰 관련된 셀들에 선택 영역을 지정한다.
     *
     * @defaultValue `false`
     */
    showSelection?: boolean;
    /**
     * 헤더의 정렬 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    sortWidth?: number;
    /**
     * 헤더의 정렬 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    sortHeight?: number;
    /**
     * 헤더의 필터 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    filterWidth?: number;
    /**
     * 헤더의 필터 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    filterHeight?: number;
    /**
     * 헤더의 팝업 메뉴 {@link HandleVisibility | 핸들} 너비
     *
     * @defaultValue `16`
     */
    popupWidth?: number;
    /**
     * 헤더의 팝업 메뉴 {@link HandleVisibility | 핸들} 높이
     *
     * @defaultValue `16`
     */
    popupHeight?: number;
    /**
     * 헤더에 popupMenuName이 설정된 경우 팝업 메뉴 핸들을 표시한다.
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    showPopupMenu?: HandleVisibility;
    /**
     * 헤더의 체크 박스 너비
     *
     * @defaultValue `16`
     */
    checkWidth?: number;
    /**
     * 헤더의 체크 박스 높이
     *
     * @defaultValue `16`
     */
    checkHeight?: number;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 스타일 명
     */
    styleName: string;
    /**
     * excel로 export될때 적용될 스타일 명
     */
    exportStyleName?: string;
}
/**
 * 행 그룹핑과 관련된 영역들의 표시 방법 등에 대한 설정 모델
 *
 * @remarks
 * {@link GridView.setRowGroup} 사용시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setRowGroup({levelIndent: false});
 * ```
 */
interface RowGroup {
    /**
     * 그룹핑 된 컬럼의 머지 표현 여부
     *
     * @defaultValue `false`
     */
    mergeMode?: boolean;
    /**
     * 자동 정렬 여부
     *
     * @remarks
     * `false`로 설정하면 행 그룹 시 자동으로 정렬되지 않고 그리드에 표시된 데이터의 순서대로 행 그룹핑 된다.
     */
    sorting?: boolean;
    /**
     * 행 그룹이 펼쳐진 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.BOTH}
     */
    expandedAdornments?: RowGroupAdornments;
    /**
     * 행 그룹이 접힌 상태일 때, 그룹 헤더, 푸터의 표시 여부
     *
     * @defaultValue {@link RowGroupAdornments.HEADER}
     */
    collapsedAdornments?: RowGroupAdornments;
    /**
     * 특정 그룹 푸터의 표시 여부를 지정하기 위한 콜백
     *
     * @remarks
     * {@link RowGroup.mergeMode } 가 `true` 인 경우 일부 그룹 푸터의 표시여부를 지정할 수 있다.
     * 표시하길 원하는 경우 `true` 값을 반환한다.
     *
     * @eventProperty
     */
    createFooterCallback?: CreateFooterCallback;
    /**
     * 그룹 레벨 간 들여쓰기 여백
     *
     * @defaultValue `20`
     */
    levelIndent?: number;
    /**
     * 머지 된 헤더의 들여쓰기 여부
     * @alpha
     * @defaultValue `true`
     */
    mergeHeaderIndenting?: boolean;
    /**
     * 머지 된 푸터의 들여쓰기 여부
     * @alpha
     * @defaultValue `true`
     */
    mergeFooterIndenting?: boolean;
    /**
     * expander 표시 여부
     * @defaultValue {@link ExpanderVisibility.DEFAULT}
     */
    mergeExpanderVisibility?: ExpanderVisibility;
    /**
     * expander 표시여부를 결정하는 콜백
     *
     * @eventProperty
     */
    expanderVisibleCallback?: ExpanderVisibleCallback;
    /**
     * 헤더에 표시할 문자열 서식
     * @defaultValue `'${groupField}: ${groupValue} - ${rowCount} rows'`
     */
    headerStatement?: string;
    /**
     * 헤더에 표시할 문자열을 return하는 콜백
     * @remarks
     * {@link RowGroup.headerStatement}가 있는 경우 무시된다.
     *
     * @eventProperty
     */
    headerCallback?: HeaderCallback;
    /**
     * 표시 여부
     */
    visible?: boolean;
}
/**
 * 그리드 Group Panel 표시 정보들에 대한 설정 정보
 *
 * @remarks
 * {@link GridView.setGroupPanel} 사용 시 필요한 정보만 입력하면 된다.
 *
 * @example
 *
 * ```js
 * gridView.setGroupPanel({visible: false});
 * ```
 */
interface GroupPanel {
    /**
     * Group Panel 의 표시 여부
     */
    visible?: boolean;
    /**
     * Group Panel 의 최소 높이
     */
    minHeight?: number;
    /**
     * Group Panel 의 높이
     *
     * @readonly
     */
    height?: number;
}

/**
 * 푸터 영역의 단일 설정 모델
 *
 * @remarks
 *
 * 그리드는 별도의 설정이 없는 경우 하나의 푸터를 자동으로 생성하고 {@link GridBase.footer}는 첫번째 푸터를 반환한다..
 *
 * {@link GridBase.setFooter | setFooter()}를 이용해서 속성을 변경하거나 또는 {@link GridBase.footer}를 이용해서 원하는 속성만 지정한다.
 *
 *  @example
 *
 * ```js
 * gridView.setFooter({styleName: 'custom-footer'});
 * // 또는
 * gridView.footer.styleName = 'custom-footer';
 * ```
 */
interface GridFooter$1 {
    /**
     * 스타일 클래스 이름
     */
    styleName?: string;
    /**
     * 최소 높이
     *
     * @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 높이
     *
     * @remarks
     * `0`이면 자동으로 계산하여 지정한다. `0` 이상이면 minHeight와 비교하여 더 큰 값으로 지정한다.
     *
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 셀 스타일을 지정하기 위한 콜백
     * @eventProperty
     *
     * @remarks
     * `string` 형태의 css 클래스 명 또는 {@link ColumnSummaryStyleObject} 형태로 지정가능하다.
     *
     * @example
     * ```js
     * // 푸터 적용
     * const f = function (grid, cell) {
     *      if (cell.value > 10) {
     *          return {
     *              styleName: 'custom-footer'
     *          }
     *      }
     * }
     * footer.cellStyleCallback = f;
     * ```
     *
     */
    cellStyleCallback?: CellStyleCallback;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 푸터의 콜렉션 내에서의 순서
     *
     * @readonly
     */
    footerIndex?: number;
}
/**
 * 그리드 푸터 영역에 관한 콜렉션 모델
 *
 * @remarks
 *
 * 그리드의 footer를 표시하거나 여러개의 푸터를 생성하고 관리한다.
 *
 * {@link GridBase.footers} 에서 반환되는 객체이다.
 *
 * @example
 * ```js
 * // object
 * gridView.setFooters({
 *      visible: true,
 *      items:[
 *          {
 *              styleName: 'custom-footer-1'
 *          }, {
 *              styleName: 'custom-footer-2'
 *          }
 *      ]
 * })
 * // 또는 array형태로 지정
 * gridView.setFooters([
 *      {
 *          styleName: 'custom-footer-1'
 *      }, {
 *          styleName: 'custom-footer-2'
 *      }
 * ])
 * ```
 */
interface GridFooterCollection$1 {
    /**
     * 표시여부
     *
     * @defaultValue `true`
     */
    visible?: boolean;
    /**
     * 현재 설정된 footer의 갯수를 반환한다.
     *
     * @readonly
     */
    count?: number;
    /**
     * 현재 설정된 footer중 visible이 `true`인 footer의 갯수를 반환한다.
     *
     * @readonly
     */
    visibleCount?: number;
    /**
     * 해당하는 인덱스의 푸터를 반환한다.
     *
     * @remarks
     * {@link GridFooter}를 반환한다.
     *
     * @param index - footer의 index
     */
    get(index: number): GridFooter$1;
    /**
     * 보여지는 순서에 해당하는 푸터를 가져온다.
     *
     * @remarks
     * {@link GridFooter}를 반환한다.
     *
     * @param index - 보여지는 순서 `0`부터 시작한다.
     */
    getVisible(index: number): GridFooter$1;
}
/**
 * Header Summary 영역의 단일 설정 모델
 *
 * @remarks
 * 그리드는 별도의 설정이 없는 경우 하나의 summary를 자동으로 생성하고 {@link GridBase.headerSummary}는 첫번째 summary를 반환한다..
 *
 * {@link GridBase.setHeaderSummary | setHeaderSummary()}를 이용해서 속성을 변경하거나 또는 {@link GridBase.headerSummary}를 이용해서 원하는 속성만 지정한다.
 *
 * @example
 *
 * ```js
 * gridView.setHeaderSummary({styleName: 'custom-hsummary-1'});
 * // 또는
 * gridView.headerSummary.styleName = 'custom-hsummary-1';
 * ```
 */
interface HeaderSummary$1 {
    /**
     * 스타일 클래스 이름
     */
    styleName?: string;
    /**
     * 최소 높이
     *
     * @defaultValue `23`
     */
    minHeight?: number;
    /**
     * 높이
     *
     * @remarks
     * `0`이면 자동으로 계산하여 지정한다. `0` 이상이면 minHeight와 비교하여 더 큰 값으로 지정한다.
     *
     * @defaultValue `0`
     */
    height?: number;
    /**
     * 셀 스타일을 지정하기 위한 콜백
     * @eventProperty
     *
     * @remarks
     * `string` 형태의 css 클래스 명 또는 {@link ColumnSummaryStyleObject} 형태로 지정가능하다.
     *
     * @example
     * ```js
     * // 푸터 적용
     * const f = function (grid, cell) {
     *      if (cell.value > 10) {
     *          return {
     *              styleName: 'custom-summary'
     *          }
     *      }
     * }
     * headerSummary.cellStyleCallback = f;
     * ```
     */
    cellStyleCallback?: CellStyleCallback;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * summary 콜렉션 내에서의 순서
     *
     * @readonly
     */
    summaryIndex?: number;
}
/**
 * Header summary 영역에 관한 콜렉션 모델 오브젝트
 *
 * @remarks
 *
 * 그리드의 headerSummary를 표시하거나 여러개의 headerSummary를 생성하고 관리한다.
 *
 * {@link GridBase.headerSummaries} 에서 반환되는 객체다.
 *
 * @example
 * ```js
 * // object
 * gridView.setHeaderSummaries({
 *      visible: true,
 *      items:[
 *          {
 *              styleName: 'custom-headerSummary-1'
 *          }, {
 *              styleName: 'custom-headerSummary-2'
 *          }
 *      ]
 * })
 * // 또는 array형태로 지정
 * gridView.setFooters([
 *      {
 *          styleName: 'custom-headerSummary-1'
 *      }, {
 *          styleName: 'custom-headerSummary-2'
 *      }
 * ])
 * ```
 */
interface HeaderSummaryCollection$1 {
    /**
     * 표시 여부
     */
    visible: boolean;
    /**
     * 현재 설정된 headerSummary의 갯수를 반환한다.
     *
     * @readonly
     */
    count?: number;
    /**
     * 현재 설정된 headerSummary중 visible이 `true`인 headerSummary의 갯수를 반환한다.
     *
     * @readonly
     */
    visibleCount?: number;
    /**
     * 해당하는 인덱스의 headerSummary를 반환한다.
     *
     * @remarks
     * {@link HeaderSummary}를 반환한다.
     *
     * @param index - headerSummary의 index
     */
    get(index: number): HeaderSummary$1;
    /**
     * 보여지는 순서에 해당하는 headerSummary를 가져온다.
     *
     * @remarks
     * {@link HeaderSummary}를 반환한다.
     *
     * @param index - 보여지는 순서 `0`부터 시작한다.
     */
    getVisible(index: number): HeaderSummary$1;
}

/**
 * 그리드의 고정 행 및 컬럼 영역에 대한 설정 모델
 *
 * @remarks
 * 그리드 위쪽에 하나 이상의 행을 수직 스크롤링에서 제외할 수 있다.
 *
 * 하나 이상의 최상위 컬럼을 수평 스크롤에서 제외할 수 있다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFixedOptions({colCount: 2});
 * ```
 */
interface FixedOptions$1 {
    /**
     * 왼쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     */
    colCount?: number;
    /**
     * 오른쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     *
     */
    rightCount?: number;
    /**
     * 위쪽 고정 행의 개수
     *
     * @defaultValue `0`
     *
     */
    rowCount?: number;
    /**
     * 오른쪽 고정 컬럼의 위치
     *
     * @remarks
     * `true`일 경우 컨테이너 오른쪽에, `false`일 경우 맨 오른쪽 컬럼 뒤에 고정
     *
     * @defaultValue `true`
     */
    rightFixed?: boolean;
    /**
     * 고정 행의 필터링 불가 여부
     *
     * @defaultValue `true`
     */
    exceptFromFiltering?: boolean;
    /**
     * 고정 행의 정렬 불가 여부
     *
     * @defaultValue `true`
     */
    exceptFromSorting?: boolean;
    /**
     * 고정 컬럼의 수정 가능 여부
     *
     * @remarks
     * `false` 시 다른 속성들과 상관 없이 고정된 컬럼을 수정 불가
     *
     * @defaultValue `true`
     */
    editable?: boolean;
    /**
     * 고정 행의 수정 가능 여부
     *
     * @remarks
     * false 시 다른 속성들과 상관 없이 고정된 행을 수정 불가
     *
     * @defaultValue `true`
     */
    rowEditable?: boolean;
    /**
     * 고정 컬럼의 너비 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 너비를 변경 불가
     *
     * @defaultValue `false`
     */
    resizable?: boolean;
    /**
     * 고정 행의 높이 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 행의 높이를 변경 불가
     *
     * @defaultValue `false`
     */
    rowResizable?: boolean;
    /**
     * 고정 컬럼의 위치 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 위치를 변경할 수 없다.
     * 고정 컬럼 그룹에 포함된 컬럼들은 그룹 내에서 이동 가능하다.
     * 최상위 컬럼에만 해당된다.
     *
     * @defaultValue `false`
     */
    movable?: boolean;
    /**
     * 왼쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    colBarWidth?: number;
    /**
     * 오른쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    rightBarWidth?: number;
    /**
     * 고정 행 구분 바의 높이
     *
     * @defaultValue `3`
     */
    rowBarHeight?: number;
}
/**
 * 그리드 수준에서 관리되는 표시 정보들에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setDisplayOptions({rowResizable: true});
 * ```
 */
interface DisplayOptions {
    /**
     * 그리드를 다시 그릴 때의 모드
     *
     * @defaultValue {@link RefreshMode.ALL}
     */
    refreshMode?: RefreshMode;
    /**
     * 컬럼 너비 변경 가능 여부
     *
     * @remarks
     * 헤더 셀 우측을 드래그하여 변경 가능
     *
     * @defaultValue `true`
     */
    columnResizable?: boolean;
    /**
     * 컬럼 위치 변경 가능 여부
     *
     * @remarks
     * 헤더 셀을 드래그하여 변경 가능
     *
     * @defaultValue `true`
     */
    columnMovable?: boolean;
    /**
     * 컬럼 너비의 기본값
     *
     * @defaultValue `100`
     */
    defaultColumnWidth?: number;
    /**
     * 그리드의 너비에 맞춰 컬럼 너비를 조정하는지에 대한 양식
     *
     * @defaultValue {@link GridFitStyle.NONE}
     */
    fitStyle?: GridFitStyle;
    /**
     * fitStyle적용시 fixed도 영역도 포함할지 여부.
     *
     * @remarks
     *
     * {@link DisplayOptions.fitStyle}을 {@link GridFitStyle.EVEN | even} 또는 {@link GridFitStyle.EVEN_FILL | evenFill}로 설정하면 고정영역에 있는 컬럼들도 너비를 변경한다.
     *
     * {@link GridFitStyle.FILL}은 적용되지 않는다.
     *
     * @defaultValue `false`
     */
    fitStyleIncludeFixed?: boolean;
    /**
     * 전체적인 행 높이 조절 가능 여부
     *
     * @remarks
     * 첫 번째 컬럼의 셀 아래쪽이나 첫 번째 행의 인디케이터의 아래 쪽을 드래그하면 조정 할 수 있다.
     *
     * @defaultValue `false`
     */
    rowResizable?: boolean;
    /**
     * 각 행 높이 조절 가능 여부
     *
     * @remarks
     * 셀 아래쪽을 드래그하면 조정 할 수 있다.
     *
     * @defaultValue `false`
     */
    eachRowResizable?: boolean;
    /**
     * {@link DisplayOptions.rowHeight | rowHeight} 속성이 변경될 때 개별 아이템마다 설정된 높이를 삭제할 지 여부
     *
     * @defaultValue `true`
     */
    autoClearHeights?: boolean;
    /**
     * {@link DisplayOptions.rowHeight | rowHeight}가 `-1`일때 그리드 스크롤시 표시되고 있는 행의 높이는 다시 찾지 않고 계산된 높이를 사용한다.
     *
     * @remarks
     * `false`로 설정하면 행이 화면에 표시될때 다시 높이를 계산한다. 화면에 많은 행이 표시되면 속도가 느려질수 있다.
     *
     * @defaultValue `true`
     */
    refCalcHeights?: boolean;
    /**
     * 행 높이
     *
     * @remarks
     * 0 이면 그리드의 폰트와 Padding 스타일을 고려해서 적절한 값으로 행들의 높이를 찾는다.
     * 0 보다 큰 값이면 지정한 값이 행들의 높이가 된다.
     * `-1` 이면 셀의 내용에 따라 행의 높이를 변경한다.
     *
     *
     * @defaultValue `0`
     */
    rowHeight?: number;
    /**
     * Table 행 최소 높이
     *
     * @defaultValue `23`
     */
    minTableRowHeight?: number;
    /**
     * 행 최소 높이
     *
     * @defaultValue `23`
     */
    minRowHeight?: number;
    /**
     * 행 최대 높이
     *
     * @defaultValue `0`
     */
    maxRowHeight?: number;
    /**
     * 셀 최소 너비
     *
     * @defaultValue `8`
     */
    minCellWidth?: number;
    /**
     * 수평 스크롤 바 표시 여부
     *
     * @defaultValue `true`
     */
    hscrollBar?: boolean;
    /**
     * 수직 스크롤 바 표시 여부
     *
     * @defaultValue `true`
     */
    vscrollBar?: boolean;
    /**
     * 스크롤바의 track-thumb을 이용한 스크롤시 즉시 스크롤 여부
     *
     * @remarks
     * `false`이면 마우스버튼을 놓았을때 스크롤한다.
     *
     * @defaultValue `true`
     */
    liveScroll?: boolean;
    /**
     * 수직 스크롤시 tooltip 표시 지연 시간
     *
     * @remarks
     * 스크롤바의 track-thumb를 이용한 스크롤시 tooltip의 발생을 지연시킨다.
     *
     * {@link DisplayOptions.liveScroll | liveScroll}이 `false`인 경우만 적용된다.
     *
     * @defaultValue `0` (ms)
     */
    scrollDuration?: number;
    /**
     * 수평 스크롤시 tooltip 표시 지연 시간
     *
     * @remarks
     * 스크롤바의 track-thumb를 이용한 스크롤시 tooltip의 발생을 지연시킨다.
     *
     * {@link DisplayOptions.liveScroll | liveScroll}이 `false`인 경우만 적용된다.
     *
     * @defaultValue `0` (ms)
     */
    hscrollDuration?: number;
    /**
     * 툴팁 지연 시간
     *
     * @defaultValue `0` (ms)
     */
    hintDelay?: number;
    /**
     * 데이터 행 위치 변경의 지연 시간
     *
     * @remarks
     * {@link GridBase.onCurrentRowChanged | onCurrentRowChanged} 를 지연시킨다.
     *
     * @defaultValue `0` (ms)
     */
    rowChangeDelay?: number;
    /**
     * 키보드로 컬럼 이동시 page단위 스크롤
     *
     * @defaultValue `false`
     */
    horzPageScroll?: boolean;
    /**
     * 그리드에 표시되는 데이터 행이 한 건도 없을 때 표시되는 메세지
     *
     * @defaultValue `'이 곳에 표시할 메시지를 DisplayOptions.emptyMessage 속성으로 설정합니다.'`
     */
    emptyMessage?: string;
    /**
     * 그리드에 표시되는 데이터 행이 한 건도 없을 때 메시지 표시 여부
     *
     * @defaultValue `false`
     */
    showEmptyMessage?: boolean;
    /**
     * focus의 보임 여부
     *
     * @defaultValue `true`
     */
    focusVisible?: boolean;
    /**
     * focus의 형태
     *
     * @defaultValue `layer`
     */
    focusType?: FocusType;
    /**
     * focus 된 행의 마스크 종류
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowFocusType?: RowMaskType;
    /**
     * 휠 가능 여부
     *
     * @defaultValue `true`
     */
    wheelEnabled?: boolean;
    /**
     * 한 번에 스크롤 되는 행 갯수
     *
     * @defaultValue `3`
     */
    wheelScrollLines?: number;
    /**
     * 휠로 수평 스크롤 했을 때 위치 이동 변동 값 (속도)
     *
     * @defaultValue `16`
     */
    wheelScrollHorz?: number;
    /**
     * 수직 스크롤 시 가속을 위한 최소 시간
     *
     * @remarks
     * {@link DisplayOptions.wheelAccelScroll | wheelAccelScroll} 과 함께 사용한다.
     *
     * @defaultValue `0`
     */
    wheelAccelDelay?: number;
    /**
     * {@link DisplayOptions.wheelAccelDelay | wheelAccelDelay} 만큼이 지연 되었을 경우, 해당 속성 만큼 스크롤을 가속한다.
     *
     * @remarks
     * 숫자 - 아이템 개수
     *
     * 문자열 - 백분율 ex) `'50%'`
     *
     * @defaultValue `null`
     */
    wheelAccelScroll?: number | string;
    /**
     * touchPad를 이용한 스크롤시 민감도를 조정한다.
     *
     * @remarks
     * touchPad의 경우 약간의 움직임만 있어도 스크롤되던것을 지정된 숫자만큼의 움직임이 있어야 스크롤되도록 한다.
     *
     * `10` ~ `20` 정도의 값이 적당하다.
     *
     * 세로스크롤에만 적용된다.
     *
     * @defaultValue `0`
     */
    wheelDeltaY?: number;
    /**
     * 그리드 내 발생한 휠 이벤트 외부 방출 여부
     *
     * @defaultValue `true`
     */
    wheelEventPropagate?: boolean;
    /**
     * 마우스 오른쪽 버튼 사용 가능 여부
     *
     * @defaultValue `true`
     */
    rightClickable?: boolean;
    /**
     * 컬럼 위치가 변경됐을 때 병합을 다시 시도할 지 여부.
     *
     * @defaultValue `true`
     */
    remergeWhenColumnMoved?: boolean;
    /**
     * Merged Row Grouping 또는 Cell Merging상태에서 셀 편집시 편집 중인 행의 분리 여부.
     *
     * @defaultValue `false`
     */
    editItemMerging?: boolean;
    /**
     * Merged Cell에서 개별 셀 영역 표시 여부
     *
     * @defaultValue `true`
     */
    showInnerFocus?: boolean;
    /**
     * 표시되는 Toast 창의 zIndex 지정
     *
     * @defaultValue `3000`
     */
    toastZIndex?: number;
    /**
     * 팝업이나 컨텍스트 메뉴에 한 화면에 표시되는 목록들의 개수
     *
     * @defaultValue `0`
     */
    popupDropdownCount?: number;
    /**
     * 선택 영역의 모드
     *
     * @remarks
     * {@link SelectionMode.EXTENDED | 다중선택}인경우 `rowMove`, `copy`를 지원하지 않는다.
     *
     * @defaultValue {@link SelectionMode.SINGLE}
     */
    selectionMode?: SelectionMode;
    /**
     * 선택 영역의 스타일
     *
     * @remarks
     * 자세한 설명은 {@link SelectionStyle} 참조
     *
     * @defaultValue {@link SelectionStyle.BLOCK}
     */
    selectionStyle?: SelectionStyle;
    /**
     * 선택 영역의 디스플레이
     * @remarks
     * 자세한 설명은 {@link SelectionDisplay} 참조
     *
     * @defaultValue {@link SelectionDisplay.CELL}
     */
    selectionDisplay?: SelectionDisplay;
    /**
     * 행 hover 시 마스크 종류
     *
     * @remarks
     * hovering 시 행 선택 영역 표시를 보여준다.
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowHoverType?: RowMaskType;
    /**
     * 행 선택 시 마스크 종류
     *
     * @remarks
     * 행 및 셀 선택시 행 선택 영역 표시를 보여준다.
     *
     * @defaultValue {@link RowMaskType.NONE}
     */
    rowBlockType?: RowMaskType;
    /**
     * 사용자 지정 {@link DisplayOptions.rowBlockType | rowBlockType} 을 설정하기 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(grid, itemIndex) {
     *     let billNo;
     *     let ds = grid.getDataSource();
     *     let fld = ds.getFieldIndex("text1");
     *     let dataRow = grid.getDataRow(itemIndex);
     *     if (dataRow >= 0) {
     *         billNo = ds.getValue(dataRow, fld);
     *     } else {
     *         billNo = null;
     *     }
     *
     *     let top = Math.min(grid.getTopItem(), itemIndex);
     *     let full = top + grid.fullItemCount();
     *     let startNo = top + full;
     *     let endNo = -1;
     *     let check1 = false;
     *
     *     for (let i = top; i <= full; i++) {
     *         dataRow = grid.getDataRow(i);
     *         if (dataRow < 0) {
     *             continue;
     *         }
     *
     *         let cBillNo = ds.getValue(dataRow, fld);
     *
     *         if (cBillNo === billNo) {
     *             startNo = Math.min(startNo, i), endNo = Math.max(endNo, i);
     *             check1 = true;
     *         } else {
     *             if (check1) {
     *                 break;
     *             }
     *         }
     *     };
     *
     *     if (startNo <= endNo && endNo > 0) {
     *         console.log(startNo)
     *         console.log(endNo);
     *         return { start: startNo, end: endNo };
     *     }
     * }
     *
     * grid.setDisplayOptions = {
     *      rowBlockType: 'row,
     *      rowBlockCallback: f
     * }
     * ```
     */
    rowBlockCallback?: RowBlockCallback;
    /**
     * 데이터와 무관하게 툴팁을 보여줄 건지에 대한 여부
     *
     * @remarks
     * `true`시 {@link GridBase.onShowTooltip | onShowTooltip()} 발생
     *
     * @defaultValue `false`
     */
    showEmptyTooltip?: boolean;
    /**
     * 마커 변경을 보여줄지에 대한 여부
     *
     * @defaultValue `true`
     */
    showChangeMarker?: boolean;
    /**
     * `liveScroll`이 `false`일 때 스크롤 위치를 알려주는 view에 표시되는 메세지를 반환하는 콜백
     *
     * @remarks
     * {@link ScrollMessageCallback} 의 형식이다.
     *
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.displayOptions.scrollMessageCallback = function(grid, vertical, itemIndex) {
     *     var msg = grid.getValue(itemIndex, "area3name");
     *     return "<span style='color:blue;font-size:20px'>itemIndex = " + msg+"</span>";
     * }
     * ```
     */
    scrollMessageCallback?: ScrollMessageCallback;
    /**
     * Native 드랍다운 편집기(date, list)일 때 셀 우측에 edit button을 표시할 것인 지 여부.
     *
     * @defaultValue `false`
     */
    showNativeEditButton?: boolean;
    /**
     * editor / editorButton 의 zIndex를 설정한다.
     *
     * @defaultValue `2000`
     */
    baseZindex?: number;
    /**
     * 짝수행의 className에 "rg-alternate-row" 추가를 설정한다.
     *
     * @defaultValue `true`
     */
    useAlternateRowStyle?: boolean;
    /**
     * focus된 셀과 row의 class명을 설정한다.
     *
     * @remarks
     * `true`이면 focus된 셀의 className에 `rg-focused-cell`을 추가한다.
     * Row의 className에 `rg-focused-row`를 추가한다.
     *
     * @defaultValue `false`
     */
    useFocusClass?: boolean;
    /**
     * container의 display가 변경되는 경우 자동으로 화면을 갱신
     *
     * @remarks
     * 그리드 상위element의 display가 변경되면 자동으로 화면을 갱신한다.
     *
     * @defaultValue `true`
     */
    watchDisplayChange?: boolean;
    /**
     * data가 모두 화면에 보이도록 그리드 컨테이너의 높이를 변경한다.
     *
     * @remarks
     * 표시되는 data의 건수가 많은 경우 속도가 느려질수 있다.
     * 그리드가 생성되기 전에 그리드 컨테이너의 높이가 지정되어야 원래 크기로 돌아갈수 있다.
     *
     * {@link DisplayOptions.rowHeight | rowHeight}가 -1인경우 적용되지 않는다.
     *
     * @defaultValue {@link SyncGridHeight.NONE}
     */
    syncGridHeight?: SyncGridHeight;
    /**
     * @internal
     * 행의 높이를 사용자가 지정한다.
     *
     * @remarks
     * 지정되지 않거나 `undefined`를 return하면 기본높이가 적용된다. {@link DisplayOptions.rowHeight | rowHeight}가 -1인경우 적용되지 않는다.
     *
     * {@link RowHeightCallback}의 형식이다.
     * @eventProperty
     */
    rowHeightCallback?: RowHeightCallback;
}
/**
 * 데이터 필드 값의 변환 형식에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFormatOptions({booleanFormat: 'wrong:correct'});
 * ```
 */
interface FormatOptions$1 {
    /**
     * 텍스트 형식의 값일 때 변환 서식
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'yy-M-dd'`
     *
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 변환 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
}
/**
 * 그리드에서의 데이터 편집에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setEditOptions({editable: false});
 * ```
 */
interface EditOptions$1 {
    /**
     * 그리드 수준에서 데이터 셀의 값 수정 금지 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue `false`
     *
     */
    readOnly?: boolean;
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue 모바일: `false`, 그외: `true`
     */
    editable?: boolean;
    /**
     * column.editable과 editOptions.editable의 적용순서 변경
     *
     * @remarks
     * `true`이면 column.editable이 설정된경우 editOptions.editable은 무시된다.
     *
     * @defaultValue `false`
     */
    columnEditableFirst?: boolean;
    /**
     * 행의 Checked 상태 변경 가능 여부
     *
     * @remarks
     * `true` 시 CheckBar Cell 을 클릭하여 변경 가능
     *
     * @defaultValue `true`
     */
    checkable?: boolean;
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * `true` 면 그리드의 데이터들을 수정 할 수 있다.
     * `false` 면 기존 데이터는 수정할 수 없고 {@link GridBase.commit | commit() } 되기 전 새로 추가된 행만 수정 가능하다.
     *
     * @defaultValue `true`
     */
    updatable?: boolean;
    /**
     * 행 추가 가능 여부
     *
     * @remarks
     * 그리드 마지막행에서 방향키로 추가 가능
     *
     * @defaultValue `false`
     */
    appendable?: boolean;
    /**
     * 행 삽입 가능 여부
     *
     * @remarks
     * `true` 시 Insert 키를 눌러 행 삽입 가능
     *
     * @defaultValue `false`
     */
    insertable?: boolean;
    /**
     * 행 삭제 가능 여부
     *
     * @remarks
     * `true` 시 사용자가 Ctrl+Del 키를 누르거나 {@link GridBase.deleteSelection | deleteSelection()} 을 호출해서 현재 선택된 행을 삭제할 수 있다.
     * `deleteSelection(true)` 와 같이 호출하면 해당 옵션과 상관없이 삭제할 수 있다.
     *
     * @defaultValue `false`
     */
    deletable?: boolean;
    /**
     * 삭제 취소 가능 여부
     *
     * @remarks
     * {@link DataProviderBase.softDeleting | dataProvider.softDeleting} == true 인 경우, 삭제 상태인 행들을 ctrl+shift+del 키 입력시 원래 상태로 되돌릴 수 있다.
     *
     * @defaultValue `false`
     */
    revertable?: boolean;
    /**
     * 선택 영역에 포함된 셀 삭제 가능 여부
     *
     * @defaultValue `false`
     */
    erasable?: boolean;
    /**
     * 행 이동 가능 여부
     *
     * @remarks
     * sorting된 상태인경우 이동할수 없다.
     * 트리의 경우 동일 노드내에서만 이동가능
     *
     * @defaultValue `false`
     */
    movable?: boolean;
    /**
     * 셀 단위 수정 후 commit 여부
     *
     * @defaultValue `false`
     */
    commitByCell?: boolean;
    /**
     * 셀 focus 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    editWhenFocused?: boolean;
    /**
     * 셀이 편집되지 않아도 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenNoEdit?: boolean;
    /**
     * Tab 이나 Enter 키로 셀을 벗어날 때 행을 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenExitLast?: boolean;
    /**
     * focus가 그리드를 벗어날때 그리드를 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenLeave?: boolean;
    /**
     * Tab이 이나 Enter 키로 마지막 셀을 벗어날 때 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    crossWhenExitLast?: boolean;
    /**
     * 셀 편집이 완료될 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `true`
     */
    validateOnEdited?: boolean;
    /**
     * 셀에서 벗어날 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `false`
     */
    validateOnExit?: boolean;
    /**
     * 편집 중에 에러가 있는 셀에 마우스가 위치할 때 에러 힌트 툴팁 표시 여부
     *
     * @defaultValue `true`
     */
    hintOnError?: boolean;
    /**
     * 삭제 대화 상자에 표시할 메세지
     *
     * @defaultValue `'선택된 행(들)을 삭제하시겠습니까??'`
     */
    deleteRowsMessage?: string;
    /**
     * mask 에서 지정한 형태가 아닐 때 표시할 오류 메시지
     *
     * @defaultValue `'잘못된 입력 유형입니다.'`
     */
    invalidFormatMessage?: string;
    /**
     * mask 에서 지정한 형태가 아닐 때 오류 메시지를 보여줄 것인지의 여부
     *
     * @defaultValue `true`
     */
    showInvalidFormatMessage?: boolean;
    /**
     * 삭제 여부를 묻는 대화 상자의 호출 여부
     *
     * @remarks
     * true시 사용자 삭제나 {@link GridBase.deleteSelection | deleteSelection()} 실행할 때 삭제 여부를 묻는 대화 상자를 먼저 호출한다.
     * GridView.deleteSelection(true)로 호출하면 대화 상자 표시 없이 바로 삭제한다.
     *
     * @defaultValue `true`
     */
    confirmWhenDelete?: boolean;
    /**
     * 선택된 셀을 클릭했을 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    editWhenClickFocused?: boolean;
    /**
     * 행 편집을 완료할 수 있는 최상위 ValidationLvel
     *
     * @defaultValue {@link ValidationLevel.IGNORE}
     */
    commitLevel?: ValidationLevel;
    /**
     * Tab 키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    useTabKey?: boolean;
    /**
     * 방향키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    useArrowKeys?: boolean;
    /**
     * 컬럼간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    skipReadOnly?: boolean;
    /**
     * 한 컬럼에서 행 간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    skipReadOnlyCell?: boolean;
    /**
     * 컬럼 그룹의 컬럼 셀을 위나 아래로 이동시 동작 방법
     *
     * @remarks
     * 'row' 또는 'cell'이다.
     *
     * @defaultValue `'row'`
     */
    verticalMoveStep?: VerticalMoveStep;
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 셀로 이동할지의 여부
     *
     * @remarks
     * enterToNextRow == true 시 다음 행으로 이동
     *
     * @defaultValue `false`
     */
    enterToTab?: boolean;
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    enterToNextRow?: boolean;
    /**
     * focus된 셀이 편집상태가 아닐때 Enter키 를 입력하면 편집상태로 변경한다.
     *
     * @remarks
     * enterToNextRow가 `true` 인경우에는 편집상태로 변경하지 않고 다음 `row`로 이동한다.
     *
     * @defaultValue `false`
     */
    enterToEdit?: boolean;
    /**
     * 지정한 자리수 만큼 입력되면 다음 셀로 이동할지의 여부
     *
     * @remarks
     * column.editor.maxLength에 지정한 자리수 만큼 입력되면 다음 셀로 이동된다.
     * editFormat이 있는 경우 보여지는 글자를 기준으로 maxLength가 체크된다. (numberEditor, dateEditor)
     * multiLine의 경우 `\n`과 같이 제어문자도 글자수에 포함된다.
     * editOptions.skipReadOnly가 true 인 경우 readOnly인 셀은 건너뛴다.
     *
     * @defaultValue `false`
     */
    maxLengthToNextCell?: boolean;
    /**
     * 변경된 내용이 없어도 Inserting 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    forceInsert?: boolean;
    /**
     * 변경된 내용이 없어도 Appending 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    forceAppend?: boolean;
    /**
     * 행 편집 완료 시 실제 셀이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * `true` 시 행 편집 완료 요청 시 실제 변경된 셀이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 시 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    checkDiff?: boolean;
    /**
     * 셀 편집 완료 시 실제 값이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * `true`면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    checkCellDiff?: boolean;
    /**
     * strict 하게 판단하여 셀 편집시 실제 값이 변경 되었는지 확인 여부 (자료형도 같아야함)
     *
     * @remarks
     * `true` 면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    strictDiff?: boolean;
    /**
     * 셀 편집 시 편집 취소 후 선택된 행 삭제 가능 여부
     *
     * @defaultValue `true`
     */
    deletableWhenEdit?: boolean;
    /**
     * commit 오류 발생 시 보여줄 것인지에 대한 여부
     *
     * @defaultValue `false`
     */
    showCommitError?: boolean;
    /**
     * @alpha
     *
     * @defaultValue `false`
     */
    firstCellWhenInsert?: boolean;
    /**
     * Insert 키로 마지막에 행을 추가할지의 여부
     *
     * @defaultValue `false`
     */
    appendWhenInsertKey?: boolean;
    /**
     * Tab 또는 Enter 키로 마지막 셀을 벗어날 때 행 추가 여부
     *
     * @remarks
     * commitWhenExitLast 가 true 여야 한다.
     *
     * @defaultValue `false`
     */
    appendWhenExitLast?: boolean;
    /**
     * 설정한 Validation Error의 메시지만 보여줄지 의 여부
     *
     * @remarks
     * `true`인경우 Validation의 `message`만 보여주며 false 인경우 `level`과 `message`를 동시에 보여준다.
     * 셀별로 `message`를 변경하려면 {@link GridBase.onValidationFail}을 참조
     *
     * @defaultValue `true`
     */
    showOnlyValidationMessage?: boolean;
    /**
     * 그리드의 행의 마지막에 항상 빈 행을 추가할지의 여부
     *
     * @remarks
     * 해당 빈 행에 데이터가 입력되고 행 commit()이 발생하면 다시 빈 행이 추가된다.
     *
     * @defaultValue `false`
     */
    displayEmptyEditRow?: boolean;
    /**
     * @alpha
     *
     * @defaultValue `false`
     */
    buttonClickWhenSpace?: boolean;
    /**
     * tab 키를 눌렀을 때 그리드 벗어남 여부
     *
     * @defaultValue {@link ExitGridWhenTab.NONE}
     */
    exitGridWhenTab?: ExitGridWhenTab;
    /**
     * 편집 취소 가능 여부
     *
     * @defaultValue `false`
     */
    cancelWhenLastUndo?: boolean;
    /**
     * 편집 중 일때 스크롤 시 처리
     *
     * @defaultValue {@link ScrollOnEditing.DEFAULT}
     */
    scrollOnEditing?: ScrollOnEditing;
}
/**
 * 그리드 수준에서 관리되는 편집기 정보들에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * {@link EditorOptions.months | months} 속성이 지정되면 {@link EditorOptions.monthDisplayFormat | monthDisplayFormat} 속성은 무시된다.
 *
 * @example
 *
 * ```js
 * grid.setEditorOptions({yearDisplayFormat: "{Y} year"});
 * ```
 */
interface EditorOptions$1 {
    /**
     * 달력 팝업에서의 년의 표시 형태
     *
     * @remarks
     * "년"에 대한 문구만 수정 가능
     * ex) `{Y} Year`
     *
     * @defaultValue `'{Y}년'`
     */
    yearDisplayFormat?: string;
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * "월"에 대한 문구만 수정 가능
     * {@link EditorOptions.months | months } 속성이 지정되면 본 속성은 무시
     * ex) `{M} Month`
     *
     * @defaultValue `'{M}월'`
     */
    monthDisplayFormat?: string;
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * ex) `['Jan', 'Feb', 'Mar', 'Apr', ...]`
     *
     * @defaultValue `null`
     */
    months?: string[];
    /**
     * 달력 팝업에서의 요일의 표시 형태
     *
     * @remarks
     * ex) `['Mon', 'Tue', 'Wed', 'Thu', ...]`
     *
     * @defaultValue `null`
     */
    weekDays?: string[];
    /**
     * 그리드 DOM 내부에 포함시킬 것인지의 여부
     *
     * @remarks
     * editor element 가 그리드 element 내부에 생성되어 브라우저가 스크롤 되는 경우 함께 스크롤 된다.
     *
     * @defaultValue `false`
     */
    viewGridInside?: boolean;
    /**
     * 편집기의 제목 문구
     *
     * @alpha
     */
    titleStatement?: string;
    /**
     * 표시되는 공휴일
     *
     * @defaultValue `null`
     */
    holidays?: Holidays;
}
/**
 * 그리드의 내용을 클립보드를 복사하는 것에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setCopyOptions({enabled: false});
 * ```
 */
interface CopyOptions$1 {
    /**
     * 복사 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 선택 영역과 상관없이 focus 된 셀 하나만 복사할 것인지에 대한 여부
     *
     * @defaultValue `false`
     */
    singleMode?: boolean;
    /**
     * 보여지는 text 로 복사할 것인지의 여부
     *
     * @remarks
     * `true` 시 number, date, dropdown, multicheck 의 경우 보여지는 Text로 복사한다.
     *
     * @defaultValue `false`
     */
    copyDisplayText?: boolean;
    /**
     * 헤더의 text 를 포함하여 복사할 것인지의 여부
     *
     * @remarks
     * ex) OrderID 10233
     *
     * @defaultValue `false`
     */
    includeHeaderText?: boolean;
    /**
     * lookupDisplay가 true인 컬럼의 text복사
     *
     * @remarks
     * `true`시 lookupDisplay가 true인 컬럼은 value가 아닌 label 또는 labelField의 값을 복사
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;
    /**
     * boolean 형식의 값일 때 변환 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'N:Y'`
     */
    booleanFormat?: string;
    /**
     * 날짜 형식의 값일 때 변환 서식
     *
     * @remarks
     * 예) `'yyyy-MM-dd'`
     *
     */
    datetimeFormat?: string;
    /**
     * 클립보드에 복사될 text를 결정하는 콜백
     *
     * @remarks
     * 셀이 복사될때 호출된다.
     *
     * 지정되지 않거나 `undefined`를 return하면 value또는 다른 설정값이 적용된다.
     *
     * {@link CopyTextCallback}의 형식이다.
     * @eventProperty
     */
    copyTextCallback?: CopyTextCallback;
}
/**
 * 클립보드의 데이터를 그리드에 붙여넣는 것에 관한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setPasteOptions({enabled: false});
 * ```
 */
interface PasteOptions$1 {
    /**
     * 붙여넣기 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 클립보드의 내용과 상관없이 focus 된 셀 하나에만 값을 붙여 넣을지에 대한 여부
     */
    singleMode?: boolean;
    /**
     * 붙여넣기 할 때 편집 시작 여부
     *
     * @remarks
     * 붙여넣게 될 값이 복수 행이 아니고, 붙여넣을 행이 아직 편집 중이 아니면 편집을 시작한다.
     * `false` 면 이 행에 연결된 데이터 행을 업데이트한다.
     *
     * @defaultValue `true`
     */
    startEdit?: boolean;
    /**
     * 복수 행 붙여넣기일 때 기존 편집 상태 commit 여부
     *
     * @remarks
     * `false` 로 지정하면 기존 편집을 취소한다.
     *
     * @defaultValue `true`
     */
    commitEdit?: boolean;
    /**
     * 붙여 넣을 여러 행이 기존의 행의 범위를 넘어설 때 행 추가 여부
     *
     * @defaultValue `true`
     */
    enableAppend?: boolean;
    /**
     * 포함되지 않은 필드의 값을 데이터 필드의 기본값으로 채워 넣을지에 대한 여부
     *
     * @defaultValue false
     */
    fillFieldDefaults?: boolean;
    /**
     * 포함되지 않은 필드의 값을 컬럼의 기본값으로 채워 넣을지에 대한 여부
     *
     * @remarks
     * {@link PasteOptions.fillFieldDefaults | fillFieldDefaults} 가 true라면 데이터필드의 기본값을 먼저 적용한 후 컬럼 기본값을 적용한다.-active
     *
     * @defaultValue false
     */
    fillColumnDefaults?: boolean;
    /**
     * 복수 행 붙여 넣기 중 행별로 행 validation을 실행할 것인지의 여부
     *
     * @defaultValue false
     */
    forceRowValidation?: boolean;
    /**
     * 복수 행 붙여 넣기 중 행별로 컬럼 validation을 실행할 것인지의 여부
     *
     * @remarks
     * {@link PasteOptions.forceRowValidation | forceRowValidation} 이 `true`면 행 validation을 먼저 실행한다.
     *
     * @defaultValue `false`
     */
    forceColumnValidation?: boolean;
    /**
     * 데이터 필드에 지정된 datetimeFormat 외에 datetime 필드값으로 변환할 때 사용할 형식들
     *
     * @defaultValue `null`
     */
    datetimeFormats?: string[];
    /**
     * 데이터 필드에 지정된 booleanFormat 외에 boolean 필드값으로 변환할 때 사용할 형식
     *
     * @defaultValue `null`
     */
    booleanFormat?: string;
    /**
     * number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * 지정한 문자열들을 모두 빈 문자열로 치환한 후 숫자로 변환한다.
     *
     * @defaultValue `null`
     */
    numberChars?: string[];
    /**
     * number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `'.'`
     *
     * @defaultValue `null`
     */
    numberSeparator?: string;
    /**
     * 컬럼별로 number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * ex) `{"column1": [",", "kr"], "column2": [" ", "$"]}`
     *
     * @defaultValue `{}`
     */
    numberCharsOfCols?: {
        [key: string]: string[];
    };
    /**
     * 컬럼별로 number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `{"column1": ".", "column2": ","}`
     *
     * @defaultValue `null`
     */
    numberSeparatorOfCols?: {
        [key: string]: string;
    };
    /**
     * 붙여넣기 시작 위치
     *
     * @remarks
     * `true` 시 focus 셀이 포함된 선택 영역의 처음 셀부터 붙여넣기
     * `false` 시 focus 셀 부터 붙여넣기
     *
     * @defaultValue `false`
     */
    selectionBase?: boolean;
    /**
     * 여러 개 셀에 붙여넣기 가능 여부
     *
     * @remarks
     * 하나의 셀을 복사후 여러 개의 셀에 붙여넣기 할 수 있다.
     *
     * @defaultValue `false`
     */
    selectBlockPaste?: boolean;
    /**
     * Validation이 실패하거나 형변환이 실패 시 붙여넣기 중지 여부
     *
     * @remarks
     * `false` 시 계속 진행하되, 에러가 있는 행은 건너뛰고 붙여넣기한다.
     *
     * @defaultValue `false`
     */
    stopOnError?: boolean;
    /**
     * {@link GridBase.onEditRowChanged | onEditRowChanged }, {@link GridBase.onCellEdited | onCellEdited} 의 발생 여부
     *
     * @remarks
     * {@link GridBase.onEditRowPasted | onEditRowPasted } 는 지정여부와 상관없이 항상 발생
     *
     * @defaultValue `false`
     */
    noEditEvent?: boolean;
    /**
     * 여러 줄의 데이터 붙여넣기 도중 refresh 실행 여부
     *
     * @remarks
     * 붙여넣기를 하는 중에는 refresh되지 않아 속도가 개선된다.
     *
     * @defaultValue `false`
     */
    noDataEvent?: boolean;
    /**
     * 여러 행 붙여넣기 시 행 수 만큼 {@link GridBase.onEditRowPasted | onEditRowPasted } 이벤트의 발생 여부
     *
     * @defaultValue `false`
     */
    eventEachRow?: boolean;
    /**
     * readOnly이거나 editable이 `false`인 컬럼은 paste 대상에서 제외 여부
     *
     * @defaultValue `false`
     */
    checkReadOnly?: boolean;
    /**
     * DropDown Editor 의 domainOnly 가 `true`인 컬럼에 붙여넣기 할때 values 에 없는 값 붙여넣기 제외 여부
     *
     * @defaultValue `false`
     */
    checkDomainOnly?: boolean;
    /**
     * DropDown Editor 에 label값을 붙여넣는 경우 value 로 변환해서 저장할지의 여부
     *
     * @defaultValue `false`
     */
    convertLookupLabel?: boolean;
    /**
     * 붙여넣기 시 editFormat이 있으면 editFormat 형태로, 없으면 styles.numberFormat 형태로 붙여넣기 된다.
     *
     * @defaultValue `false`
     */
    applyNumberFormat?: boolean;
    /**
     * mask에 붙여넣을 수 없는 경우 붙여넣기 제한 여부
     *
     * @remarks
     * mask의 입력자리수보다 긴 경우 mask에 들어가는 자리를 제외하고 붙여넣기가 된다.
     *
     * @defaultValue `false`
     */
    applyEditMask?: boolean;
    /**
     * 붙여넣기 시 editor.maxLength, maxLengthExceptComma 적용 여부
     *
     * @defaultValue `false`
     */
    applyMaxLength?: boolean;
    /**
     * ValidationError 를 발생시킬지 여부
     *
     * @defaultValue `true`
     */
    throwValidationError?: boolean;
    /**
     * editor에 inputCharacters, ignoreCharacters 적용여부
     *
     * @defaultValue `false`
     */
    applyInputChars?: boolean;
}
/**
 * 모바일 관련 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setMobileOptions({longTapDuration: 300});
 * ```
 */
interface MobileOptions$1 {
    /**
     * 롱 탭으로 인식하기 위한 최소 시간
     *
     * @defaultValue `500`
     */
    longTapDuration?: number;
    /**
     * 더블 탭이 발생하기 위한 탭 간 최대 시간
     *
     * @defaultValue `300`
     */
    doubleTapInterval?: number;
    /**
     * 탭 간 동일 탭으로 인지하는 영역범위
     *
     * @defaultValue `4`
     */
    tapThreshold?: number;
    /**
     * 편집 커맨더를 보여줄지에 대한 여부
     *
     * @defaultValue `true`
     */
    showEditCommander?: boolean;
    /**
     * 모바일에서 툴팁을 보여줄 건지에 대한 여부
     *
     * @remarks
     * 다른 툴팁 설정들이 `true`여야 한다.
     *
     * @defaultValue `false`
     */
    showTooltip?: boolean;
    /**
     *
     * @deprecated
     * {@link EditOptions.scrollOnEditing}으로 이동.
     *
     * 모바일에서 편집 중 일때 스크롤 시 처리
     *
     */
    scrollOnEditing?: ScrollOnEditing;
}
/**
 * 데이터 정렬에 대한 설정 모델
 *
 * @remarks
 * {@link SortingOptions.style | style} 이 "exclusive"일 때 shift 키와 함께 컬럼 헤더를 클릭하면 "inclusive"처럼 동작한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setSortingOptions({enabled: false});
 * ```
 */
interface SortingOptions$1 {
    /**
     * 컬럼 헤더를 클릭으로 컬럼을 정렬 가능 여부
     *
     * @remarks
     * {@link GridBase.orderBy | orderBy()} 는 이 속성 값과 상관없이 실행된다.
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 그리드에서 여러 컬럼에 대한 정렬 상태를 지정하는 방식
     *
     * @defaultValue {@link SortStyle.EXCLUSIVE}
     */
    style?: SortStyle;
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    handleVisibility?: HandleVisibility;
    /**
     * 정렬 전에 commit 할 건지의 여부
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    commitBeforeSorting?: boolean;
    /**
     * 정렬 시 현재 focus 된 행 유지 여부
     *
     * @defaultValue `false`
     */
    keepFocusedRow?: boolean;
    /**
     * 대소문자 구분
     *
     * @defaultValue {@link SortCase.SENSITIVE}
     */
    textCase?: SortCase;
    /**
     * 여러 컬럼을 정렬했을 때 정렬 순서 표시 여부
     *
     * @defaultValue `false`
     */
    showSortOrder?: boolean;
    /**
     * 현재페이지 기준으로 정렬할 것인지의 여부
     *
     * @defaultValue `false`
     */
    pageSorting?: boolean;
    /**
     * toast 관련 설정
     *
     * @remarks
     * {@link ToastOptions} 모델을 따른다.
     *
     * @defaultValue `{visible: false, message: "Sorting..."}`
     */
    toast?: ToastOptions;
}
/**
 * 다른 그리드에서 drag 된 데이터를 처리하는 방식에 대한 설정 모델
 *
 * @remarks
 * callback 이 지정되지 않은 경우, {@link DataDropOptions.fieldMap | fieldMap} 이나 {@link DataDropOptions.fieldMapCallback | fieldMapCallback} 에 설정된대로 동작한다.
 *
 * 아무것도 지정되지 않은 경우 필드명이 같은 필드들의 값을 {@link DataDropOptions.dropMode | dropMode} 에 따라 이동 / 복사한다.
 *
 * {@link EditOptions.movable} 이 `true` 여야한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 * ```js
 * grid.setDataDropOptions({dropMode: 'copy'});
 * ```
 */
interface DataDropOptions {
    /**
     * drag and drop 을 결정하는 콜백
     *
     * @remarks
     * drag 시작 시 발생한다.
     * {@link DataDragCallback} 의 형식이다.
     * @eventProperty
     */
    dragCallback?: DataDragCallback;
    /**
     * drop 했음을 알리는 콜백
     *
     * @remarks
     * drop 시 발생한다.
     * {@link DataDropCallback} 의 형삭이다.
     * @eventProperty
     */
    callback?: DataDropCallback;
    /**
     * 데이터 drop 모드
     *
     * @remarks
     * drop 시 {@link DataDropMode} 의 값으로 행 이동할 것인지 복사할 것인지 설정 가능하다.
     *
     * @defaultValue {@link DataDropMode.COPY}
     */
    dropMode?: DataDropMode;
    /**
     * drag 를 시작한 그리드의 필드명 - drop 할 그리드의 필드명 쌍
     *
     * @remarks
     * callback 이나 feildMapcallback 이 설정되지 않았을 경우에 이 값을 따른다.
     * {@link FieldMap} 형식으로 drop 될 그리드에 설정해야한다.
     *
     * @example
     * ```js
     * {'CompanyName': 'ShipAddress'}
     * ```
     */
    fieldMap?: FieldMap;
    /**
     * {@link FieldMap} 형식의 오브젝트를 반환하여 규칙으로 사용하는 콜백
     *
     * @remarks
     * {@link DropFieldMapCallback} 의 형식이다.
     * drop 될 그리드에 설정해야한다.
     * @eventProperty
     */
    fieldMapCallback?: DropFieldMapCallback;
    /**
     * drag 중인 item 의 label 텍스트
     *
     * @remarks
     * {@link DataDropOptions.labelCallback} 이 설정되지 않았을 경우에 이 값을 따른다.
     *
     * [사용 가능 표현 목록]
     *
     * `${rows}` - 드래그 된 아이템의 개수
     *
     * `${mode}` - 현재 dropMode
     *
     * `${from}` - 드래그 된 위치 (인덱스)
     *
     * `${to}` - 복사 혹은 이동 될 위치 (인덱스)
     *
     * @defaultValue `${rows}행${mode}`
     *
     * @example
     * ```js
     * gridView.dataDropOptions.proxyLabel = '${rows} 개 행을 ${to} 로 ${mode}'
     * // ex)  '1 개 행을 4 로 복사'
     * ```
     */
    proxyLabel?: string;
    /**
     * drag 중인 item 의 label 텍스트를 결정하기 위한 콜백
     * @eventProperty
     */
    labelCallback?: DataDragLabelCallback;
}
/**
 * 컬럼 필터링과 관련된 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({enabled: false});
 * ```
 */
interface FilteringOptions {
    /**
     * 필터 핸들이나 Indicator Head를 클릭으로 필터 상자 표시 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    handleVisibility?: HandleVisibility;
    /**
     * 필터링 전에 commit 할 건지의 여부
     *
     * @defaultValue `true`
     */
    commitBeforeFiltering?: boolean;
    /**
     * TreeView 에서 검색된 데이터 행의 부모 행도 표시할지의 여부
     *
     * @defaultValue `true`
     */
    includeParentItem?: boolean;
    /**
     * 필터 선택 상자에 대한 설정 모델
     *
     * @remarks
     * {@link FilterSelectorOptions} 모델을 따른다.
     */
    selector?: FilterSelectorOptions;
    /**
     * 자동 필터링에 대한 설정 모델
     *
     * @remarks
     * {@link FilterAutomatingOptions} 모델을 따른다.
     */
    automating?: FilterAutomatingOptions;
    /**
     * toast 관련 설정
     *
     * @remarks
     * {@link ToastOptions} 모델을 따른다.
     *
     * @defaultValue `{visible: false, message: "Filtering..."}`
     */
    toast?: ToastOptions;
}
/**
 * 컬럼 필터의 선택 상자에 대한 설정 모델
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      selector: {
 *          showButtons: false
 *      }
 * });
 * ```
 */
interface FilterSelectorOptions {
    /**
     * 컬럼 필터의 선택 상자의 푸터 버튼 표시 여부
     *
     * @defaultValue `false`
     */
    showButtons?: boolean;
    /**
     * 필터 검색 상자 표시 여부
     *
     * @defaultValue `true`
     */
    partialSearch?: boolean;
    /**
     * 필터의 선택 상자의 확인 버튼의 문구
     *
     * @defaultValue `'확인'`
     */
    acceptText?: string;
    /**
     * 필터의 선택 상자의 취소 버튼의 문구
     *
     * @defaultValue `'취소'`
     */
    cancelText?: string;
    /**
     * 전체 선택 탭의 문구
     *
     * @defaultValue `'(전체선택)'`
     */
    allCheckText?: string;
    /**
     * 자동 필터 생성 시 값 없음 필터 탭의 문구
     *
     * @defaultValue `'(값 없음)'`
     */
    emptyFilterText?: string;
    /**
     * 검색 박스의 placeholder
     *
     * @defaultValue `'검색...'`
     */
    searchPlaceholder?: string;
    /**
     * 검색 이후 적용하고자 하는 탭을 클릭하여 필터를 적용할 때, 검색 범위에 없는 필터들을 비활성화 할지의 여부
     *
     * @alpha
     * @defaultValue `true`
     */
    excludeCheck?: boolean;
    /**
     * 검색 후 전체 선택 대신에 보여지는 문구
     *
     * @defaultValue `'(조회 전체 선택)'`
     */
    searchedCheckText?: string;
    /**
     * 필터창의 class
     *
     * @defaultValue `rg-filter-selector`
     */
    style?: string;
    /**
     * 필터를 활성화 하였을 때 창 닫힘 여부
     *
     * @remarks
     * {@link FilterSelectorOptions.showButtons | showButtons} 가 `false` 일 경우, 필터를 선택 하였을 때 창이 닫힌다.
     * {@link FilterSelectorOptions.showButtons | showButtons} 에 `true`로 설정하여 확인 / 취소 버튼이 생겼을 경우에는 확인 / 취소 버튼 동작 시 창이 닫힌다.
     *
     */
    closeWhenClick?: boolean;
    /**
     * 필터 초기화 버튼 유무
     *
     * @defaultValue `true`
     */
    filterReset?: boolean;
    /**
     * 필터 초기화 텍스트
     *
     * @defaultValue `'필터 초기화'`
     */
    filtersResetText?: string;
    /**
     * 필터 검색창에 입력한 내용을 토대로 사용자 지정 필터를 등록하기 위한 콜백
     * @alpha
     *
     * @remarks
     * Ctrl + Enter 로 등록 요청한다.
     * @eventProperty
     */
    userFilterAddCallback?: UserFilterAddCallback;
    /**
     * 필터 text를 `title`로 추가 여부
     *
     * @defaultValue `false`
     *
     * @remarks
     * 필터의 text를 element의 title로 추가해서 mouse over시 tooltip이 보여지도록 한다.
     */
    textToTitle?: boolean;
    /**
     * 필터 검색시 대소문자 구분 여부
     *
     * @defaultValue `false`
     *
     * @remarks
     * `true`이면 대소문자를 구분하지 않고 검색한다.
     */
    searchIgnoreCase?: boolean;
}
/**
 * 자동 필터링에 관한 설정 정보
 *
 * @remarks
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      automating: {
 *          dateCategorize: false
 *      }
 * });
 * ```
 */
interface FilterAutomatingOptions {
    /**
     * 날짜를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 설정한 foramt 들을 기준으로한 텍스트로 연도, 분기, 또는 월 단위로 분류된다.
     *
     * 년도 수가 2 이상, 월 수가 7 이상이어야 연도별로 분류된다.
     *
     * 년도 당 월 수가 7 이상이어야 분기별로 분류된다.
     *
     * 총 일 수가 10 이상이고 월 수가 4 이상이어야 월별로 분류된다.
     *
     * `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     *
     * {@link FilterAutomatingOptions.dateCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `true`
     */
    dateCategorize?: boolean;
    /**
     * 수를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 아이템이 16개 이상인 경우, 최대값과 최소값의 차를 기준으로 4개에서 8개 사이의 구간으로 분류 되어진다.
     * 아이템이 15개 이하거나 `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     * {@link FilterAutomatingOptions.numberCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `true`
     */
    numberCategorize?: boolean;
    /**
     * 텍스트를 분류할 것인지의 여부
     *
     * @remarks
     * `true` 시 아이템이 16개 이상인 경우에 문자열의 첫 문자를 기준으로 숫자, 알파벳 대문자, 알파벳 소문자, 유니코드, 그 외로 분류 되어진다.
     * 아이템이 15개 이하거나 `false` 시 트리 형태가 아닌 리스트 형태로 항목마다 필터 탭이 만들어진다.
     * {@link FilterAutomatingOptions.textCategoryCallback } 을 지정하여 사용자 지정의 분류를 할 수 있다.
     *
     * @defaultValue `false`
     */
    textCategorize?: boolean;
    /**
     * 날짜를 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    dateCategoryCallback?: CategoryCallback;
    /**
     * 수를 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    numberCategoryCallback?: CategoryCallback;
    /**
     * 문자열을 분류하기 위한 콜백
     * @remarks
     * 반환 값 및 설명은 {@link FilterCategory} 참조
     *
     * @eventProperty
     */
    textCategoryCallback?: CategoryCallback;
    /**
     * 항목에 표시되는 연도 형식
     *
     * @defaultValue `'YYYY년도'`
     */
    dateYearFormat?: string;
    /**
     * 항목에 표시되는 분기 형식
     *
     * @defaultValue `'Q분기'`
     */
    dateQuarterFormat?: string;
    /**
     * 항목에 표시되는 월 형식
     *
     * @defaultValue `'M월'`
     */
    dateMonthFormat?: string;
    /**
     * 항목에 표시되는 일 형식
     *
     * @defaultValue `'YYYY-MM-DD'`
     */
    dateDayFormat?: string;
    /**
     * Column의 lookupDisplay가 true이면 value 대신 label을 표시한다.
     *
     * @defaultValue `false`
     */
    lookupDisplay?: boolean;
    /**
     * @internal
     * FilterSelector에 표시되는 데이터
     *
     * @remarks
     * `true`이면 전체 데이터가 아닌 filtering되어서 보여지고 있는 데이터만 filterSelector에 표시된다.
     * {@link DataColumn.autoFilter}가 `true`인 column에만 적용된다.
     *
     * @defaultValue `false`
     */
    filteredDataOnly?: boolean;
}
/**
 * Toast View 표시 여부와 메시지를 지정할 수 있는 설정 모델
 *
 * @remarks
 * 대량 데이터셋의 정렬/필터링/그룹핑시 화면이 멈춰있는 상태일 때 진행 중임을 알려줄 수 있다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setFilteringOptions({
 *      toast: {
 *          message: "필터링 중"
 *      }
 * });
 * ```
 */
interface ToastOptions {
    /**
     * 토스트에 표시할 메시지
     *
     * @defaultValue sorting/filtering/grouping 에 따라 다름
     */
    message?: string;
    /**
     * 표시 여부
     */
    visible?: boolean;
    /**
     * 토스트 창의 zIndex
     *
     * @defaultValue `3000`
     */
    zIndex?: number;
    /**
     * 토스트 창의 스타일 클래스명
     *
     * @defaultValue `'rg-toast'`
     */
    styleName?: string;
}
/**
 * 셀 검색 관련 유연한 설정 모델
 *
 * @remarks
 * {@link GridBase.searchCell} 에서 사용된다.
 *
 * @example
 * ```js
 * function searchCellHandler() {
 *     let value = "PR20012392"
 *     let fields = [ "RequestType", "ServiceCode" ];
 *     let startFieldIndex = fields.indexOf(grid.getCurrent().fieldName) + 1;
 *     let options = {
 *          fields : fields,
 *          value : value,
 *          startIndex : grid.getCurrent().itemIndex,
 *          startFieldIndex : startFieldIndex,
 *          wrap : true,
 *          caseSensitive : false,
 *          partialMatch : true
 *     }
 *     let index = grid.searchCell(options);
 *     grid.setCurrent(index);
 * }
 * ```
 */
interface SearchCellOptions {
    /**
     * 검색할 필드 목록
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능
     */
    fields?: string[];
    /**
     * 지정한 검색 조건값
     */
    value?: string;
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex?: number;
    /**
     * fields 배열에서 검색을 시작할 필드의 인덱스
     *
     * @remarks
     * let fields = ["a", "b", "c", "d"]; const startFieldIndex = 2 인 경우 "c" 필드부터 검색을 시작한다.
     *
     * @defaultValue `0`
     */
    startFieldIndex?: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     *
     * @defaultValue `true`
     */
    wrap?: boolean;
    /**
     * 검색된 행 선택여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * @defaultValue `true`
     */
    select?: boolean;
    /**
     * 대소문자를 구분하여 검색할지의 여부
     *
     * @defaultValue `false`
     */
    caseSensitive?: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch?: boolean;
    /**
     * 필드와 컬럼들 순서가 다를 때 지정하는 컬럼들의 배열
     *
     * @remarks
     * 이곳에 지정한 순서대로 검색이 수행된다.
     * 이 속성 사용시 {@link SearchCellOptions.fields} 는 사용하지 않는다.
     */
    columns?: string[];
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * const f = function(v1, v2, sensitive, partialMatch) {
     *      if (v1 === v2) {
     *           return true;
     *      }
     *      let s1 = String(v1);
     *      let s2 = v2 == null ? undefined : String(v2);
     *      if (!s1 && !s2) {
     *           return true;
     *      }
     *      if (!s1 || !s2) {
     *           return false;
     *      }
     *      if (!caseSensitive) {
     *           s1 = s1.toLowerCase();
     *           s2 = s2.toLowerCase();
     *      }
     *      if (partialMatch) {
     *      	    return s2.indexOf(s1) >= 0;
     *      } else {
     *      	    return s1 == s2;
     *      }
     * }
     *
     * let options = {
     *          fields : fields,
     *          value : value,
     *          compareCallback: f
     * }
     *
     * let index = grid.searchCell(options);
     * ```
     */
    compareCallback?: CompareCallback;
    /**
     * 상위트리의 행 고유 번호
     * {@link LocalTreeDataProvider.searchData | LocalTreeDataProvider} 에서만 사용 가능하다.
     */
    parentId?: number;
}
/**
 * 행 검색 관련 유연한 설정 정보 모델
 *
 * @remarks
 * {@link GridBase.searchItem}에서 사용된다.
 *
 * {@link LocalDataProvider.searchDataRow}, {@link LocalTreeDataProvider.searchDataRow} 에서 사용될 경우, 필터링 되었거나 행 그룹핑 된 경우 감춰진 행들은 찾지 않는다.
 *
 * @example
 *
 * ```js
 * function searchItemHandler() {
 *     let values = ["PR20012392", "QF24212112"]
 *     let fields = [ "RequestType", "ServiceCode" ];
 *     let startFieldIndex = fields.indexOf(grid.getCurrent().fieldName) + 1;
 *     let options = {
 *          fields : fields,
 *          values: values,
 *          startIndex : grid.getCurrent().itemIndex,
 *          startFieldIndex : startFieldIndex,
 *          wrap : true,
 *          caseSensitive : false,
 *          partialMatch : true
 *     }
 *     let index = grid.searchCell(options);
 *     grid.setCurrent(index);
 * }
 * ```
 */
interface SearchOptions {
    /**
     * 검색할 필드 목록
     *
     * @remarks
     * 필드명 또는 필드 인덱스로 지정 가능.
     */
    fields?: string[];
    /**
     * fields 에 지정한 각 필드에 해당하는 순서에 맞게 배열된 검색 조건값
     */
    values?: string[];
    /**
     * 검색 시작 행
     *
     * @defaultValue `0`
     */
    startIndex?: number;
    /**
     * 마지막 행까지 해당하는 행이 없으면 첫 행부터 다시 검색할 것인지 여부
     */
    wrap?: boolean;
    /**
     * 검색된 행 focus 여부
     *
     * @remarks
     * `true`로 지정하면 검색된 행이 있을 때 그 행을 선택하고, 현재 표시된 범위 밖이면 표시되도록 스크롤한다.
     *
     * {@link GridBase.searchItem} 에서만 사용 가능하다.
     *
     * @defaultValue `true`
     */
    select?: boolean;
    /**
     * 해당 조건에 맞는 필드들을 전부 검색할 건지의 여부
     *
     * @remarks
     * `false`면 지정된 fields중 일치하는 필드가 있으면 검색을 종료한다.
     *
     * @defaultValue `true`
     */
    allFields?: boolean;
    /**
     * 대소문자를 구분하여 검색할지의 여부
     *
     * @defaultValue `false`
     */
    caseSensitive?: boolean;
    /**
     * 포함되는 것도 검색할지 여부
     *
     * @defaultValue `false`
     */
    partialMatch?: boolean;
    /**
     * 사용자 정의 조건을 위한 콜백
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * const f = function(v1, v2, sensitive, partialMatch) {
     *      if (v1 === v2) {
     *           return true;
     *      }
     *      let s1 = String(v1);
     *      let s2 = v2 == null ? undefined : String(v2);
     *      if (!s1 && !s2) {
     *           return true;
     *      }
     *      if (!s1 || !s2) {
     *           return false;
     *      }
     *      if (!caseSensitive) {
     *           s1 = s1.toLowerCase();
     *           s2 = s2.toLowerCase();
     *      }
     *      if (partialMatch) {
     *      	    return s2.indexOf(s1) >= 0;
     *      } else {
     *      	    return s1 == s2;
     *      }
     * }
     *
     * let options = {
     *          fields : fields,
     *          values : values,
     *          compareCallback: f
     * }
     *
     * let index = grid.searchItem(options);
     * ```
     */
    compareCallback?: CompareCallback;
    /**
     * 상위트리의 행 고유 번호
     * {@link LocalTreeDataProvider.searchDataRow | LocalTreeDataProvider} 에서만 사용 가능하다.
     */
    parentId?: number;
}
/**
 * 그리드의 전체 설정 정보들
 *
 * @remarks
 * {@link GridBase.getOptions} 시 하위 구성 요소를 재설정하는 것이 불가능하다.
 *
 * {@link GridBase.setOptions} 시 하위 구성 요소를 재설정하는 것이 가능하다.
 *
 * 실질적인 사용은 {@link GridView}, {@link TreeView} 에서 한다.
 *
 * @example
 * ```js
 * let options =  {
 *     summaryMode: 'aggregate',
 *     display: {
 *         columnResizable : false
 *     }
 * };
 * gridView.setOptions(options);
 * ```
 */
interface GridOptions {
    summaryMode?: SummaryMode;
    fixed?: FixedOptions$1;
    display?: DisplayOptions;
    format?: FormatOptions$1;
    edit?: EditOptions$1;
    editor?: EditorOptions$1;
    copy?: CopyOptions$1;
    paste?: PasteOptions$1;
    sorting?: SortingOptions$1;
    filtering?: FilteringOptions;
    dataDrop?: DataDropOptions;
    rowIndicator?: RowIndicator;
    checkBar?: CheckBar;
    stateBar?: StateBar$1;
    header?: GridHeader;
    footer?: GridFooter$1;
    footers?: GridFooterCollection$1;
    headerSummary?: HeaderSummary$1;
    headerSummaries?: HeaderSummaryCollection$1;
}
/**
 * 행 그룹핑에 관련된 설정 모델
 *
 * @remarks
 * 행 그룹핑은 데이터 행들을 하나 이상의 지정한 컬럼의 값을 기준으로 구분 시켜 계층적인 구조로 표시한다.
 *
 * {@link GridBase | 그리드} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * grid.setGroupingOptions({prompt: "I am Groop"});
 * ```
 */
interface GroupingOptions {
    /**
     * 그룹핑 활성화 여부
     */
    enabled?: boolean;
    /**
     * 패널에 표시될 메시지
     *
     * @defaultValue `'컬럼 헤더를 이 곳으로 끌어다 놓으면 그 컬럼으로 그룹핑합니다.'`
     */
    prompt?: string;
    /**
     * 그룹핑 시 그룹의 펼침 여부
     *
     * @defaultValue `true`
     */
    expandWhenGrouping?: boolean;
    /**
     * @alpha
     *
     * @defaultValue `true`
     */
    summarizing?: boolean;
    /**
     * 그룹핑 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeGrouping?: boolean;
    /**
     * 그룹 펼치기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeExpand?: boolean;
    /**
     * 그룹 접기 전 커밋 여부
     *
     * @defaultValue `true`
     */
    commitBeforeCollapse?: boolean;
    /**
     * 머지 된 컬럼 고정 여부
     * @defaultValue `true`
     * @alpha
     */
    fixMergedColumns?: boolean;
    /**
     * toast 관련 설정
     *
     * @defaultValue `{visible: false, message: "Grouping..."}`
     */
    toast?: ToastOptions;
}
/**
 * {@link GridView} 의 전체 설정 정보들
 *
 * @remarks
 * {@link GridOptions} 를 상속한다.
 *
 * [상위 클래스]
 *
 * {@link GridOptions}
 *
 * @example
 * ```js
 * let options =  {
 *     summaryMode: 'aggregate',
 *     display: {
 *         columnResizable : false
 *     },
 *     grouping: {
 *         enabled: false
 *     }
 * };
 * gridView.setOptions(options);
 * ```
 */
interface ViewOptions extends GridOptions {
    grouping?: GroupingOptions;
    groupPanel?: GroupPanel;
}
/**
 * {@link TreeView} 표시에 대한 설정 모델
 *
 * @remarks
 * {@link TreeView} 에서 옵션으로 설정할 때는 필요한 정보만 넣으면 된다.
 *
 * @example
 *
 * ```js
 * tree.setTreeOptions({lineVisible: false});
 * ```
 */
interface TreeOptions$1 {
    /**
     * 트리 라인 표시 여부
     *
     * @defaultValue `true`
     */
    lineVisible?: boolean;
    /**
     * 트리 내부 체크 박스 여부
     *
     * @defaultValue `false`
     */
    showCheckBox?: boolean;
    /**
     * 아이콘으로 사용할 이미지 경로
     */
    iconImagesRoot?: string;
    /**
     * 아이콘으로 사용할 이미지 파일 목록
     *
     * @remarks
     * {@link ImageList} 에 등록된 이름이어야 한다.
     */
    iconImages?: string[];
    /**
     * 아이템의 아이콘 인덱스가 존재하지 않거나, 총 개수를 넘어가면 지정되는 아이콘 인덱스
     *
     * @defaultValue `-1`
     */
    defaultIcon?: number;
    /**
     * 왼쪽 방향키만 눌렀을 때 접힘 여부
     * @remarks
     * 맨 왼쪽에 위치해 있어야한다.
     *
     * @defaultValue `true`
     */
    collapseWhenLeftKey?: boolean;
    /**
     * ctrl 키와 왼쪽 방향키를 함께 눌렀을 때 접힘 여부
     * @remarks
     * {@link TreeOptions.collapseWhenLeftKey | collapseWhenLeftKey} 가 `false` 여도 동작한다.
     *
     * @defaultValue `true`
     */
    collapseWhenCtrlKey?: boolean;
    /**
     * 오른쪽 방향키를 눌렀을 때 펼침 여부
     *
     * @remarks
     * 맨 오른쪽에 위치해 있어야한다.
     *
     * @defaultValue `true`
     */
    expandWhenRightKey?: boolean;
    /**
     * ctrl 키와 오른쪽 방향키를 함께 눌렀을 때 펼침 여부
     * @remarks
     * {@link TreeOptions.expandWhenRightKey | expandWhenRightKey} 가 `false` 여도 동작한다.
     *
     * @defaultValue `true`
     */
    expandWhenCtrlKey?: boolean;
    /**
     * tree icon visible
     *
     * @defaultValue `true`
     */
    iconVisible?: boolean;
    /**
     * 트리 아이템이 펼쳐졌을때 표시되는 아이콘
     *
     * @defaultValue `-1`
     */
    expandedIcon?: number;
    /**
     * 트리 아이템이 접혀있을때 표시되는 아이콘
     *
     * @defaultValue `-1`
     */
    collapsedIcon?: number;
    /**
     * Tree Expander 아이콘의 형태를 지정
     *
     * @defaultValue {@link TreeExpanderStyle.TRIANGLE}
     */
    treeExpanderIconStyle?: TreeExpanderIconStyle;
}

/**
 * @internal
 *
 * 그리드에서 사용자가 데이터를 편집하는 것에 대한 설정 모델
 *
 */
declare class EditOptions extends GridBaseOptions implements EditOptions$1 {
    private _readOnly;
    private _editable;
    private _checkable;
    private _updatable;
    private _appendable;
    private _insertable;
    private _deletable;
    private _revertable;
    private _erasable;
    private _movable;
    private _commitByCell;
    private _editWhenFocused;
    private _commitWhenNoEdit;
    private _commitWhenExitLast;
    private _commitWhenLeave;
    private _crossWhenExitLast;
    private _validateOnEdited;
    private _validateOnExit;
    private _hintOnError;
    private _deleteRowsMessage;
    private _invalidFormatMessage;
    private _showInvalidFormatMessage;
    private _confirmWhenDelete;
    private _editWhenClickFocused;
    private _commitLevel;
    private _useTabKey;
    private _useArrowKeys;
    private _skipReadOnly;
    private _skipReadOnlyCell;
    private _verticalMoveStep;
    private _enterToTab;
    private _enterToNextRow;
    private _enterToEdit;
    private _maxLengthToNextCell;
    private _forceInsert;
    private _forceAppend;
    private _checkDiff;
    private _checkCellDiff;
    private _strictDiff;
    private _deletableWhenEdit;
    private _showCommitError;
    private _firstCellWhenInsert;
    private _appendWhenInsertKey;
    private _appendWhenExitLast;
    private _showOnlyValidationMessage;
    private _displayEmptyEditRow;
    private _buttonClickWhenSpace;
    private _exitGridWhenTab;
    private _cancelWhenLastUndo;
    private _exceptDataClickWhenButton;
    private _removeValidateOnCommit;
    private _validateOnlyEditColumn;
    private _columnEditableFirst;
    private _scrollOnEditing;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 그리드 수준에서 데이터 셀의 값 수정 금지 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue `false`
     *
     */
    get readOnly(): boolean;
    set readOnly(value: boolean);
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * 각 컬럼에서 지정한 readOnly 값 또한 false 여야 수정 가능하다.
     *
     * @defaultValue `false`
     */
    get editable(): boolean;
    set editable(value: boolean);
    /**
     * columnEditableFirst
     */
    get columnEditableFirst(): boolean;
    set columnEditableFirst(value: boolean);
    /**
     * 행의 Checked 상태 변경 가능 여부
     *
     * @remarks
     * `true` 시 CheckBar Cell 을 클릭하여 변경 가능
     *
     * @defaultValue `true`
     */
    get checkable(): boolean;
    set checkable(value: boolean);
    /**
     * 그리드의 데이터 수정 가능 여부
     *
     * @remarks
     * `true` 면 그리드의 데이터들을 수정 할 수 있다.
     * `false` 면 기존 데이터는 수정할 수 없고 새로 추가중인 행 또는 추가된 행만 편집가능하다.
     *
     * @defaultValue `true`
     */
    get updatable(): boolean;
    set updatable(value: boolean);
    /**
     * 행 추가 가능 여부
     *
     * @remarks
     * 그리드 마지막행에서 방향키로 추가 가능
     *
     * @defaultValue `false`
     */
    get appendable(): boolean;
    set appendable(value: boolean);
    /**
     * 행 삽입 가능 여부
     *
     * @remarks
     * `true` 시 Insert 키를 눌러 행 삽입 가능
     *
     * @defaultValue `false`
     */
    get insertable(): boolean;
    set insertable(value: boolean);
    /**
     * 행 삭제 가능 여부
     *
     * @remarks
     * `true` 시 사용자가 Ctrl+Del 키를 누르거나 {@link GridBase.deleteSelection | deleteSelection()} 을 호출해서 현재 선택된 행을 삭제할 수 있다.
     *
     * `deleteSelection(true)` 와 같이 호출하면 해당 옵션과 상관없이 삭제할 수 있다.
     *
     * @defaultValue `false`
     */
    get deletable(): boolean;
    set deletable(value: boolean);
    /**
     * 삭제 취소 가능 여부
     *
     * @remarks
     * {@link DataProviderBase.softDeleting | dataProvider.softDeleting} == true 인 경우, 삭제 상태인 행들을 ctrl+shift+del 키 입력시 원래 상태로 되돌릴 수 있다.
     *
     * @defaultValue `false`
     */
    get revertable(): boolean;
    set revertable(value: boolean);
    /**
     * ?
     *
     * @defaultValue `false`
     */
    get erasable(): boolean;
    set erasable(value: boolean);
    /**
     * movable
     */
    get movable(): boolean;
    set movable(value: boolean);
    /**
     * 셀 단위 수정 후 commit 여부
     *
     * @defaultValue `false`
     */
    get commitByCell(): boolean;
    set commitByCell(value: boolean);
    /**
     * 셀 focus 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    get editWhenFocused(): boolean;
    set editWhenFocused(value: boolean);
    /**
     * 셀이 편집되지 않아도 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    get commitWhenNoEdit(): boolean;
    set commitWhenNoEdit(value: boolean);
    /**
     * Tab 이나 Enter 키로 셀을 벗어날 때 행을 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    get commitWhenExitLast(): boolean;
    set commitWhenExitLast(value: boolean);
    /**
     * 셀의 focus가 벗어날 때 행을 commit 할지의 여부
     *
     * @defaultValue `false`
     */
    get commitWhenLeave(): boolean;
    set commitWhenLeave(value: boolean);
    /**
     * Tab이 이나 Enter 키로 마지막 셀을 벗어날 때 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    get crossWhenExitLast(): boolean;
    set crossWhenExitLast(value: boolean);
    /**
     * 셀 편집이 완료될 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `true`
     */
    get validateOnEdited(): boolean;
    set validateOnEdited(value: boolean);
    /**
     * 셀에서 벗어날 때 컬럼 Validation 실행 여부
     *
     * @defaultValue `false`
     */
    get validateOnExit(): boolean;
    set validateOnExit(value: boolean);
    /**
     * 편집 중에 에러가 있는 셀에 마우스가 위치할 때 에러 힌트 툴팁 표시 여부
     *
     * @defaultValue `true`
     */
    get hintOnError(): boolean;
    set hintOnError(value: boolean);
    /**
     * commit이 성공했을때 편집중인 row의 validation정보가 남아있는 경우 삭제 여부
     *
     * @remarks
     * `true`이면 화면에 표시되고있는 commitLevel보다 낮은수준의 validation정보를 commit을 한 이후 제거한다.
     *
     * @defaultValue `false`
     */
    get removeValidateOnCommit(): boolean;
    set removeValidateOnCommit(value: boolean);
    /**
     * 컬럼이 수정된 경우에만 validation 검증할것인지 여부
     *
     * @remarks
     * `true`이면 수정된 컬럼만 validation을 확인한다.
     *
     * @defaultValue `false`
     */
    get validateOnlyEditColumn(): boolean;
    set validateOnlyEditColumn(value: boolean);
    /**
     * 삭제 대화 상자에 표시할 메세지
     *
     * @defaultValue `'선택된 행(들)을 삭제하시겠습니까?'`
     */
    get deleteRowsMessage(): string;
    set deleteRowsMessage(value: string);
    /**
     * mask 에서 지정한 형태가 아닐 때 표시할 오류 메시지
     *
     * @defaultValue `'잘못된 입력 유형입니다.'`
     */
    get invalidFormatMessage(): string;
    set invalidFormatMessage(value: string);
    /**
     * mask 에서 지정한 형태가 아닐 때 오류 메시지를 보여줄 것인지의 여부
     *
     * @defaultValue `true`
     */
    get showInvalidFormatMessage(): boolean;
    set showInvalidFormatMessage(value: boolean);
    /**
     * 삭제 여부를 묻는 대화 상자의 호출 여부
     *
     * @remarks
     * true시 사용자 삭제나 {@link GridBase.deleteSelection | deleteSelection()} 실행할 때 삭제 여부를 묻는 대화 상자를 먼저 호출한다.
     * GridView.deleteSelection(true)로 호출하면 대화 상자 표시 없이 바로 삭제한다.
     *
     * @defaultValue `true`
     */
    get confirmWhenDelete(): boolean;
    set confirmWhenDelete(value: boolean);
    /**
     * focus 된 셀을 클릭했을 시 편집기 표시 여부
     *
     * @defaultValue `false`
     */
    get editWhenClickFocused(): boolean;
    set editWhenClickFocused(value: boolean);
    /**
     * 행 편집을 완료할 수 있는 최상위 ValidationLvel
     *
     * @defaultValue {@link ValidationLevel.IGNORE}
     */
    get commitLevel(): ValidationLevel;
    set commitLevel(value: ValidationLevel);
    /**
     * Tab 키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    get useTabKey(): boolean;
    set useTabKey(value: boolean);
    /**
     * 방향키로 셀 이동 가능 여부
     *
     * @defaultValue `true`
     */
    get useArrowKeys(): boolean;
    set useArrowKeys(value: boolean);
    /**
     * 컬럼간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    get skipReadOnly(): boolean;
    set skipReadOnly(value: boolean);
    /**
     * 한 컬럼에서 행 간 이동시 readOnly 셀을 건너뛰고 이동할지에 대한 여부.
     *
     * @defaultValue `false`
     */
    get skipReadOnlyCell(): boolean;
    set skipReadOnlyCell(value: boolean);
    /**
     * 컬럼 그룹의 컬럼 셀을 위나 아래로 이동시 동작 방법
     *
     * @remarks
     * 'row' 또는 'cell'이다.
     *
     * @defaultValue `'row'`
     */
    get verticalMoveStep(): VerticalMoveStep;
    set verticalMoveStep(value: VerticalMoveStep);
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 셀로 이동할지의 여부
     *
     * @remarks
     * enterToNextRow == true 시 다음 행으로 이동
     *
     * @defaultValue `false`
     */
    get enterToTab(): boolean;
    set enterToTab(value: boolean);
    /**
     * 셀 편집 중 Enter 키를 입력하면 편집을 완료하고 다음 행으로 이동할지의 여부
     *
     * @defaultValue `false`
     */
    get enterToNextRow(): boolean;
    set enterToNextRow(value: boolean);
    /**
     * focus된 셀이 편집상태가 아닐때 Enter키 를 입력하면 편집상태로 변경한다.
     *
     * @remarks
     * enterToNextRow가 `true` 인경우에는 편집상태로 변경하지 않고 다음 `row`로 이동한다.
     *
     * @defaultValue `false`
     */
    get enterToEdit(): boolean;
    set enterToEdit(value: boolean);
    /**
     * 지정한 자리수 만큼 입력되면 다음 셀로 이동할지의 여부
     *
     * @remarks
     * column.editor.maxLength에 지정한 자리수 만큼 입력되면 다음 셀로 이동된다.
     * editFormat이 있는 경우 보여지는 글자를 기준으로 maxLength가 체크된다. (numberEditor, dateEditor)
     * multiLine의 경우 `\n`과 같이 제어문자도 글자수에 포함된다.
     * editOptions.skipReadOnly가 true 인 경우 readOnly인 셀은 건너뛴다.
     *
     * @defaultValue `false`
     */
    get maxLengthToNextCell(): boolean;
    set maxLengthToNextCell(value: boolean);
    /**
     * 변경된 내용이 없어도 Inserting 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    get forceInsert(): boolean;
    set forceInsert(value: boolean);
    /**
     * 변경된 내용이 없어도 Appending 상태에서 항상 commit 할 건지의 여부
     *
     * @defaultValue `false`
     */
    get forceAppend(): boolean;
    set forceAppend(value: boolean);
    /**
     * 행 편집 완료 시 실제 셀이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * `true` 시 행 편집 완료 요청 시 실제 변경된 셀이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 시 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    get checkDiff(): boolean;
    set checkDiff(value: boolean);
    /**
     * 셀 편집 완료 시 실제 값이 변경 되었을 때 상태 변경 확인 여부
     *
     * @remarks
     * true면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    get checkCellDiff(): boolean;
    set checkCellDiff(value: boolean);
    /**
     * strict 하게 판단하여 셀 편집시 실제 값이 변경 되었는지 확인 여부 (자료형도 같아야함)
     *
     * @remarks
     * `true` 면 셀 편집 완료 요청 시 실제 변경 값이 하나라도 있어야 완료된다.
     * 그렇지 않으면 무시된다.
     * `false` 면 실제 값이 변경되었는 지와 상관없이 사용자 편집 행위가 있었다면 그 행은 변경된 상태가 된다.
     *
     * @defaultValue `false`
     */
    get strictDiff(): boolean;
    set strictDiff(value: boolean);
    /**
     * 셀 편집 시 편집 취소 후 선택된 행 삭제 가능 여부
     *
     * @defaultValue `true`
     */
    get deletableWhenEdit(): boolean;
    set deletableWhenEdit(value: boolean);
    /**
     * commit 오류 발생 시 보여줄 것인지에 대한 여부
     *
     * @defaultValue `true`
     */
    get showCommitError(): boolean;
    set showCommitError(value: boolean);
    /**
     * @alpha
     *
     * @defaultValue `false`
     */
    get firstCellWhenInsert(): boolean;
    set firstCellWhenInsert(value: boolean);
    /**
     * Insert 키로 마지막에 행을 추가할지의 여부
     *
     * @defaultValue `false`
     */
    get appendWhenInsertKey(): boolean;
    set appendWhenInsertKey(value: boolean);
    /**
     * Tab 또는 Enter 키로 마지막 셀을 벗어날 때 행 추가 여부
     *
     * @remarks
     * commitWhenExitLast 가 true 여야 한다.
     *
     * @defaultValue `false`
     */
    get appendWhenExitLast(): boolean;
    set appendWhenExitLast(value: boolean);
    /**
     * 설정한 Validation Error의 메시지만 보여줄지 의 여부
     *
     * @remarks
     * validationError.userMessage 가 존재해야한다.
     *
     * @defaultValue `true`
     */
    get showOnlyValidationMessage(): boolean;
    set showOnlyValidationMessage(value: boolean);
    /**
     * 그리드의 행의 마지막에 항상 빈 행을 추가할지의 여부
     *
     * @remarks
     * 해당 빈 행에 데이터가 입력되고 행 commit()이 발생하면 다시 빈 행이 추가된다.
     *
     * @defaultValue `false`
     */
    get displayEmptyEditRow(): boolean;
    set displayEmptyEditRow(value: boolean);
    /**
     * @alpha
     *
     * @defaultValue `false`
     */
    get buttonClickWhenSpace(): boolean;
    set buttonClickWhenSpace(value: boolean);
    /**
     * @alpha
     *
     * @defaultValue `none`
     */
    get exitGridWhenTab(): ExitGridWhenTab;
    set exitGridWhenTab(value: ExitGridWhenTab);
    /**
     * 편집상태 취소 가능 여부
     *
     * @defaultValue `false`
     */
    get cancelWhenLastUndo(): boolean;
    set cancelWhenLastUndo(value: boolean);
    /**
     * DataCell의 button이 클릭되었을때 onCellClicked 이벤트 발생여부
     * true이면 onCellClicked이벤트를 발생하지 않는다.
     *
     * @defaultValue `false`
     */
    get exceptDataClickWhenButton(): boolean;
    set exceptDataClickWhenButton(value: boolean);
    get scrollOnEditing(): ScrollOnEditing;
    set scrollOnEditing(value: ScrollOnEditing);
    /**
     * @internal
     */
    isWritable(): boolean;
    /**
     * @internal
     */
    canUpdate(created: boolean): boolean;
    /**
     * @internal
     */
    canInsert(): boolean;
    /**
     * @internal
     */
    canAppend(): boolean;
    /**
     * @internal
     */
    canDelete(): boolean;
}
/**
 * 공휴일 지정을 위한 설정 모델
 *
 * @remarks
 * {@link GridBase.setEditorOptions} 을 이용하여 지정하거나 {@link EditorOptions.holidays | grid.editorOptions.holidays} 에 직접 지정할 때 사용된다.
 *
 * {@link DateCellEditor} 에서 사용되기도 한다.
 *
 * @example
 * ```js
 * holidays: [
 *      {
 *          type : "date",
 *          dates : ["2020-01-24","2020-01-25","2020-01-26","2020-01-27"],
 *          styleName: "seollal",
 *          tooltips : ["설날1","설날2","설날3","설날4"]
 *      },
 *   ...
 * ]
 * ```
 */
declare type Holidays = (DateHoliday | DayHoliday)[];
/**
 * 날짜로 지정하는 공휴일
 *
 * ```js
 *  {
 *      type : "date",
 *      dates : ["2020-01-24","2020-01-25","2020-01-26","2020-01-27"],
 *      styleName: "seollal",
 *      tooltips : ["설날1","설날2","설날3","설날4"]
 *  }
 * ```
 */
interface DateHoliday {
    /**
     * 공휴일 유형
     */
    type?: "date";
    /**
     * 날짜들
     */
    dates?: string[];
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * 툴팁들
     */
    tooltips?: string[];
    /**
     * 선택 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
}
/**
 * 요일로 지정하는 공휴일
 *
 * @example
 * ```js
 *  {
 *      type : "day",
 *      days : [0, 4],
 *      styleName: "custom-holiday",
 *      tooltips : ["쉬는 날","쉬는 날"]
 *  }
 * ```
 */
interface DayHoliday {
    /**
     * 공휴일 유형
     */
    type: "day";
    /**
     * 요일들
     *
     * @remarks
     *
     * 월요일 부터 일요일까지 각각 0~6에 해당된다.
     */
    days: number[];
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * 툴팁들
     */
    tooltips?: string[];
    /**
     * 선택 가능 여부
     *
     * @defaultValue `true`
     */
    enabled?: boolean;
}
/**
 * 그리드 수준에서 관리되는 편집기 정보들에 대한 설정 모델
 * @internal
 */
declare class EditorOptions extends GridBaseOptions implements EditorOptions$1 {
    private _yearDisplayFormat;
    private _monthDisplayFormat;
    private _months;
    private _weekDays;
    private _viewGridInside;
    private _titleStatement;
    private _holidays;
    private _titleExprStatement;
    private _titleExprRuntime;
    private _holidayCollection;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 달력 팝업에서의 년의 표시 형태
     *
     * @remarks
     * "년"에 대한 문구만 수정 가능
     * ex) `{Y} Year`
     *
     * @defaultValue `'{Y}년'`
     */
    get yearDisplayFormat(): string;
    set yearDisplayFormat(value: string);
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * "월"에 대한 문구만 수정 가능
     * {@link EditorOptions.months | months } 속성이 지정되면 본 속성은 무시
     * ex) `{M} Month`
     *
     * @defaultValue `'{M}월'`
     */
    get monthDisplayFormat(): string;
    set monthDisplayFormat(value: string);
    /**
     * 달력 팝업에서의 월의 표시 형태
     *
     * @remarks
     * ex) `['Jan', 'Feb', 'Mar', 'Apr', ...]`
     *
     * @defaultValue `null`
     */
    get months(): string[];
    set months(value: string[]);
    /**
     * 달력 팝업에서의 요일의 표시 형태
     *
     * @remarks
     * ex) `['Mon', 'Tue', 'Wed', 'Thu', ...]`
     *
     * @defaultValue `null`
     */
    get weekDays(): string[];
    set weekDays(value: string[]);
    /**
     * editor element와 브러우저의 동시 스크롤 여부
     *
     * @remarks
     * editor element 가 그리드 element 내부에 생성되어 브라우저가 스크롤 되는 경우 함께 스크롤 된다.
     *
     * @defaultValue - `false`
     */
    get viewGridInside(): boolean;
    set viewGridInside(value: boolean);
    /**
     * 편집기의 제목 문구
     *
     * @alpha
     */
    get titleStatement(): string;
    set titleStatement(value: string);
    /**
     * 표시되는 공휴일
     *
     * @defaultValue `null`
     */
    get holidays(): Holidays;
    set holidays(value: Holidays);
}
/**
 * 그리드를 복사할때 클립보드에 저장되는 text를 반환하는 콜백 형식
 *
 * @remarks
 * {@link CopyOptions.copyTextCallback}에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `grid` - GridBase 콘트롤
 *
 * `itemIndex` - 복사되는 행의 itemIndex
 *
 * `column` - {@link DataColumn} 객체
 *
 * [반환값] - 클립보드에 복사될 text `undefined` 를 return 하면 value 또는 copyOptions의 다른 설정값에 따른 text가 복사된다.
 *
 * ```js
 * const f = function(grid, itemIndex, column, value) {
 *      if (value != null && column.name === "number1") {
 *          return value + "";
 *      }
 * }
 * grid.copyOptions.copyTextCallback = f;
 * ```
 */
declare type CopyTextCallback = (grid: GridBase$1, itemIndex: number, column: ValueColumn, value: any) => string;
/**
 * 그리드의 내용을 클립보드를 복사하는 것에 대한 설정 모델
 * @internal
 */
declare class CopyOptions extends GridBaseOptions implements CopyOptions$1 {
    private _enabled;
    private _singleMode;
    private _datetimeFormat;
    private _booleanFormat;
    private _lookupDisplay;
    private _copyDisplayText;
    private _includeHeaderText;
    private _copyTextCallback;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** enabled */
    get enabled(): boolean;
    set enabled(value: boolean);
    /** singleMode */
    get singleMode(): boolean;
    set singleMode(value: boolean);
    /** datetimeFormat */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /** booleanFormat */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /** lookupDisplay */
    get lookupDisplay(): boolean;
    set lookupDisplay(value: boolean);
    /** copyDisplayText */
    get copyDisplayText(): boolean;
    set copyDisplayText(value: boolean);
    /** includeHeaderText */
    get includeHeaderText(): boolean;
    set includeHeaderText(value: boolean);
    /** copyTextCallback */
    get copyTextCallback(): CopyTextCallback;
    set copyTextCallback(value: CopyTextCallback);
}
/**
 * 클립보드의 데이터를 그리드에 붙여넣는 것에 관한 설정 모델
 *
 * @internal
 */
declare class PasteOptions extends GridBaseOptions implements PasteOptions$1 {
    private _enabled;
    private _singleMode;
    private _startEdit;
    private _commitEdit;
    private _enableAppend;
    private _fillFieldDefaults;
    private _fillColumnDefaults;
    private _forceRowValidation;
    private _forceColumnValidation;
    private _datetimeFormats;
    private _booleanFormat;
    private _numberChars;
    private _numberSeparator;
    private _numberCharsOfCols;
    private _numberSeparatorOfCols;
    private _selectionBase;
    private _selectBlockPaste;
    private _stopOnError;
    private _noEditEvent;
    private _noDataEvent;
    private _eventEachRow;
    private _checkReadOnly;
    private _checkDomainOnly;
    private _convertLookupLabel;
    private _applyNumberFormat;
    private _applyEditMask;
    private _applyMaxLength;
    private _applyInputChars;
    private _throwValidationError;
    private _boolReader;
    private _dateReaders;
    private _numberCharExp;
    private _numberCharExpOfCols;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 붙여넣기 가능 여부
     *
     * @defaultValue `true`
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    /**
     * 클립보드의 내용과 상관없이 focus 된 셀 하나에만 값을 붙여 넣을지에 대한 여부
     */
    get singleMode(): boolean;
    set singleMode(value: boolean);
    /**
     * 붙여넣기 할 때 편집 시작 여부
     *
     * @remarks
     * 붙여넣게 될 값이 복수 행이 아니고, 붙여넣을 행이 아직 편집 중이 아니면 편집을 시작한다.
     * `false` 면 이 행에 연결된 데이터 행을 업데이트한다.
     *
     * @defaultValue `true`
     */
    get startEdit(): boolean;
    set startEdit(value: boolean);
    /**
     * 복수 행 붙여넣기일 때 기존 편집 상태 commit 여부
     *
     * @remarks
     * `false` 로 지정하면 기존 편집을 취소한다.
     *
     * @defaultValue `true`
     */
    get commitEdit(): boolean;
    set commitEdit(value: boolean);
    /**
     * 붙여 넣을 여러 행이 기존의 행의 범위를 넘어설 때 행 추가 여부
     *
     * @defaultValue `true`
     */
    get enableAppend(): boolean;
    set enableAppend(value: boolean);
    /**
     * 포함되지 않은 필드의 값을 데이터 필드의 기본값으로 채워 넣을지에 대한 여부
     *
     * @defaultValue false
     */
    get fillFieldDefaults(): boolean;
    set fillFieldDefaults(value: boolean);
    /**
     * 포함되지 않은 필드의 값을 컬럼의 기본값으로 채워 넣을지에 대한 여부
     *
     * @remarks
     * {@link PasteOptions.fillFieldDefaults | fillFieldDefaults} 가 true라면 데이터필드의 기본값을 먼저 적용한 후 컬럼 기본값을 적용한다.-active
     *
     * @defaultValue false
     */
    get fillColumnDefaults(): boolean;
    set fillColumnDefaults(value: boolean);
    /**
     * 복수 행 붙여 넣기 중 행별로 행 validation을 실행할 것인지의 여부
     *
     * @defaultValue false
     */
    get forceRowValidation(): boolean;
    set forceRowValidation(value: boolean);
    /**
     * 복수 행 붙여 넣기 중 행별로 컬럼 validation을 실행할 것인지의 여부
     *
     * @remarks
     * {@link PasteOptions.forceRowValidation | forceRowValidation} 이 `true`면 행 validation을 먼저 실행한다.
     *
     * @defaultValue `false`
     */
    get forceColumnValidation(): boolean;
    set forceColumnValidation(value: boolean);
    /**
     * 데이터 필드에 지정된 datetimeFormat 외에 datetime 필드값으로 변환할 때 사용할 형식들
     *
     * @defaultValue `null`
     */
    get datetimeFormats(): string[];
    set datetimeFormats(value: string[]);
    /**
     * dateReaders
     * @internal
     */
    get dateReaders(): DateTimeReader[];
    /**
     * 데이터 필드에 지정된 booleanFormat 외에 boolean 필드값으로 변환할 때 사용할 형식
     *
     * @defaultValue `null`
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * boolReader
     * @internal
     */
    get boolReader(): BooleanConverter;
    /**
     * number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * 지정한 문자열들을 모두 빈 문자열로 치환한 후 숫자로 변환한다.
     *
     * @defaultValue `null`
     */
    get numberChars(): string[];
    set numberChars(value: string[]);
    /**
     * number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `'.'`
     *
     * @defaultValue `null`
     */
    get numberSeparator(): string;
    set numberSeparator(value: string);
    /**
     * 컬럼별로 number 필드값으로 변환할 때 에러로 판단하지 않고 무시해도 되는 하나 이상의 문자열들
     *
     * @remarks
     * ex) `{"column1": [",", "kr"], "column2": [" ", "$"]}`
     *
     * @defaultValue `{}`
     */
    get numberCharsOfCols(): {
        [key: string]: string[];
    };
    set numberCharsOfCols(value: {
        [key: string]: string[];
    });
    /**
     * numberCharExp
     * @internal
     */
    get numberCharExp(): RegExp;
    /**
     * 컬럼별로 number 필드값으로 변환할 때 소수점으로 표시되는 문자
     *
     * @remarks
     * ex) `{"column1": ".", "column2": ","}`
     *
     * @defaultValue `null`
     */
    get numberSeparatorOfCols(): {
        [key: string]: string;
    };
    set numberSeparatorOfCols(value: {
        [key: string]: string;
    });
    /**
     * 붙여넣기 시작 위치
     *
     * @remarks
     * `true` 시 focus 셀이 포함된 선택 영역의 처음 셀부터 붙여넣기
     *
     * `false` 시 focus 셀 부터 붙여넣기
     *
     * @defaultValue `false`
     */
    get selectionBase(): boolean;
    set selectionBase(value: boolean);
    /**
     * 여러 개 셀에 붙여넣기 가능 여부
     *
     * @remarks
     * 하나의 셀을 복사후 여러 개의 셀에 붙여넣기 할 수 있다.
     *
     * @defaultValue `false`
     */
    get selectBlockPaste(): boolean;
    set selectBlockPaste(value: boolean);
    /**
     * Validation이 실패하거나 형변환이 실패 시 붙여넣기 중지 여부
     *
     * @remarks
     * `false` 시 계속 진행하되, 에러가 있는 행은 건너뛰고 붙여넣기한다.
     *
     * @defaultValue `false`
     */
    get stopOnError(): boolean;
    set stopOnError(value: boolean);
    /**
     * {@link GridBase.onEditRowChanged | onEditRowChanged }, {@link GridBase.onCellEdited | onCellEdited} 의 발생 여부
     *
     * @remarks
     * {@link GridBase.onEditRowPasted | onEditRowPasted } 는 지정여부와 상관없이 항상 발생
     *
     * @defaultValue `false`
     */
    get noEditEvent(): boolean;
    set noEditEvent(value: boolean);
    /**
     * 여러 줄의 데이터 붙여넣기 도중 refresh 실행 여부
     *
     * @remarks
     * 붙여넣기를 하는 중에는 refresh되지 않아 속도가 개선된다.
     *
     * @defaultValue `false`
     */
    get noDataEvent(): boolean;
    set noDataEvent(value: boolean);
    /**
     * 여러 행 붙여넣기 시 행 수 만큼 {@link GridBase.onEditRowPasted | onEditRowPasted } 이벤트의 발생 여부
     *
     * @defaultValue `false`
     */
    get eventEachRow(): boolean;
    set eventEachRow(value: boolean);
    /**
     * readOnly이거나 editable이 `false`인 컬럼은 paste 대상에서 제외 여부
     *
     * @defaultValue `false`
     */
    get checkReadOnly(): boolean;
    set checkReadOnly(value: boolean);
    /**
     * DropDown Editor 의 domainOnly 가 `true`인 컬럼에 붙여넣기 할때 values 에 없는 값 붙여넣기 제외 여부
     *
     * @defaultValue `false`
     */
    get checkDomainOnly(): boolean;
    set checkDomainOnly(value: boolean);
    /**
     * DropDown Editor 에 label값을 붙여넣는 경우 value 로 변환해서 저장할지의 여부
     *
     * @defaultValue `false`
     */
    get convertLookupLabel(): boolean;
    set convertLookupLabel(value: boolean);
    /**
     * 붙여넣기 시 editFormat이 있으면 editFormat 형태로, 없으면 styles.numberFormat 형태로 붙여넣기 된다.
     *
     * @defaultValue `false`
     */
    get applyNumberFormat(): boolean;
    set applyNumberFormat(value: boolean);
    /**
     * mask에 붙여넣을 수 없는 경우 붙여넣기 제한 여부
     *
     * @remarks
     * mask의 입력자리수보다 긴 경우 mask에 들어가는 자리를 제외하고 붙여넣기가 된다.
     *
     * @defaultValue `false`
     */
    get applyEditMask(): boolean;
    set applyEditMask(value: boolean);
    /**
     * 붙여넣기 시 editor.maxLength, maxLengthExceptComma 적용 여부
     *
     * @defaultValue `false`
     */
    get applyMaxLength(): boolean;
    set applyMaxLength(value: boolean);
    /**
     * applyInputChars
     */
    get applyInputChars(): boolean;
    set applyInputChars(value: boolean);
    /**
     * ValidationError 를 발생시킬지 여부
     *
     * @defaultValue `true`
     */
    get throwValidationError(): boolean;
    set throwValidationError(value: boolean);
    /**
     * numberCharExpOfCol
     * @internal
     */
    numberCharExpOfCol(col: string): RegExp;
    /**
     * numberSeparatorOfCol
     * @internal
     */
    numberSeparatorOfCol(col: string): string;
}
/**
 * 모바일 관련 설정 모델
 *
 * @internal
 */
declare class MobileOptions extends GridBaseOptions implements MobileOptions$1 {
    private _longTapDuration;
    private _doubleTapInterval;
    private _tapThreshold;
    private _showEditCommander;
    private _showTooltip;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 롱 탭으로 인식하기 위한 최소 시간
     *
     * @defaultValue `500`
     */
    get longTapDuration(): number;
    set longTapDuration(value: number);
    /**
     * 더블 탭이 발생하기 위한 탭 간 최대 시간
     *
     * @defaultValue `300`
     */
    get doubleTapInterval(): number;
    set doubleTapInterval(value: number);
    /**
     * 탭 간 동일 탭으로 인지하는 영역범위
     *
     * @defaultValue `4`
     */
    get tapThreshold(): number;
    set tapThreshold(value: number);
    /**
     * 편집 커맨더를 보여줄지에 대한 여부
     *
     * @defaultValue `true`
     */
    get showEditCommander(): boolean;
    set showEditCommander(value: boolean);
    /**
     * 모바일에서 툴팁을 보여줄 건지에 대한 여부
     *
     * @remarks
     * 다른 툴팁 설정들이 `true`여야 한다.
     *
     * @defaultValue `false`
     */
    get showTooltip(): boolean;
    set showTooltip(value: boolean);
    /**
     * 모바일에서 편집 중 일때 스크롤 시 처리 상태
     */
    get scrollOnEditing(): ScrollOnEditing;
    set scrollOnEditing(value: ScrollOnEditing);
}

/**
 * @public
 * 텍스트나 날짜 필드에 적용할 수 있는 편집기의 오브젝트 형태 표시 형식
 *
 * @remarks
 * {@link ValueColumn.editor} 를 적용할 때, 에디터의 {@link TextCellEditor.mask | mask} 속성에서 사용된다.
 *
 * 숫자 필드는 {@link NumberCellEditor.editFormat} 을 사용한다.
 *
 * 마크스에 적용된 형식은 편집기에만 표시된다.
 *
 * {@link DropDownCellEditor | dropDown}, {@link MultiLineCellEditor | multiLine}, {@link MultiCheckCellEditor | multiCheck}, {@link NumberCellEditor | number Editor} 에서는 동작하지 않는다.
 *
 * @example
 * ```js
 * column.editor = {
 *      type: 'line',
 *      mask: {
 *          editMask: '9999-99-99',
 *          placeHolder: 'input...'
 *      }
 * }
 * ```
 */
interface EditMaskObject {
    /**
     * 편집기에 표시된 내용이 그대로 셀 값으로 전달되는지의 여부
     *
     * @defaultValue `false`
     */
    includedFormat: boolean;
    /**
     * 편집기의 placeHolder
     */
    placeHolder: string;
    /**
     * "0000-00-00" 등으로 표시되는 형식
     *
     * @remarks
     * 기본적으로 제공하는 형식은 다음의 정규식과 같다.
     *
     * `9`: `new RegExp("[0-9 ]")`
     *
     * `0`: `new RegExp("[0-9]")`
     *
     * `a`: `new RegExp("[A-Za-z]")`
     *
     * `*`: `new RegExp("[A-Za-z0-9]")`
     */
    editMask: string;
    /**
     * 정의 되어있는 마스크 형식
     *
     * @remarks
     * 기본적으로 제공되는 "9", "0", "a", "*" 외에 개발자가 추가로 정의하고 싶은 경우나 수정하고 싶은 경우 사용한다.
     *
     * @example
     * ```js
     * definitions: {"h": "[a-h]"} //"h"는 a~h까지 입력 가능하다.
     * ```
     */
    definitions: any;
    /**
     * 잘못된 형식이 입력되었을 때 표시할 메세지
     */
    invalidFormatMessage: string;
    /**
     * 잘못된 형식이 입력되었을때 메시지 표시 유무
     */
    showInvalidFormatMessage: boolean;
    /**
     * 입력시 기존 문자를 덮어쓰기 여부
     *
     * @defaultValue `false`
     */
    overWrite: boolean;
    /**
     * mask 가 0로 설정된 경우 빈값 `''`의 허용 여부
     */
    allowEmpty: boolean;
    /**
     * 중간부터 입력 중단 여부
     *
     * @defaultValue `false`
     */
    restrictNull: boolean;
}
/**
 * @public
 * 셀 편집기들의 기반이 되는 모델
 *
 * @remarks
 * 셀 편집기 별로 지정할 수 있는 속성이 있으며, DataColumn 에 지정하지 않을 시 {@link LineCellEditor} 가 기본으로 설정된다.
 *
 * 또, 오브젝트 형태일 때의 `type` 속성을 {@link ValueColumn.editor | column.editor} 에 문자열 형태로 지정 가능하다.
 *
 * [목록]
 *
 * {@link LineCellEditor}: 한 줄 입력 편집기
 *
 * {@link PasswordCellEditor}: 암호 입력 편집기
 *
 * {@link MultiLineCellEditor}: 여러 줄 입력 편집기
 *
 * {@link NumberCellEditor}: 숫자 입력 편집기
 *
 * {@link DateCellEditor}: 날짜 편집기
 *
 * {@link BTDateCellEditor}: 부트스트랩 날짜 편집기
 *
 * {@link DropDownCellEditor}: 드롭 다운 편집기
 *
 * {@link SearchCellEditor}: 검색 기능이 추가 된 드롭 다운 편집기
 *
 * {@link MultiCheckCellEditor}: 여러 항목이 선택 가능한 드롭 다운 편집기
 *
 * @warning CellEditor 로 직접 설정하거나 호출할 수 없다.
 *
 * @example
 *
 * ```js
 * // string type
 * column.editor = "line"
 *
 * // object type
 * column.editor = { type: "line", maxLength: 1}
 * ```
 */
interface CellEditor$1 {
    /**
     * 셀 편집기 종류
     *
     * @remarks
     *
     * {@link LineCellEditor}: "line" 또는 "text"
     *
     * {@link PasswordCellEditor}: "password"
     *
     * {@link MultiLineCellEditor}: "multiline"
     *
     * {@link NumberCellEditor}: "number"
     *
     * {@link DateCellEditor}: "date"
     *
     * {@link BTDateCellEditor}: "btdate"
     *
     * {@link DropDownCellEditor}: "dropdown" 또는 "list"
     *
     * {@link SearchCellEditor}: "search"
     *
     * {@link MultiCheckCellEditor}: "checklist"
     */
    type?: string;
    /**
     * 값이 비었을 때 표시되는 값
     */
    emptyValue?: any;
    /**
     * 편집기의 입력되는 문자의 대소문자 구분 형태
     *
     * @remarks
     * 편집기에 입력되는 문자를 자동으로 대소문자로 변경한다.
     * {@link TextInputCase.DEFAULT} 로 지정하면 컬럼의 textInputCase에 지정한 값을 따르게 된다.
     */
    textCase?: TextInputCase;
    /**
     * 날짜 형식의 값일 때 표시되는 편집기의 서식
     *
     * @remarks
     * 데이터 필드가 날짜 타입일 때 작동
     */
    datetimeFormat?: string;
    /**
     * 편집기에서 현재 날짜를 입력하도록 하는 문자
     *
     * @remarks
     * 데이터 필드가 날짜 타입이거나, 텍스트 타입이지만 날짜 편집기일 때 동작한다.
     *
     */
    todayChar?: string;
    /**
     * @alpha
     * 편집기에 입력했을 때 지금에 해당하는 문자
     *
     * @remarks
     * 데이터 필드가 날짜 타입이거나, 편집기가 날짜 편집기일 때 동작한다.
     */
    nowChar?: string;
    /**
     * Boolean 값일 때 표시되는 편집기의 서식
     *
     * @remarks
     * 데이터 필드가 boolean 타입일 때 동작한다.
     */
    booleanFormat?: string;
    /**
     * 데이터 셀의 값 수정 가능 여부
     *
     * @remarks
     * `true` 일 때
     *
     * @defaultValue `false`
     */
    readOnly?: boolean;
}

/** @internal */
interface EditController {
    readOnly: boolean;
    editable: boolean;
    editIndex: CellIndex;
    editing: boolean;
    editValue: any;
    dispose(): null;
    setFocus(force: boolean, target?: HTMLElement): void;
    invalidateEditor(): void;
    resetEditor(resetValue: boolean): boolean;
    prepareEditor(index: CellIndex): void;
    requestPrepareEditor(): void;
    reprepareEditor(index: CellIndex): void;
    resetEditable(index: CellIndex): void;
    showEditor(index: CellIndex, dropdown: boolean): boolean;
    showList(index: CellIndex): boolean;
    fillSearchItems(column: GridColumn, searchKey: string, values: string[], labels: string[]): void;
    buttonClicked(index: CellIndex, event?: Event): void;
    buttonDown(index: CellIndex, event: Event): void;
    buttonUp(index: CellIndex, event: Event): void;
    hideEditor(): void;
    cancelEditor(hideEditor: boolean): void;
    commitEditor(hideEditor: boolean, throwError: boolean, editFocusing?: boolean): boolean;
    closeList(accept: boolean): void;
    caretToLast(): void;
    getData(index: CellIndex): any;
    focusedIndexChanging(): boolean;
    focusedIndexChanged(oldIndex: CellIndex, newIndex: CellIndex, prepare: boolean): void;
    setEditValue(value: any, dropDown: any): void;
    onEditorStart(editor: CellEditor): boolean;
    onEditorKeyDown(editor: CellEditor, event: KeyboardEvent): boolean;
    onEditorKeyPress(editor: CellEditor, event: KeyboardEvent): boolean;
    onEditorKeyUp(editor: CellEditor, event: KeyboardEvent): boolean;
    onEditorChange(editor: CellEditor): void;
    onEditorSearch(editor: CellEditor, text: string): void;
    onSearchCellButtonClick(editor: CellEditor, text: string): boolean;
    onEditorCommit(editor: CellEditor): boolean;
}
/** @internal */
declare abstract class CellEditor extends EventAware {
    static readonly Unselected: {};
    static readonly InvalidFormat: {};
    static readonly EDITOR_CSS = "rg-editor ";
    private static readonly CONTAINER_CSS;
    static getEditorType(cfg: any): string;
    static getEditorType2(cfg1: any, cfg2: any): string;
    protected _emptyValue: any;
    protected _textCase: TextInputCase;
    private _datetimeFormat;
    private _todayChar;
    private _nowChar;
    private _booleanFormat;
    protected _readOnly: boolean;
    protected _textReadOnly: boolean;
    protected _allowEmpty: boolean;
    protected _grid: GridBase$1;
    protected _isMobile: boolean;
    protected _options: EditorOptions;
    protected _parentElement: HTMLElement;
    protected _container: HTMLDivElement;
    protected _editor: HTMLElement;
    protected _editIndex: CellIndex;
    protected _controller: EditController;
    protected _started: boolean;
    protected _oldValue: any;
    protected _dateConverter: DateTimeConverter;
    private _saveDateConverter;
    private _boolConverter;
    private _saveBoolConverter;
    protected _cellBounds: Rectangle;
    protected _checkHangeul: boolean;
    protected _mask: EditMask;
    protected _composing: boolean;
    constructor(grid: GridBase$1, parentElement: HTMLElement);
    protected _doDispose(): void;
    get native(): boolean;
    get buttonCount(): number;
    get hasList(): boolean;
    /** emptyValue */
    get emptyValue(): any;
    set emptyValue(value: any);
    /** textCase */
    get textCase(): TextInputCase;
    set textCase(value: TextInputCase);
    /** dateTimeFormat */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /** todayChar */
    get todayChar(): string;
    set todayChar(value: string);
    /** nowChar */
    get nowChar(): string;
    set nowChar(value: string);
    /** booleanFormat */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /** editor */
    get editor(): HTMLElement;
    /** visible */
    get visible(): boolean;
    setVisible(value: boolean, force?: boolean): void;
    protected _doVisibleChanged(visible: boolean): void;
    /** readOnly */
    get readOnly(): boolean;
    set readOnly(value: boolean);
    /** textReadOnly */
    get textReadOnly(): boolean;
    protected _setTextReadOnly(value: boolean): void;
    /** allowEmpty */
    get allowEmpty(): boolean;
    protected _setAllowEmpty(value: any): void;
    /** editing */
    get editing(): boolean;
    /** editIndex */
    get editIndex(): CellIndex;
    /** value */
    get value(): any;
    /** listing */
    get listing(): boolean;
    hasButton(showNative: boolean, cfg: ConfigObject): boolean;
    applyOptions(options: any): void;
    setEditIndex(value: CellIndex): void;
    setController(value: EditController): void;
    prepare(): void;
    unprepare(): void;
    beginEdit(clear: boolean, select: boolean): void;
    endEdit(): void;
    isEdited(): boolean;
    isDisabled(): boolean;
    caretToLast(): void;
    commit(): void;
    setReadOnly(value: boolean): void;
    getEditValue(throwError?: boolean, validateValue?: boolean): any;
    setEditValue(value: any): void;
    setCellEditValue(value: any, dropdown: boolean): void;
    getEditText(): string;
    selectAll(force?: boolean): void;
    clear(): void;
    setFocus(): void;
    abstract setEditorZIndex(active: boolean): void;
    /**
     * @alpha
     */
    setEditorTitle(index: CellIndex): void;
    setBounds(x: number, y: number, w: number, h: number, inputWidth: number): void;
    setCellBounds(x: number, y: number, w: number, h: number): void;
    closeList(accept: boolean): void;
    dropDownList(force: boolean): void;
    buttonClicked(index: CellIndex, event?: Event): void;
    buttonDown(index: CellIndex, event: Event): void;
    buttonUp(index: CellIndex, event: Event): void;
    setButtonStyle(elt: HTMLElement, idx: number, vertical: boolean, right: number, width: number): boolean;
    protected abstract _createEditor(parentElement: HTMLElement): HTMLElement;
    protected abstract _getInputSelector(): string;
    initOptions(): void;
    private $_setEditorId;
    protected _changed(): void;
    private $_setController;
    protected _editField(): DataField;
    protected _isDateEditor(): boolean;
    protected abstract _selectAll(): void;
    protected abstract _doBeginEdit(): boolean;
    protected abstract _doEndEdit(): void;
    protected abstract _doCommit(): void;
    protected abstract _doChanged(): void;
    protected _requestStart(dropDown?: boolean): boolean;
    protected _valToStr(value: any): string;
    protected _strToVal(s: string): any;
    protected _dispatchKeyDown(event: KeyboardEvent): boolean;
    protected _dispatchKeyPress(event: KeyboardEvent): boolean;
    protected _dispatchKeyUp(event: KeyboardEvent): boolean;
    protected _dispatchChange(): void;
    protected _dispatchSearch(text: string): void;
    protected _dispatchSearchCellButtonClick(text: string): boolean;
    protected _dispatchCommit(): void;
    protected _sendToParent(e: any, flag?: any, nohandle?: boolean): boolean;
    protected _commitListValue(value: any): void;
}
/**
 * 별도로 interface
 * @internal
 */
declare class EditMask implements EditMaskObject {
    private _includedFormat;
    private _placeHolder;
    private _editMask;
    private _invalidFormatMessage;
    private _showInvalidFormatMessage;
    private _overwrite;
    private _allowEmpty;
    private _restrictNull;
    private _editor;
    private _definitions;
    private _tests;
    private _buffer;
    private _defBuffer;
    private _pStart;
    constructor(editor: CellEditor, options: any);
    /**
     * @internal
     */
    dispose(): any;
    /**
     * 편집기에 표시된 내용이 그대로 셀 값으로 전달되는지의 여부
     *
     * @defaultValue `false`
     */
    get includedFormat(): boolean;
    set includedFormat(value: boolean);
    /**
     * 편집기의 placeHolder
     */
    get placeHolder(): string;
    set placeHolder(value: string);
    /**
     * "0000-00-00" 등으로 표시되는 형식
     *
     * @remarks
     * 기본적으로 제공하는 형식은 다음의 정규식과 같은 의미이다.
     * `9` - `new RegExp("[0-9 ]")`
     * `0` - `new RegExp("[0-9]")`
     * `a` - `new RegExp("[A-Za-z]")`
     * `*` - `new RegExp("[A-Za-z0-9]")`
     */
    get editMask(): string;
    set editMask(value: string);
    /**
     * 정의 되어있는 마스크 형식
     *
     * @remarks
     * 기본적으로 제공되는 "9", "0", "a", "*" 외에 개발자가 추가로 정의하고 싶은 거나 수정하고 싶은 경우 사용한다.
     *
     * @example
     * ```js
     * definitions: {"h": "[a-h]"} //"h"는 a~h까지 입력 가능하다.
     * ```
     */
    get definitions(): any;
    set definitions(value: any);
    /**
     * 잘못된 형식이 입력되었을 때 표시할 메세지
     */
    get invalidFormatMessage(): string;
    set invalidFormatMessage(value: string);
    /**
     * 잘못된 형식이 입력되었을때 메시지 표시 유무
     */
    get showInvalidFormatMessage(): boolean;
    set showInvalidFormatMessage(value: boolean);
    /**
     * 입력시 기존 문자를 덮어쓰기 여부
     *
     * @defaultValue `false`
     */
    get overWrite(): boolean;
    set overWrite(value: boolean);
    /**
     * mask가 0로 설정된 경우 빈값 ""의 허용여부
     */
    get allowEmpty(): boolean;
    set allowEmpty(value: boolean);
    /**
     * 중간부터 입력되지 않을 지의 여부
     *
     * @defaultValue `false`
     */
    get restrictNull(): boolean;
    set restrictNull(value: boolean);
    /**
     * @internal
     * @param event -
     */
    clickHandler(event: Event): void;
    /**
     * @internal
     * @param begin -
     * @param end -
     */
    clearBuffer(begin?: number, end?: number): void;
    /**
     * @internal
     * @param value -
     * @param isPaste -
     */
    writeBuffer(value?: string, isPaste?: boolean): string;
    /**
     * @internal
     */
    getStripValue(): string;
    /**
     * @internal
     * @param options -
     */
    setOptions(options: any): void;
    /**
     * @internal
     */
    checkValid(): boolean;
    /**
     * @internal
     */
    protected _changed(): void;
    /**
     * @internal
     * @param start -
     * @param end -
     */
    protected _moveCaret(start?: number, end?: number): boolean;
    private $_setCaret;
    private $_parseDefinitions;
    private $_parseMask;
    private $_getPlaceHolder;
    private $_seekPrev;
    private $_seekNext;
    private $_shiftL;
    private $_shiftR;
    private keydown;
    private keyPress;
    private input;
}

/** @internal */
declare class GridDelegate extends Base {
    private _grid;
    private _defaultEditor;
    private _cellEditors;
    private _customRenderers;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    getDefaultCellEditor(): CellEditor;
    getCellEditor(editorType: string): CellEditor;
    private $_checkFlexible;
    createRenderer(rendererType: string, cfg1: any, cfg2: any): DataCellRenderer;
    addCustomRenderer(type: string, renderer: any): void;
    removeCustomRenderer(type: string): void;
    existsCustomRenderer(type: string): boolean;
    clearCustomRenderers(): void;
}

/**
 * {@link FormView} 에 관한 설정 모델
 */
interface FormOptions$1 {
    /**
     * modal 스타일로 FormView 를 보여줄 것인지의 여부
     *
     * @defaultValue `false`
     */
    modal: boolean;
    /**
     * modal 의 padding 간격
     *
     * @remarks
     * 4개 일 경우: `top`, `right`, `bottom`, `left` 순서대로 지정된다.
     *
     * 3개 일 경우: `top`, `left / right`, `bottom` 순서대로 지정된다.
     *
     * 2개 일 경우: `top / bottom`, `left / right` 순서대로 지정된다.
     *
     * 1개 일 경우: `top / bottom/ left / right` 의 간격을 지정한다.
     *
     * @defaultValue `'10%'`
     *
     * @example
     * ```js
     * // 4개
     * "50% 30 25% 40"
     * // 3개
     * "50% 30 25% "
     * // 2개
     * "50% 30"
     * // 1개
     * "50%"
     * ```
     */
    modalPadding: string;
    /**
     * modal 의 불투명도
     *
     * @remarks
     * 0 부터 1 사이의 값이다.
     */
    modalOpacity: number;
    /**
     * 값 수정후 save 나 cancel 시 자동으로 화면으로 닫히게 할지의 여부
     *
     * @defaultValue `false`
     */
    autoClose: boolean;
    /**
     * form 화면에서 편집 가능 여부
     *
     * @defaultValue `true`
     */
    editable: boolean;
    /**
     * 아이템 크기 조정 가능 여부
     *
     * @defaultValue `true`
     */
    itemResizable: boolean;
    /**
     * Label 의 최소 너비
     *
     * @defaultValue `60`
     */
    minLabelWidth: number;
    /**
     * focus 표시를 보이게 할지의 여부
     *
     * @defaultValue `true`
     */
    focusVisible: boolean;
    /**
     * 스크롤 바의 너비
     *
     * @defaultValue `9`
     */
    scrollBarWidth: number;
    /**
     * Swipe 할 때 커밋할 것인지의 여부
     *
     * @defaultValue `false`
     */
    commitWhenSwipe: boolean;
    /**
     * @internal
     * 실제 toProxy() 는 `FormView.ts` 의 FormOptions 의 toProxy() 를  찾아갈 것
     * FormView 에 대한 정책이 정해지면 그때 interface 에서 제거 하든 말든 결정
     */
    toProxy(): any;
    /**
     * 저장 버튼을 클릭하면 호출된다.
     *
     * @defaultValue `null`
     *
     */
    commitCallback: FormViewButtonCallback;
    /**
     * 취소 버튼을 클릭하면 호출된다.
     *
     * @defaultValue `null`
     */
    cancelCallback: FormViewButtonCallback;
}
/**
 * 모바일에 최적화 된 화면 모델
 *
 * @remarks
 * {@link GridBase.formView} 로 접근 할 수 있다.
 *
 * @example
 * ```js
 * let form = gridView.formView;
 * form.visible = true;
 * form.options.modal = true;
 * form.options.modalPadding = "10% 8%";
 * form.options.autoClose = true;
 *
 * let formModel = {
 *      items:[{
 *             header: "이름",
 *             column: "KorName"
 *         },
 *         {
 *             header: "성별",
 *             column: "SexLabel"
 *         },
 *         {
 *             header: "주문일",
 *             column: "OrderDate"
 *         },
 *         {
 *             header: "Address",
 *             template: "<span>Good!<br>121212</span>"
 *         },
 *         "Email"
 *      }]
 * }
 * form.setModel(formModel);
 * ```
 */
interface FormView$1 {
    /**
     * FormView 표시 여부
     *
     * @remarks
     * `true` 지정 시 FormView 를 해당 그리드 위에 표시한다.
     *
     * @defaultValue `false`
     */
    visible: boolean;
    /**
     * 현재 화면을 보여주고 있는 페이지 (그리드에서의 행)
     *
     * @example
     * ```js
     * // 첫번째 페이지로 돌아가기
     * formView.currentRow = 0;
     * ```
     */
    currentRow: number;
    /**
     * 해당 FormView 의 설정 정보
     *
     * @remarks
     * {@link FormOptions} 의 속성을 가져오거나 설정할 수 있다.
     */
    options: FormOptions$1;
    /**
     * 화면 구성을 설정한다.
     *
     * @example
     * ```js
     * form.setModel({
     *     items: [
     *         {
     *             header: "이름",
     *             column: "KorName"
     *         },
     *         {
     *             header: "성별",
     *             column: "SexLabel"
     *         },
     *         {
     *             header: "주문일",
     *             column: "OrderDate"
     *         },
     *         {
     *             header: "납입금",
     *             column: "SaveCost"
     *         },
     *         {
     *             header: "만기금액",
     *             column: "SaveMaturity"
     *         }
     *     ]
     * });
     * ```
     */
    setModel(value: FormModel): any;
}
/**
 * {@link FormView} 의 화면 구성을 생성하기 위한 설정 모델
 *
 * @example
 * ```js
 * {
 *      footer: {
 *          popupMenu: "menuForm"
 *      },
 *      items: [{
 *          header: "이름",
 *          column: "KorName"
 *      },
 *      {
 *          header: "성별",
 *          column: "SexLabel"
 *      },
 *      ...
 *      ]
 * }
 * ```
 */
interface FormModel {
    /**
     * @alpha
     *
     */
    title?: FormHeader;
    /**
     * 화면에 배치되는 푸터 영역 모델
     */
    footer?: FormFooter;
    /**
     * @alpha
     */
    body?: FormBody;
    /**
     * 화면에 배치되는 아이템들의 모델
     *
     * @remarks
     * 오브젝트 또는 문자열 형태로 설정 가능 하다.
     */
    items?: FormItem[];
}
/**
 * {@link FormView} 의 아이템 설정 모델
 *
 * @remarks
 * 문자열로 설정하면 {@link FormItemObject.column} 으로 설정하여 FromItem 을 생성한다.
 *
 * @example
 * ```js
 * items:[{
 *        header: "이름",
 *        column: "KorName"
 *    },
 *    {
 *        header: "Address",
 *        template: "<span>Good!<br>121212</span>"
 *    },
 *    "Email" // 문자열로 설정
 * }]
 * ```
 */
declare type FormItem = string | FormItemObject;
/**
 * {@link FormView} 의 오브젝트 형식의 아이템 설정 모델
 *
 * @remarks
 * {@link FormItem} 에 포함된다.
 *
 * @example
 * ```js
 * {
 *      items: [{
 *               header: "이름",
 *               column: "KorName"
 *           },
 *           {
 *               header: "성별",
 *               column: "SexLabel"
 *           },
 *           ...
 *      }]
 * }
 * ```
 */
interface FormItemObject {
    /**
     * 해당 아이템이 표시될 때의 헤더 텍스트
     *
     * @remarks
     * 설정하지 않을 시 `column` (컬럼명) 으로 설정
     */
    header?: string;
    /**
     * 해당 아이템의 값을 표시하기 위한 컬럼명
     *
     * @remarks
     * 이 값을 지정하면 {@link FormItemObject.template} 을 사용할 수 없다.
     *
     * {@link FormModel.items} 설정 시 문자열만으로 설정 가능하다.
     *
     * @example
     * ```js
     * {
     *     header: "성별",
     *     column: "SexLabel"
     * }
     * ```
     */
    column?: string;
    /**
     * 해당 아이템의 값을 표시하기 위한 html 템플릿 형식
     *
     * @remarks
     * 이 값을 지정하면 {@link FormItemObject.column} 을 사용할 수 없다.
     *
     * @example
     * ```js
     * {
     *     header: "성별",
     *     template: "<span>Good!<br>121212</span>"
     * }
     * ```
     */
    template?: string;
}
/**
 * {@link FormView} 의 푸터 영역에 관한 설정 모델
 *
 * @remarks
 * {@link FormView.setModel} 로 설정가능하다.
 */
interface FormFooter {
    /**
     * 좌측 하단에 위치한 Popup Menu 의 이름
     *
     * @remarks
     * {@link GridBase.addPopupMenu} 로 추가한 Popup Menu 를 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.addPopupMenu("menuForm", [
     *     {
     *         label: "Grid",
     *         callback: function () {
     *             form.visible = false;
     *         }
     *     }, {
     *         label: "Delete Row",
     *         callback: function () {
     *             form.deleteRow();
     *         }
     *     }, {
     *         label: "Add Row",
     *         callback: function () {
     *             form.appendRow();
     *         }
     *     }
     * ]);
     *
     * form.setModel({
     *      footer: {
     *          popupMenu: "menuForm"
     *      },
     *      ...
     * })
     * ```
     */
    popupMenu?: string;
}
/**
 * {@link FormView} 의 헤더 영역에 관한 설정 모델
 *
 * @remarks
 * {@link FormView.setModel} 로 설정가능하다.
 *
 * @alpha
 */
interface FormHeader {
}
/**
 * {@link FormView} 의 Body 영역에 관한 설정 모델
 *
 * @remarks
 * {@link FormView.setModel} 로 설정가능하다.
 *
 * @alpha
 */
interface FormBody {
}

/**
 * formView의 저장 또는 취소 버튼을 클릭했을때 실행되는 콜백
 *
 * @remarks
 * {@link FormOptions.commitCallback} 또는 {@link FormOptions.cancelCallback}에서 사용된다.
 *
  * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `itemIndex` - 보여지고 있는 행의 itemIndex
 *
 * `item` - 선택된 행의 itemModel
 *
 * [반환값] - false를 return하면 버튼의 기본동작을 실행하지 않는다.
 * @example
 * ```js
 * grid.formOptions.commitCallback = function(grid, itemIndex, item) {
 *   var value = item.getRowObject.column;
 *   if (!isValid(value)) { // value 검증
 *     return false;
 *   }
 * }
 * ```
 */
declare type FormViewButtonCallback = (grid: GridBase$1, itemIndex: number, item: GridItem) => boolean;
/** @internal */
declare class FormOptions extends Base implements FormOptions$1 {
    private _modal;
    private _modalPadding;
    private _modalOpacity;
    private _autoClose;
    private _editable;
    private _itemResizable;
    private _minLabelWidth;
    private _focusVisible;
    private _scrollBarWidth;
    private _commitWhenSwipe;
    private _enterToNextCell;
    private _editWhenFocused;
    private _checkBarSync;
    private _saveLabel;
    private _cancelLabel;
    private _fieldLabel;
    private _valueLabel;
    private _commitCallback;
    private _cancelCallback;
    private _owner;
    private _padTopP;
    private _padBottomP;
    private _padLeftP;
    private _padRightP;
    private _padTop;
    private _padBottom;
    private _padLeft;
    private _padRight;
    constructor(owner: FormView);
    /** modal */
    get modal(): boolean;
    set modal(value: boolean);
    /** modalPadding */
    get modalPadding(): string;
    set modalPadding(value: string);
    /** modalOpacity */
    get modalOpacity(): number;
    set modalOpacity(value: number);
    /** autoClose */
    get autoClose(): boolean;
    set autoClose(value: boolean);
    /** editable */
    get editable(): boolean;
    set editable(value: boolean);
    /** itemResizable */
    get itemResizable(): boolean;
    set itemResizable(value: boolean);
    /** minLabelWidth */
    get minLabelWidth(): number;
    set minLabelWidth(value: number);
    /** focusVisible */
    get focusVisible(): boolean;
    set focusVisible(value: boolean);
    /** scrollBarWidth */
    get scrollBarWidth(): number;
    set scrollBarWidth(value: number);
    /** commitWhenSwipe */
    get commitWhenSwipe(): boolean;
    set commitWhenSwipe(value: boolean);
    /** enterToNextCell */
    get enterToNextCell(): boolean;
    set enterToNextCell(value: boolean);
    /** editWhenFocused */
    get editWhenFocused(): boolean;
    set editWhenFocused(value: boolean);
    /**
     * 그리드 check bar 표시 여부와 check mark 표시 여부 동기화.
     *
     * @defaultValue `true`
     */
    get checkBarSync(): boolean;
    set checkBarSync(value: boolean);
    /** saveLabel */
    get saveLabel(): string;
    set saveLabel(value: string);
    /** cancelLabel */
    get cancelLabel(): string;
    set cancelLabel(value: string);
    /** fieldlabel */
    get fieldLabel(): string;
    set fieldLabel(value: string);
    /** valuelabel */
    get valueLabel(): string;
    set valueLabel(value: string);
    /** commitCallback */
    get commitCallback(): FormViewButtonCallback;
    set commitCallback(value: FormViewButtonCallback);
    /** cancelCallback */
    get cancelCallback(): FormViewButtonCallback;
    set cancelCallback(value: FormViewButtonCallback);
    setModalPadding(top: string, right?: string, bottom?: string, left?: string): void;
    padRect(r: Rectangle): void;
    protected _changed(): void;
}
/** @internal */
declare class LayoutInfo {
    form: Form;
    formView: FormView;
    columnBinder: ColumnBinder;
    gridRow: number;
    items: FormItem$1[];
    labelWidth: number;
    valueWidth: number;
    rowPoints: number[];
}
/** @internal */
declare abstract class FormSectionElement extends LayerElement {
    private _model;
    constructor(doc: Document, model: FormSection, name: string);
    _doDispose(): void;
    /** model */
    get model(): FormSection;
    /** formView */
    get formView(): FormView;
    measure(info: LayoutInfo, hintWidth: number, hintHeight: number): Size;
    layoutContent(info: LayoutInfo): void;
    protected _getCssSelector(): string;
    protected abstract _doMeasure(info: LayoutInfo, hintWidth: number, hintHeight: number): Size;
    protected abstract _doLayoutContent(info: LayoutInfo, width: number, height: number): void;
    protected _doLayoutMobile(info: LayoutInfo, width: number, height: number): void;
    protected _changed(): void;
}
/** @internal */
declare class FormView extends ViewLayer implements ColumnBinder, EditorLender, FormView$1 {
    private static readonly STYLE_NAME;
    private static readonly STYLE_MODAL;
    private _topPos;
    private _labelWidth;
    private _currentRow;
    private _container;
    private _delegate;
    private _model;
    private _options;
    private _headerView;
    private _footerView;
    private _bodyContainer;
    private _bodyView;
    private _bodyView2;
    private _bodyView1;
    private _groupView;
    private _feedbackLayer;
    private _scrollBar;
    private _selectionTool;
    private _layoutInfo;
    private _focusedItem;
    private _valueWidth;
    private _dataCell;
    private _literalCell;
    private _seriesCell;
    private _rowRuntime;
    private _cellRuntime;
    private _needEditor;
    private _layout;
    private _editIndex;
    private _saveRow;
    private _cellRect;
    constructor(container: GridContainer, options?: ConfigObject);
    _doDispose(): void;
    getColumnObject(column: string): ValueColumn;
    getDataFieldIndex(field: string): number;
    getEditItem(grid: GridBase$1): GridItem;
    canWrite(index: CellIndex): boolean;
    getEditor(index: CellIndex): any;
    getEditBounds(editor: CellEditor, index: CellIndex): Rectangle;
    isEditing(): boolean;
    isItemEditing(): boolean;
    validateCellCommit(index: CellIndex, value: any): void;
    makeCellVisible(index: CellIndex): boolean;
    editCellCommit(index: CellIndex, oldValue: any, newValue: any): boolean;
    editorChange(editor: CellEditor, index: CellIndex, value: any): void;
    editorShow(index: CellIndex): void;
    editorHide(index: CellIndex): void;
    itemUpdateStarted(grid: GridBase$1, item: GridItem): void;
    itemAppendStarted(grid: GridBase$1, item: GridItem): void;
    itemInsertStarted(grid: GridBase$1, item: GridItem): void;
    itemCommited(grid: GridBase$1, item: GridItem): void;
    itemCanceled(grid: GridBase$1): void;
    itemInserted(grid: GridBase$1, item: GridItem): void;
    itemsChanged(grid: GridBase$1): void;
    /** container */
    get container(): GridContainer;
    /** delegate */
    get delegate(): GridDelegate;
    /** model */
    get model(): Form;
    /** options */
    get options(): FormOptions;
    /** dataSource */
    get dataSource(): DataSource;
    /** headerView */
    get headerView(): FormHeaderView;
    /** footerView */
    get footerView(): FormFooterView;
    /** topPos */
    get topPos(): number;
    set topPos(value: number);
    /** labelWidth */
    get labelWidth(): number;
    set labelWidth(value: number);
    /** valueWidth */
    get valueWidth(): number;
    /** currentRow */
    get currentRow(): number;
    set currentRow(value: number);
    /** focusedItem */
    get focusedItem(): FormValueItem;
    set focusedItem(value: FormValueItem);
    /** focusedIndex */
    get focusedIndex(): number;
    set focusedIndex(value: number);
    /** bodyView */
    get bodyView(): FormBodyView;
    getHandler(): any;
    invalidateLayout(): void;
    addFeedbackElement(view: VisualElement): boolean;
    removeFeedbackElement(view: VisualElement): boolean;
    canSwipeCommit(): boolean;
    canSwipe(x: number): number;
    private $_getIndex;
    showEditor(itemIndex: number): boolean;
    showList(itemIndex: number): boolean;
    deleteRow(): void;
    appendRow(): void;
    addBodyElement(elt: VisualElement): boolean;
    removeBodyElement(elt: VisualElement): boolean;
    close(): void;
    editorButtonClicked(itemIndex: number): void;
    setModel(source: ConfigObject): void;
    get isLayer(): boolean;
    protected _getCssSelector(): string;
    protected _doActivateView(): void;
    protected _dodDeactivateView(): void;
    protected _visibleChanged(): void;
    private $_initialzie;
    private $_prepareRender;
    private $_layout;
    private $_getScrollBarWidth;
    protected _changed(): void;
    private $_getGridCell;
    private $_elementClicked;
    private $_focusedChanged;
    private $_commitEditor;
    private $_deleteRow;
    private $_appendRow;
    private $_isScrollBar;
    private $_makeCellVisible;
}
/** @internal */
declare class FormHeaderView extends FormSectionElement {
    private _labelCell;
    private _valueCell;
    private _closeView;
    constructor(doc: Document, model: FormHeader$1);
    _doDispose(): void;
    isClose(elt: HTMLElement): boolean;
    protected _doMeasure(info: LayoutInfo, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(info: LayoutInfo, width: number, height: number): void;
    protected _doDraw(dom: HTMLElement): void;
}
/** @internal */
declare class FormFooterView extends FormSectionElement {
    private _editMode;
    private _posView;
    private _currView;
    private _slashView;
    private _totalView;
    private _headView;
    private _menuView;
    private _leftView;
    private _firstView;
    private _prevView;
    private _rightView;
    private _lastView;
    private _nextView;
    private _footView;
    private _commitView;
    private _commitLabel;
    private _cancelView;
    private _cancelLabel;
    private _checkView;
    private _menuEnabled;
    private _posVisible;
    private _firstVisible;
    private _prevVisible;
    private _nextVisible;
    private _lastVisible;
    private _firstEnabled;
    private _prevEnabled;
    private _nextEnabled;
    private _lastEnabled;
    private _commitVisible;
    private _cancelVisible;
    private _checkEnabled;
    constructor(doc: Document, footer: FormFooter$1);
    _doDispose(): void;
    /** editMode */
    get editMode(): boolean;
    set editMode(value: boolean);
    isCheck(elt: HTMLElement): boolean;
    protected _initDom(dom: HTMLElement): void;
    protected _doMeasure(info: LayoutInfo, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(info: LayoutInfo, width: number, height: number): void;
    protected _doDraw(dom: HTMLElement): void;
    private $_createElements;
    private $_setIconStyle;
    private $_createHead;
    private $_createFoot;
    private $_createPosition;
    private $_createLeft;
    private $_createRight;
    private $_elementClicked;
}
/** @internal */
declare class FormBodyView extends FormSectionElement {
    private _table;
    private _thead;
    private _tbody;
    private _cells;
    private _rowPoints;
    constructor(doc: Document, model: FormBody$1);
    _doDispose(): void;
    bodyCellByCell(cell: HTMLTableCellElement): BodyTableCell;
    bodyCellAt(item: FormItem$1): BodyTableCell;
    getValueCellRect(item: FormItem$1, rect?: Rectangle): Rectangle;
    protected _createDom(doc: Document): HTMLElement;
    protected _initDom(dom: HTMLElement): void;
    protected _doMeasure(info: LayoutInfo, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(info: LayoutInfo, width: number, height: number): void;
    protected _doDraw(dom: HTMLElement): void;
    private $_initTable;
    private $_prepareRows;
    private $_refreshCells;
    private $_setCellsDisplay;
    private $_updateHead;
    private $_updateRows;
    private $_setLabelStyle;
    private $_updateRow;
    private $_updateValueCell;
    private $_createRenderer;
    private $_getButtonVisible;
    private $_buttonWidth;
    private $_editButtonWidth;
    private $_editButtonCount;
    private $_editButtonVerti;
    private $_errorWidth;
    private $_renderColumnCell;
    private $_renderDataCell;
    private $_focusedChanged;
}

/** @internal */
declare class GridContainer extends VisualContainer {
    private _gridView;
    private _formMarquee;
    private _formView;
    private _activeView;
    private _heightMeasurer;
    private _watchTimer;
    private _resizeTimer;
    private _sizeInfo;
    private _displayObserver;
    private _orgCssHeight;
    constructor(containerId: string | HTMLDivElement, viewDelegate: any, accessibility?: boolean, waiOptions?: any);
    protected _doDispose(): void;
    /** gridView */
    get gridView(): GridBase$1;
    /** formView */
    get formView(): FormView;
    /** heightMeasurer */
    get heightMeasurer(): GridMeasurer;
    setWatchTimer(active: boolean): void;
    recallHeight(): void;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
    protected _doResized(event: Event): void;
    protected _isOutChildElement(event: Event): boolean;
    protected _doPrepareContainer(dom: HTMLElement, accessibility: boolean, waiOptions: WaiOptions): void;
    protected _createDefaultTool(): VisualTool;
    protected _doLayout(bounds: Rectangle): void;
    protected _layoutChildren(bounds: Rectangle): void;
    protected _doBeforeRender(): void;
    protected _doAfterRender(): void;
    protected _doPrepareRender(bounds: Rectangle): void;
    protected _createGridView(accessibility: boolean, waiOptions: WaiOptions): GridBase$1;
    protected _resizeHandler(event: Event): void;
    private $_displayObserver;
}
/** @internal */
declare class GridMeasurer extends Base {
    private _container;
    private _bodyStyle;
    private _headerStyle;
    private _summaryStyle;
    private _footerStyle;
    private _dataRowStyle;
    private _headerRowStyle;
    private _summaryRowStyle;
    private _footerRowStyle;
    private _groupFooterStyle;
    private _dataCellStyle;
    private _headerCellStyle;
    private _summaryCellStyle;
    private _footerCellStyle;
    private _groupFooterCellStyle;
    private _rowHeight;
    private _headerHeight;
    private _summaryHeight;
    private _footerHeight;
    private _gfooterHeight;
    private _dirty;
    constructor(container: HTMLElement);
    protected _doDispose(): void;
    /** rowHeight */
    get rowHeight(): number;
    /** headerHeight */
    get headerHeight(): number;
    /** summaryHeight */
    get summaryHeight(): number;
    /** footerHeight */
    get footerHeight(): number;
    /** groupFooterHeight */
    get groupFooterHeight(): number;
    measure(grid: GridBase$1): void;
    invalidate(): void;
    private $_prepareElements;
    private $_measure;
}

/**@internal */
declare abstract class TouchManager extends Base {
    protected _container: GridContainer;
    constructor(container: GridContainer);
    _doDispose(): void;
    abstract touchStart(event: TouchEvent): void;
    abstract touchEnd(event: TouchEvent): void;
    abstract touchMove(event: TouchEvent): void;
    abstract touchCancel(event: TouchEvent): void;
    private _touchToOffset;
    protected _toOffset(touch: Touch): Touch;
}
/**@internal */
declare type TouchHandler = (event: TouchEvent, x: number, y: number) => any;
/**@internal */
declare type TouchEndHandler = (event: TouchEvent) => any;
/**@internal */
declare type DragHandler = (prevX: number, prevY: number, x: number, y: number) => any;
/**@internal */
declare type DragStartHandler = (startX: number, startY: number, x: number, y: number) => any;
/**@internal */
declare type DragEndHandler = (x: number, y: number, canceled: boolean) => void;
/**@internal */
declare type SwipeHandler = (duration: number, distance: number, dir: string, event: Event) => any;
/**@internal */
declare type TapHandler = (event: TouchEvent, x: number, y: number) => any;
/**@internal */
declare type DoubleTapHandler = (event: TouchEvent, x: number, y: number) => any;
/**@internal */
declare type LongTapHandler = (event: TouchEvent, x: number, y: number) => any;
/**@internal */
declare class SingleTouchManager extends TouchManager {
    private _touchHandler;
    private _dragHandler;
    private _dragStartHandler;
    private _dragEndHandler;
    private _swipeHandler;
    private _tapHandler;
    private _doubleTapHandler;
    private _longTapHandler;
    private _touchEndHandler;
    private _mobileOptions;
    private _touchId;
    private _started;
    private _seconded;
    private _startX;
    private _startY;
    private _tapped;
    private _dragging;
    private _prevX;
    private _prevY;
    private _longTapTimer;
    private _tracker;
    private _events;
    private _touches;
    private _touchEndt;
    constructor(container: GridContainer, options: MobileOptions);
    _doDispose(): void;
    /** touchHandler */
    get touchHandler(): TouchHandler;
    set touchHandler(value: TouchHandler);
    /** dragHandler */
    get dragHandler(): DragHandler;
    set dragHandler(value: DragHandler);
    /** dragStartHandler */
    get dragStartHandler(): DragStartHandler;
    set dragStartHandler(value: DragStartHandler);
    /** dragEndHandler */
    get dragEndHandler(): DragEndHandler;
    set dragEndHandler(value: DragEndHandler);
    /** swipeHandler */
    get swipeHandler(): SwipeHandler;
    set swipeHandler(value: SwipeHandler);
    /** tapHandler */
    get tapHandler(): TapHandler;
    set tapHandler(value: TapHandler);
    /** doubleTapHandler */
    get doubleTapHandler(): DoubleTapHandler;
    set doubleTapHandler(value: DoubleTapHandler);
    /** longTapHandler */
    get longTapHandler(): LongTapHandler;
    set longTapHandler(value: LongTapHandler);
    /** touchEndHandler */
    get touchEndHandler(): TouchEndHandler;
    set touchEndHandler(value: TouchEndHandler);
    /** touchEndt */
    get touchEndt(): number;
    get options(): MobileOptions;
    isSingleTouch(): boolean;
    clearTouches(): void;
    removeTouches(touches: TouchList): void;
    touchStart(event: TouchEvent): void;
    touchMove(event: TouchEvent): void;
    touchEnd(event: TouchEvent): void;
    touchCancel(event: TouchEvent): void;
    $_findTouch(event: TouchEvent): Touch;
    $_checkSwipe(event: Event): boolean;
}

/** @internal */
interface VisualToolOwner {
    findElementAt(x: number, y: number, hitTesting: boolean): VisualElement;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
}
/** @internal */
declare class VisualTool extends Base {
    private _owner;
    private _name;
    private _previous;
    private _dragTracker;
    private _clickX;
    private _clickY;
    private _mouseX;
    private _mouseY;
    private _mouseEventTarget;
    protected _touchManager: SingleTouchManager;
    protected _lastTouch: number;
    constructor(owner: VisualToolOwner, name: string);
    protected _doDispose(): void;
    /** owner */
    get owner(): VisualToolOwner;
    /** name */
    get name(): string;
    /** previous */
    get previous(): VisualTool;
    /** dragTracker */
    get dragTracker(): DragTracker;
    set dragTracker(value: DragTracker);
    /** dragging */
    get dragging(): boolean;
    /** touchManager */
    get touchManager(): SingleTouchManager;
    /** mouseX */
    get mouseX(): number;
    /** mouseY */
    get mouseY(): number;
    findElementAt(x: number, y: number, hitTesting: boolean): VisualElement;
    activate(previous: VisualTool): void;
    deactivate(): void;
    keyDown(event: KeyboardEvent): boolean;
    keyUp(event: KeyboardEvent): boolean;
    keyPress(event: KeyboardEvent): boolean;
    mouseDown(event: MouseEvent | TouchEvent): void;
    dragFrom(event: MouseEvent, tracker: DragTracker): void;
    dropFrom(event: MouseEvent, tracker: DragTracker): void;
    cancelFrom(tracker: DragTracker): void;
    mouseMove(event: MouseEvent | TouchEvent): void;
    mouseUp(event: MouseEvent | TouchEvent): void;
    mouseEnter(event: MouseEvent): void;
    mouseLeave(event: MouseEvent): void;
    mouseOver(event: MouseEvent): void;
    mouseOutside(): void;
    mouseWheel(event: WheelEvent): boolean;
    contextMenu(event: MouseEvent): boolean;
    click(event: MouseEvent): void;
    dblclick(event: MouseEvent): void;
    setFocus(target?: HTMLElement): void;
    focusLeave(event: Event): void;
    resetFocused(): void;
    touchStart(event: TouchEvent): void;
    touchMove(event: TouchEvent): void;
    touchEnd(event: TouchEvent): void;
    touchCancel(event: TouchEvent): void;
    lastTouch(): number;
    protected get mouseEventTarget(): HTMLElement;
    protected isMouseEventTarget(elt: VisualElement): boolean;
    protected _doActivated(previous: VisualTool): void;
    protected _doDeactivated(): void;
    protected _doKeyDown(event: KeyboardEvent): boolean;
    protected _doKeyUp(event: KeyboardEvent): boolean;
    protected _doKeyPress(event: KeyboardEvent): boolean;
    protected _doMouseDown(event: MouseEvent | TouchEvent): void;
    protected _doMouseMove(event: MouseEvent | TouchEvent): void;
    /** 그리드 밖에서도 호출된다. */
    protected _doMouseUp(event: MouseEvent | TouchEvent): void;
    protected _doMouseEnter(event: MouseEvent): void;
    protected _doMouseLeave(event: MouseEvent): void;
    protected _doMouseOver(event: MouseEvent): void;
    protected _doMouseOutside(): void;
    protected _doMouseWheel(event: WheelEvent): boolean;
    protected _doContextMenu(event: MouseEvent): boolean;
    /** 그리드 밖에서 마우스를 놓으면 호출되지 않는다. */
    protected _doClick(event: MouseEvent): void;
    protected _doDblClick(event: MouseEvent): void;
    protected _doSetFocus(target?: HTMLElement): void;
    protected _doFocusLeave(event: Event): void;
    protected _getDragTracker(request: EditRequest, x: number, y: number): DragTracker;
    protected _startDragTracker(x: number, y: number, event?: MouseEvent | TouchEvent): void;
    protected _stopDragTracker(x: number, y: number, canceled: boolean): void;
    protected _doDragTrackerStarted(dragTracker: DragTracker): void;
    protected _doDragTrackerFinished(dragTracker: DragTracker, canceled: boolean): void;
    protected _findTableCell(source?: HTMLElement): HTMLTableCellElement;
    protected _doTouchStart(event: TouchEvent): void;
    protected _doTouchMove(event: TouchEvent): void;
    protected _doTouchEnd(evnet: TouchEvent): void;
    protected _doTouchCancel(evnet: TouchEvent): void;
}
/** @internal */
declare abstract class EditRequest extends Base {
    constructor();
    /** cursor */
    get cursor(): Cursor;
    /** source */
    get source(): any;
    /** selectable */
    get selectable(): boolean;
    /** dblClickable */
    get dblClickable(): boolean;
}

/** @internal */
declare abstract class VisualContainer extends EventAware implements VisualToolOwner {
    private static $_Containers;
    static $_mouseContainer: number;
    getMouseContainer(): VisualContainer;
    findContainer(event: MouseEvent, target?: HTMLElement): VisualContainer;
    private static $_ActiveGrid;
    static getActiveGrid(): any;
    static setActiveGrid(hash: number): void;
    static getGridInstance(cDom: string | HTMLDivElement): any;
    static clearContainer(hash: number): void;
    static disposeStatic(): void;
    private _disabled;
    private _activeTool;
    private _containerDiv;
    protected _containerDom: HTMLDivElement;
    private _container;
    private _measurer;
    private _textMeasurer;
    private _checkMeasurer;
    private _checkRect;
    private _updateRequested;
    private _layoutNeeded;
    private _invalidated;
    private _defaultTool;
    private _captured;
    private _focusing;
    private _focusingTarget;
    private _hovered;
    private _currentX;
    private _currentY;
    private _rendered;
    private _defaultCursor;
    private _drawing;
    private _clicked;
    private _clicket;
    private _children;
    private _rootElement;
    private _eventHandlers;
    private _eventNodes;
    private _contextMenu;
    private _containerRender;
    private _scrollTool;
    private _cursor;
    private _testWidth;
    private _testHeight;
    private _requestTimer;
    private _focusTimer;
    private _doc;
    private _focused;
    constructor(containerId: string | HTMLDivElement, accessibility: boolean, waiOptions: WaiOptions);
    protected _doDispose(): void;
    /** Document */
    get doc(): Document;
    /** disabled */
    get disabled(): boolean;
    set disabled(value: boolean);
    /** activeTool */
    get activeTool(): VisualTool;
    set activeTool(value: VisualTool);
    /** defaultTool */
    get defaultTool(): VisualTool;
    /** measurer */
    protected get measurer(): HTMLElement;
    findElementAt(x: number, y: number, hitTesting: boolean): VisualElement;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
    setCursor(cursor: string): void;
    setFocus(): void;
    updateNow(): void;
    toScreen(r: Rectangle): Rectangle;
    pointToScreen(x: number, y: number): {
        x: number;
        y: number;
    };
    getBound(): Rectangle;
    getHtml(): string;
    addElement(element: VisualElement): boolean;
    removeElement(element: VisualElement): boolean;
    resetSize(callback?: any): void;
    measureText(style: string, text: string, font?: ConfigObject): number;
    private $_refreshCheckMeasurer;
    measureCheckWidth(): number;
    measureCheckHeight(): number;
    contains(target: EventTarget): boolean;
    getDomPosition(elt: HTMLElement): {
        x: number;
        y: number;
    };
    offsetDomPosition(elt: HTMLElement, p: any): any;
    cancelOtherContainer(tracker: any): void;
    protected _doDisabledChanged(): void;
    private prepareContainer;
    protected _doPrepareContainer(dom: HTMLElement, accessibility: boolean, waiOptions: WaiOptions): void;
    private _createRootElement;
    protected abstract _createDefaultTool(): VisualTool;
    isLayoutNeeded(): boolean;
    invalidateLayout(): void;
    invalidate(force: boolean): void;
    invalidateElement(element: VisualElement): void;
    private _render;
    private $$_render;
    protected _layoutChildren(bounds: Rectangle): void;
    protected _doLayout(bounds: Rectangle): void;
    protected abstract _doBeforeRender(): void;
    protected _doAfterRender(): void;
    protected _doPrepareRender(bounds: Rectangle): void;
    protected _doRenderHtml(bounds: Rectangle): void;
    protected _doDrawContainer(bounds: Rectangle): void;
    protected _drawElement(element: VisualElement): void;
    private _validateChildren;
    protected _setFocusAndScroll(target: any): void;
    _registerEventHandlers(container: HTMLElement, keyContainer: HTMLElement): void;
    $_addListener(node: any, event: any, handler: any, capture: any): void;
    $_removeListener(node: any, event: any): void;
    $_removeListenerAll(node?: HTMLElement): void;
    protected abstract _resizeHandler(event: Event): any;
    protected _doResized(event: Event): void;
    protected _isEnabled(): boolean;
    protected _isOutChildElement(event: Event): boolean;
    private $_checkKeyElement;
    private _keyDownHandler;
    private _keyUpHandler;
    private _keyPressHandler;
    eventToContainer(event: any): Point;
    private toOffset;
    private toOffsetTouch;
    private _clickHandler;
    private _dblclickHandler;
    private $_setMouseTarget;
    private _mouseDownHandler;
    private _mouseMoveHandler;
    private _mouseUpHandler;
    private _mouseEnterHandler;
    private _mouseLeaveHandler;
    private _mouseOverHandler;
    private _contextMenuHander;
    private _wheelHandler;
    private _focusHandler;
    private _blurHandler;
    private _selectstartHandler;
    private _focusinHandler;
    private _globalMouseDownHandler;
    private _focusoutHandler;
    private _focusHandlerFireFox;
    private _touchStartHandler;
    private _touchMoveHandler;
    private _touchEndHandler;
    private _touchCancelHandler;
    private _touchLeaveHandler;
}

/** @internal */
declare abstract class VisualElement extends EventAware {
    private _x;
    private _y;
    private _width;
    private _height;
    private _visible;
    private _mouseEnabled;
    private _name;
    private _parent;
    private _elements;
    private _dom;
    private _dirty;
    private _hovered;
    private _className;
    constructor(doc: Document, name?: string);
    protected _doDispose(): void;
    /** name */
    get name(): string;
    /** container */
    get container(): VisualContainer;
    /** parent */
    get parent(): VisualElement;
    /** childCount */
    get childCount(): number;
    /** isSingleton */
    get isSingleton(): boolean;
    /** x */
    get x(): number;
    set x(value: number);
    /** y */
    get y(): number;
    set y(value: number);
    /** width */
    get width(): number;
    set width(value: number);
    /** height */
    get height(): number;
    set height(value: number);
    /** right */
    get right(): number;
    /** bottom */
    get bottom(): number;
    /** position */
    get position(): Point;
    /** bounds */
    get bounds(): Rectangle;
    /** clientRect */
    get clientRect(): Rectangle;
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** mouseEnabled */
    get mouseEnabled(): boolean;
    set mouseEnabled(value: boolean);
    /** hovered */
    get hovered(): boolean;
    set hovered(value: boolean);
    /** isLayer */
    get isLayer(): boolean;
    /** clickable */
    get clickable(): boolean;
    /** mouseX */
    get mouseX(): number;
    /** mouseY */
    get mouseY(): number;
    get doc(): Document;
    /** style */
    protected get style(): CSSStyleDeclaration;
    isDom(element: HTMLElement): boolean;
    canHover(): boolean;
    getChildren(): VisualElement[];
    getChild(index: number): VisualElement;
    indexOf(element: VisualElement): number;
    contains(element: VisualElement): boolean;
    getAncestor(cls: any): VisualElement;
    addChild(child: VisualElement): boolean;
    insertChild(index: number, child: VisualElement): boolean;
    removeChild(child: VisualElement): boolean;
    removeChildAt(index: number): VisualElement;
    removeLast(): VisualElement;
    clear(): boolean;
    hideAll(): void;
    invalidate(force?: boolean, invalidateChildren?: boolean): void;
    validate(): void;
    invalidateLayout(): void;
    getBounds(r?: Rectangle): Rectangle;
    getClientRect(r?: Rectangle): Rectangle;
    containsInBounds(x: number, y: number): boolean;
    containsInClient(x: number, y: number): boolean;
    parentToElement(parent: VisualElement, x: number, y: number): Point;
    translateBy(descendant: VisualElement, r?: Rectangle): Rectangle;
    topBy(parent: VisualElement, top: number): number;
    boundsBy(parent: VisualElement, r?: Rectangle): Rectangle;
    boundsByContainer(r?: Rectangle): Rectangle;
    pointByContainer(x: number, y: number): Point;
    containerToElement(x: number, y: number): Point;
    boundsByScreen(r?: Rectangle): Rectangle;
    hitTest(x: number, y: number): boolean;
    findChildAt(x: number, y: number, hitTesting: boolean): any;
    move(x: number, y: number): void;
    resize(width: number, height: number): void;
    setBounds(x: number, y: number, width: number, height: number): void;
    setBoundsI(x: number, y: number, width: number, height: number): void;
    setRect(r: Rectangle): void;
    setRectI(r: Rectangle): void;
    draw(): void;
    resetSize(): void;
    getHtml(): string;
    setImportantStyle(style: string, value: any): void;
    protected _createDom(doc: Document): HTMLElement;
    protected abstract _getCssSelector(): string;
    protected _initDom(dom: HTMLElement): void;
    protected _addEventListeners(dom: HTMLElement): void;
    protected _removeEventListeners(dom: HTMLElement): void;
    private $_attached;
    protected _doAttached(parent: VisualElement): void;
    private $_detached;
    protected _doDetached(parent: VisualElement): void;
    protected _setSizeStyle(css: CSSStyleDeclaration): void;
    protected _getCssDisplay(): string;
    resetStyleName(): void;
    protected _setClassName(dom: HTMLElement): void;
    applyBounds(): void;
    protected _beforeDraw(dom: HTMLElement): void;
    protected abstract _doDraw(dom: HTMLElement): void;
    protected _hoverChanged(): void;
    protected _visibleChanged(): void;
    private sizeChanged;
    protected _doSizeChanged(): void;
}
/** @internal */
declare class LayerElement extends VisualElement {
    get isLayer(): boolean;
    protected _getCssSelector(): string;
    protected _doDraw(element: HTMLElement): void;
}
/** @internal */
declare abstract class ViewLayer extends LayerElement {
    private _active;
    get active(): boolean;
    constructor(doc: Document, active?: boolean);
    private $_activateView;
    private $_deactivateView;
    protected abstract _doActivateView(): void;
    protected abstract _dodDeactivateView(): void;
}

/**
 * 셀 선택 영역에 대한 모드
 *
 * @remarks
 *
 * {@link DisplayOptions.selectionMode} 에서 사용된다.
 */
declare enum SelectionMode {
    /**
     * 영역선택을 사용하지 않음.
     */
    NONE = "none",
    /**
     * 하나의 영역선택만 사용
     */
    SINGLE = "single",
    /**
     * 여러개의 영역선택을 사용
     */
    EXTENDED = "extended"
}
/**
 * 셀 선택 영역에 대한 스타일
 *
 * @remarks
 * `SINGLE`, `SINGLE_ROW`, `SINGLE_COLUMN` 을 single selection style 이라한다.
 *
 * {@link DisplayOptions.selectionStyle} 에서 사용된다.
 *
 * {@link RowIndicator.selectable} 기능이 정상적으로 작동하려면 {@link DisplayOptions.selectionStyle} 이 single selection style 이 아니어야 한다.
 *
 * {@link DisplayOptions.selectionStyle} 이 single selection style 이 아니어야 `ctrl` key 를 누른 후 컬럼헤더 드래그 시 컬럼 단위 선택 영역이 지정된다.
 *
 */
declare enum SelectionStyle {
    /**
     * 블록 형태로 선택
     */
    BLOCK = "block",
    /**
     * 행 단위로 선택
     */
    ROWS = "rows",
    /**
     * 컬럼 단위로 선택
     */
    COLUMNS = "columns",
    /**
     * 하나의 행만 선택
     */
    SINGLE_ROW = "singleRow",
    /**
     * 하나의 컬럼만 선택
     */
    SINGLE_COLUMN = "singleColumn",
    /**
     * 하나의 셀만 선택
     */
    SINGLE = "single",
    /**
     * 선택 불가
     */
    NONE = "none"
}
/**
 * 셀 선택 디스플레이
 *
 * @remarks
 * 개발 중...
 */
declare enum SelectionDisplay {
    /**
     * 셀
     */
    CELL = "cell",
    /**
     * 셀과 경계
     */
    CELL_AND_BORDER = "cellAndBorder",
    /**
     * 마스크
     */
    MASK = "mask"
}
/**
 * @internal
 */
declare abstract class SelectionItem extends Base {
    private _manager;
    protected _runStyle: SelectionStyle;
    constructor(manager: SelectionManager, style: SelectionStyle);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    abstract get style(): SelectionStyle;
    abstract get single(): boolean;
    get runStyle(): SelectionStyle;
    abstract getBounds(): CellRange;
    abstract contains(row: number, layout: CellLayoutItem): boolean;
    abstract containsItem(itemIndex: number): boolean;
    abstract containsLayout(layout: CellLayoutItem): boolean;
    abstract resizeTo(endIndex: CellIndex): void;
    abstract moveRow(delta: number): void;
    abstract intersectsWith(item: SelectionItem): boolean;
    abstract mergeWith(item: SelectionItem): void;
    abstract getData(maxRows: number): any[];
    protected abstract _getRows(): {
        rows: number[];
        fields: number[];
    };
    setValues(value: any): void;
    inflate(dir: string, newIndex: CellIndex): void;
    getItems(dataOnly?: boolean): GridItem[];
    getItemIndices(dataOnly?: boolean): number[];
    getRows(): number[];
    protected abstract _inflateLeft(newLeft: CellIndex): void;
    protected abstract _inflateRight(newRight: CellIndex): void;
    protected abstract _inflateTop(newTop: CellIndex): void;
    protected abstract _inflateBottom(newBottom: CellIndex): void;
    protected _resized(): void;
    toProxy(): ConfigObject;
}
/**
 * @internal
 */
declare class SelectionManager extends EventAware {
    static readonly CHANGED = "onSelectionChanged";
    static readonly ADDED = "onSelectionAdded";
    static readonly REMOVED = "onSelectionRemoved";
    static readonly CLEARED = "onSelectionCleared";
    static readonly RESIZED = "onSelectionResized";
    static readonly ENDED = "onSelectionEnded";
    private _grid;
    private _items;
    private _locked;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    /** exclusiveMode */
    get exclusiveMode(): boolean;
    /** count */
    get count(): number;
    /** single */
    get single(): boolean;
    lock(): void;
    unlock(): void;
    getItem(index: number): SelectionItem;
    getItems(): SelectionItem[];
    lastItem(): SelectionItem;
    add(start: CellIndex, end: CellIndex, style: SelectionStyle): SelectionItem;
    remove(item: SelectionItem): void;
    clear(): void;
    selectRow(itemIndex: number, clear: boolean): void;
    containsItem(itemIndex: number, style: any): boolean;
    containsLayout(layout: CellLayoutItem): boolean;
    containsCell(index: CellIndex): boolean;
    contains(row: number, layout: CellLayoutItem): boolean;
    normalize(): void;
    canResize(item: SelectionItem): boolean;
    protected _changed(item?: SelectionItem): void;
    private $_addItem;
    private $_itemResized;
    private $_ended;
}
/**
 * @internal
 */
declare class SelectionMask extends LayerElement {
    private _item;
    private _view;
    private _toped;
    private _bottomed;
    private _lefted;
    private _righted;
    constructor(doc: Document);
    /** item  */
    get item(): SelectionItem;
    prepare(): void;
    updateElement(): void;
    protected _initDom(dom: HTMLElement): void;
}
/** @internal */
declare class SelectionLayer extends LayerElement {
    protected _grid: GridBase$1;
    protected _pool: SelectionMask[];
    protected _views: {
        [key: number]: SelectionMask;
    };
    private _rangeRect;
    constructor(grid: GridBase$1, name: string);
    protected _doDispose(): void;
    addView(item: SelectionItem): SelectionMask;
    removeView(item: SelectionItem): void;
    clearViews(): void;
    layout(): void;
    protected $_getSelectionRowsRect(lm: GridLayoutManager, item: SelectionItem, view: SelectionMask, r: Rectangle): boolean;
    protected $_getSelectionColumnsRect(lm: GridLayoutManager, item: SelectionItem, view: SelectionMask, r: Rectangle, mr?: Rectangle): boolean;
    protected $_getSelectionRangeRect(lm: GridLayoutManager, item: SelectionItem, view: SelectionMask, r: Rectangle, mr?: Rectangle): boolean;
}

/**
 * 검증 결과 관련 설정 정보 모델
 *
 * @remarks
 * {@link GridBase.onValidateColumn}, {@link GridBase.onValidateRow}, {@link GridBase.onValidationFail} 에서 사용된다.
 */
interface ValidationError$1 {
    /**
     * 데이터 검증 결과 수준
     */
    level: ValidationLevel;
    /**
     * 표시할 메세지 내용
     */
    message: string;
}
/**
 * 클릭한 아이템의 정보 모델
 *
 * @remarks
 * {@link GridBase.onMenuItemClicked} 이나 {@link GridBase.onCellClicked} 등 클릭 관련 콜백에서 사용하는 아이템의 정보 모델이다.
 *
 * @example
 * ```js
 * gridView.onMenuItemClicked =  function (grid, item, clickData) {
 *      console.log(item.label + "was clicked.");
 *      console.log("cellType is: " + clickData.cellType);
 * };
 * ```
 */
interface ClickData {
    /**
     * 클릭한 셀의 종류
     */
    cellType?: GridCellType;
    /**
     * 클릭한 대상의 서브 타입
     */
    subType?: GridCellType;
    /**
     * 클릭한 대상의 필드
     */
    field?: number;
    /**
     * 클릭한 대상이 위치한 순서
     */
    itemIndex?: number;
    /**
     * 클릭한 셀의 컬럼
     */
    column?: string;
    /**
     * 클릭한 셀의 인덱스
     *
     * @remarks
     * footer, summary 등의 인덱스이다.
     */
    index?: number;
    /**
     * 클릭한 셀의 그룹 레벨
     */
    groupLevel?: number;
}
/**
 * 컬럼 단위 혹은, 행 단위 데이터 편집 검증 조건과 방식에 대한 모델
 *
 * @remarks
 * {@link GridBase.setValidations} 에서 사용한다.
 *
 * @example
 * ```js
 * // 문자열
 * gridView.setValidations("values['UnitPrice'] > 100");
 *
 * // 오브젝트
 * gridView.setValidations({
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100"
 * })
 *
 * // 배열
 * gridView.setValidations([{
 *      message: 'Too expensive!',
 *      criteria: "values['UnitPrice'] > 100"
 * }])
 * ```
 */
interface EditValidation$1 {
    /**
     * 이름
     *
     * @remarks
     * 검증 실패시 메시지나 description 이 설정되지 않았을 경우 메시지로 사용된다.
     */
    name?: string;
    /**
     * 검증 진행 여부
     *
     * @defaultValue `true`
     */
    active?: boolean;
    /**
     * 검증 모드
     *
     * @remarks
     * Insert 시, Update 시, 또는 두 경우 모두 실행한다.
     *
     * @defaultValue {@link ValidationMode.ALWAYS}
     */
    mode?: ValidationMode;
    /**
     * 검증 결과 수준
     *
     * @defaultValue {@link ValidationLevel.ERROR}
     */
    level?: ValidationError$1;
    /**
     * 검증식
     */
    criteria?: string;
    /**
     * 검증 실패 시 보여지는 에러 메시지
     */
    message?: string;
    /**
     * 검증 실패 시의 설명
     *
     * @remarks
     * 검증 실패시 메시지가 지정되지 않았을 경우 메시지로 사용된다.
     */
    description?: string;
}
/**
 * 셀의 위치정보 모델
 *
 * @remarks
 * {@link GridBase.onCurrentChanging | onCurrentChanging} 등 {@link GridBase} 의 여러 콜백 및 셀 위치 관련 method 들에서 주로 사용된다.
 *
 * 필요한 정보만 사용하면 된다.
 *
 * @example
 * ```js
 * gridView.setCurrent({ itemIndex: 1, column: '행정구역별' });
 * ```
 */
interface CellIndex$1 {
    /**
     * 그리드 상에서의 순서
     */
    itemIndex?: number;
    /**
     * 컬럼 이름
     */
    column?: string | GridColumn;
    /**
     * 고유의 행 번호
     */
    dataRow?: number;
    /**
     * 필드 순서
     */
    fieldIndex?: number;
    /**
     * 필드명
     */
    fieldName?: string;
}
/**
 * 그리드 선택 영역 정보 모델
 *
 * @remarks
 * {@link GridBase.onCopy}, {@link GridBase.setSelection} 등에서 사용된다.
 */
interface Selection {
    /**
     * 스타일
     */
    style?: SelectionStyle;
    /**
     * 시작 행의 itemIndex
     */
    startItem?: number;
    /**
     * 시작 행의 고유 번호
     */
    startRow?: number;
    /**
     * 시작 컬럼의 이름
     */
    startColumn?: string;
    /**
     * 끝 행의 itemIndex
     */
    endItem?: number;
    /**
     * 끝 행의 고유 번호
     */
    endRow?: number;
    /**
     * 끝 컬럼의 이름
     */
    endColumn?: string;
}
/**
 * {@link GridBase.getInvalidCells} 에서 반환되는 오브젝트 형식
 */
interface InvalidCell {
    /**
     * 컬럼 명
     */
    column: string;
    /**
     * 행의 고유 번호
     */
    dataRow: number;
    /**
     * 설정한 메시지
     */
    message: string;
    /**
     * 설정한 데이터 검증 결과 수준
     */
    level: ValidationLevel;
}
/**
 * {@link GridBase.getEditingItem} 에서 반환되는 오브젝트 형식
 */
interface EditingItemInfo {
    /**
     * 행의 인덱스 (순서)
     */
    itemIndex: number;
    /**
     * 행의 고유번호
     */
    dataRow: number;
    /**
     * 해당 행의 값들
     */
    values: {
        [fieldName: string]: string;
    };
}
/**
 * {@link GridBase.getGroupSummary} 에서 반환되는 오브젝트 형식
 *
 * @remarks
 * `getGroupSummary` 에 `statistical` 을 `true` 로 하면, `var`, `varp`, `stdev`, `stdevp` 가 추가된다.
 */
interface GroupSummary {
    /**
     * 행 갯수
     */
    count: number;
    /**
     * 합
     */
    sum: number;
    /**
     * 최대값
     */
    max: number;
    /**
     * 최소값
     */
    min: number;
    /**
     * 평균
     */
    avg: number;
    /**
     * 값이 지정되어 잇는 데이터 개수 (null 이 아닌)
     */
    datacount: number;
    /**
     * `datacount` 로 나눈 평균
     */
    dataavg: number;
    /**
     * 표본집단 분산
     */
    var?: number;
    /**
     * 모집단 분산
     */
    varp?: number;
    /**
     * 표본집단 표준편차
     */
    stdev?: number;
    /**
     * 모집단 표준편차
     */
    stdevp?: number;
}
/**
 * {@link EditValidation} 의 콜렉션 모델
 *
 * @remarks
 * {@link DataColumn.validations | column의 validations} 를 반환할 때 이 오브젝트를 반환한다.
 */
interface EditValidationCollection$1 {
    /**
     * 검증 조건 모델들의 갯수
     * @readonly
     */
    count: number;
    /**
     * 검증 조건 모델의 배열
     */
    items: EditValidation$1[];
}
/**
 * 변경된 셀 정보
 *
 * @remarks
 * {@link UpdatedRow} 에서 사용된다.
 */
interface UpdatedCell {
    /**
     * 필드명
     */
    fieldName: string;
    /**
     * 변경 전 값
     */
    oldValue: any;
    /**
     * 변경 후 값
     */
    newValue: any;
}
/**
 * 변경된 행 정보
 *
 * @remarks
 * {@link DataProviderBase.getUpdatedCells | getUpdatedCells()} 에서 사용된다.
 */
interface UpdatedRow {
    /**
     * 행의 고유번호
     */
    __rowId: number;
    /**
     * 변경된 셀 정보들
     */
    updatedCells: UpdatedCell[];
}
/**
 * 검색된 셀의 위치정보
 *
 * @remarks
 * {@link GridBase.searchCell} 또는 {@link LocalDataProvider.searchData} / {@link LocalTreeDataProvider.searchData} 에서 사용한다.
 */
interface SearchCellResult {
    /**
     * 행 고유 번호
     */
    dataRow: number;
    /**
     * 필드 인덱스
     */
    fieldIndex: number;
    /**
     * 검색한 필드 목록에서의 인덱스
     */
    searchFieldIndex: number;
    /**
     * 필드이름
     */
    fieldName: string;
}

declare enum VerticalMoveStep {
    ROW = "row",
    CELL = "cell"
}
/**
 * @internal
 */
declare class CellIndex extends Base implements CellIndex$1 {
    private static $_temp;
    static temp(grid?: GridBase$1, itemIndex?: number, column?: CellLayoutItem | GridColumn): CellIndex;
    static areEquals(idx1: CellIndex, idx2: CellIndex): boolean;
    static equalsTo(idx: CellIndex, itemIndex: number, layout: CellLayoutItem): boolean;
    static clearTemp(): void;
    static compareHorz(index1: CellIndex, index2: CellIndex): number;
    private _grid;
    private _itemIndex;
    private _layout;
    constructor(grid?: GridBase$1, itemIndex?: number, column?: any);
    protected _doDispose(): void;
    /** grid */
    get grid(): GridBase$1;
    /** itemIndex */
    get itemIndex(): number;
    set itemIndex(value: number);
    /** layout */
    get layout(): CellLayoutItem;
    set layout(value: CellLayoutItem);
    /** column */
    get column(): GridColumn;
    set column(value: GridColumn);
    /** dataColumn */
    get dataColumn(): DataColumn;
    /** valueColumn */
    get valueColumn(): ValueColumn;
    /** dataField */
    get dataField(): number;
    /** item */
    get item(): GridItem;
    /** dataRow */
    get dataRow(): number;
    set dataRow(value: number);
    /** fieldName */
    set fieldName(value: string);
    /** fieldIndex */
    set fieldIndex(value: number);
    /** dataId */
    get dataId(): number;
    /** value */
    get value(): any;
    get fixed(): boolean;
    get rowFixed(): boolean;
    get colFixed(): boolean;
    get rightFixed(): boolean;
    get isTop(): boolean;
    get isBottom(): boolean;
    get isLeft(): boolean;
    get isRight(): boolean;
    get isFirst(): boolean;
    get isEditableFirst(): boolean;
    get isEditableLast(): boolean;
    get isLast(): boolean;
    set(itemIndex: number, column: CellLayoutItem | GridColumn, grid?: GridBase$1): CellIndex;
    assign(source: CellIndex): CellIndex;
    reset(): CellIndex;
    clone(): CellIndex;
    proxy(): ConfigObject;
    normalize(grid: GridBase$1): CellIndex;
    incRow(delta: number): void;
    first(): void;
    last(): void;
    right(): void;
    left(): void;
    next(): boolean;
    prev(): boolean;
    home(): void;
    end(): void;
    firstCell(): void;
    lastCell(): void;
    down(step?: VerticalMoveStep, editing?: boolean, crossTab?: boolean): void;
    up(step?: VerticalMoveStep, editing?: boolean, crossTab?: boolean): void;
    getValue(): any;
    assignFrom(source: ConfigObject | Base): void;
    toString(): string;
    private $_gridLayout;
    private $_isSpanned;
}
/** @internal */
declare class CellRange extends Base {
    static readonly NULL: CellRange;
    private static readonly $_TEMP;
    private static $_setRange;
    static create(index1: CellIndex, index2?: CellIndex): CellRange;
    static temp(index1: CellIndex, index2: CellIndex): CellRange;
    static createRange(r1: number, c1: CellLayoutItem, r2: number, c2: CellLayoutItem): CellRange;
    private _row1;
    private _col1;
    private _row2;
    private _col2;
    constructor();
    get empty(): boolean;
    get r1(): number;
    get c1(): CellLayoutItem;
    get r2(): number;
    get c2(): CellLayoutItem;
    get top(): number;
    get bottom(): number;
    get firstCell(): CellIndex;
    get lastCell(): CellIndex;
    contains(itemIndex: number, layout: CellLayoutItem): boolean;
    normalize(): CellRange;
    normalizeData(): CellRange;
    intersectsWith(other: CellRange): boolean;
}

/**
 * @remarks
 * 그리드의 셀 관련 모델의 기반 클래스
 *
 * [하위 클래스]
 *
 * {@link StyledCell}
 * {@link ValueCell}
 *  - {@link DataCell}
//  *  - {@link SeriesCell}
 */
interface GridCell$1 {
    /**
     * 셀의 위치정보
     *
     * @remarks
     * {@link CellIndex} 와는 다르게 proxy처리되지 않은 내부 객체가 그대로 전달된다.
     */
    index?: CellIndex;
    /**
     * 셀이 위치한 아이템의 정보 모델
     */
    item?: GridItem;
    /**
     * 셀이 참조하는 Column정보
     */
    valueColumn?: ValueColumn;
    /**
     * 셀이 참조하는 DataColumn정보
     */
    dataColumn?: DataColumn;
    /**
     * 화면에 표시되는 text
     *
     * @remarks
     * 그리드 body영역을 제외한 나머지 셀에 표시되는 text
     */
    text?: string;
    /**
     * 참조하고 있는 data
     *
     * @remarks
     * 그리드 body영역에 위치한 셀의 value
     *
     */
    value?: any;
    /**
    * RowGroup관련 셀인 경우 참조하고 있는 item의 level
    * @defaultValue `0`
    */
    level?: number;
}

/**
 * @internal
 */
declare abstract class GridCell extends Base implements GridCell$1 {
    static readonly ERROR = "<<ERROR>>";
    private _name;
    private _index;
    constructor(name: string);
    protected _doDispose(): void;
    /** name */
    get name(): string;
    /** index */
    get index(): CellIndex;
    /** item */
    get item(): GridItem;
    /** valueColumn */
    get valueColumn(): ValueColumn;
    /** dataColumn */
    get dataColumn(): DataColumn;
    /** text */
    get text(): string;
    /** value  */
    get value(): any;
    /** level */
    get level(): number;
    setIndex(value: CellIndex): void;
    setIndex2(grid: GridBase$1, itemIndex: number, column: GridColumn): void;
    setLayout(layout: CellLayoutItem): void;
}
/**
 * @internal
 */
declare class StyledCell extends GridCell {
    private _model;
    constructor(model: GridObject, name?: string);
    protected _doDispose(): void;
    /** model */
    get model(): GridObject;
    set model(value: GridObject);
}
/**
 * @internal
 */
declare abstract class ValueCell extends GridCell {
    constructor(name: string);
    protected _doDispose(): void;
    error: any;
    errorLevel: ValidationLevel;
    getBlankState(): BlankState;
    isValueChanged(): boolean;
}
/**
 * @internal
 */
interface CellFormatter {
    numberFormatter: DecimalFormatter;
    datetimeWriter: DateTimeWriter;
    booleanFormatter: BooleanFormatter;
    textFormatter: TextFormatter;
    prefix: string;
    suffix: string;
}

/**
 * @internal
 */
declare class RendererEditResult$1 {
    commit: boolean;
    value: any;
}
/**
 * {@link CellRenderer.ariaLabelCallback} 에서 사용되는 콜백 형식
 *
 * @remarks
 * [매개변수 목록]
 *
 * `grid` - GridBase 컨트롤
 *
 * `model` - 그리드의 셀
 *
 * [반환값] - 스크린 리더가 읽을 문자열.
 *
 * @example
 * ```js
 * const f = function(grid, model) {
 *      var s = model.value;
 *      var date = grid.getValue(model.item.index, "date")
 *      s += (date.getTime() > Date.now() - 60*60*24*7*1000) ? " 신규" : "";
 *      return s;
 * }
 *
 * column.renderer = {
 *      type: 'text',
 *      ariaLabelCallback: f
 * }
 * ```
 */
declare type GetAriaLabelCallback = (grid: GridBase$1, model: GridCell) => string;
/**
 * @internal
 *
 * [제한 사항]
 * 1. Check/Icon/Shape 에서 자동 높이 일 때 TOP_EDGE, BOTTOM_EDGE를 사용할 수 없다.
 *    자동 높이인 경우 셀들을 모두 렌더링하기 전에 행의 실제 높이를 알 수 없다.
 *    TOP_EDGE 등은 셀의 실제 높이를 요구한다.
 */
declare abstract class DataCellRenderer extends Base {
    static getRendererStyle(cell: HTMLTableCellElement): string;
    private _showTooltip;
    private _refreshFocusChanged;
    private _ariaLabelCallback;
    protected _dom: HTMLElement;
    protected _textProp: string;
    private _inited;
    private _dirty;
    private _className;
    private _index;
    protected _itemClickable: boolean;
    constructor();
    protected _doDispose(): void;
    clearAndDispose(): DataCellRenderer;
    initContent(index: CellIndex, dom: HTMLElement, styleName: string): void;
    initFormContent(dom: HTMLElement, styleName: string): void;
    clearContent(): void;
    checkClassName(value: string): boolean;
    initOptions(): void;
    /** type */
    abstract get type(): string;
    /** grid */
    get grid(): GridBase$1;
    /** index */
    get index(): CellIndex;
    /** styleName */
    get styleName(): string;
    /** showTooltip */
    get showTooltip(): boolean;
    set showTooltip(value: boolean);
    /** ariaLabelCallback */
    get ariaLabelCallback(): GetAriaLabelCallback;
    set ariaLabelCallback(value: GetAriaLabelCallback);
    get refreshFocusChanged(): boolean;
    set refreshFocusChanged(value: boolean);
    /** itemClickable */
    get itemClickable(): boolean;
    renderCell(grid: GridBase$1, model: GridCell, cell: BodyTableCell): void;
    getTooltip(cell: BodyTableCell, index: CellIndex): string;
    canShowInnerFocus(): boolean;
    /**
     * 편집 가능한 렌더러인가?
     */
    canEdit(): boolean;
    canEditClickAt(event: MouseEvent): boolean;
    /**
     * Html element의 기본 편집 동작을 중지 시키도록 요청 받았다.
     */
    preventDefaultEditClick(event: MouseEvent): void;
    /**
     * result를 리턴하지 않으면 편집 행위가 없는 것으로 판단한다.
     * 편집 행위가 없는 경우 preventDefaultEditClick가 호출돼서
     * 엘리먼트 기본 편집 동작을 무시하도록 요청 받는다.
     */
    editClick(index: CellIndex, event: MouseEvent): RendererEditResult$1;
    /**
     * 편집할 수 없으면 false를 리턴해야 한다.
     */
    protected _doEditClick(index: CellIndex, event: MouseEvent, result: RendererEditResult$1): boolean;
    /**
     * Html element의 기본 click 동작을 중지 시키도록 요청 받았다.
     */
    preventDefaultClick(event: Event): void;
    canClick(event: MouseEvent): boolean;
    canClickSpaceKey(event: Event): boolean;
    /**
     * event.target이 클릭 가능하면 클릭 data를 리턴한다.
     * 리턴된 data는 그리드 onCellItemClicked 이벤트로 전달된다.
     * 그리드 이벤트가 false를 return하면 preventDefaultClick이 호출돼서
     * 엘리먼트 기본 클릭 동작을 무시하도록 요청된다.
     */
    click(index: CellIndex, event: Event, target?: HTMLElement): any;
    /**
     * space등을 이용해서 click을 실행시킬려고 한다.
     */
    itemClick(): void;
    protected _doItemClick(): void;
    protected _doClick(index: CellIndex, event: Event, target?: HTMLElement): any;
    /**
     * 입력 키로 사용할 수 있으면 true 리턴.
     */
    canEditKey(e: KeyboardEvent): boolean;
    /**
     * result를 리턴하지 않으면 편집 행위가 없는 것으로 판단한다.
     */
    editKey(index: CellIndex, e: KeyboardEvent): RendererEditResult$1;
    protected _doEditKey(index: CellIndex, e: KeyboardEvent, result: RendererEditResult$1): boolean;
    moveClickElement(top: number, merged: boolean): void;
    protected _doInitContent(dom: HTMLElement): void;
    protected _doClearContent(dom: HTMLElement): void;
    protected _doRenderCell(grid: GridBase$1, model: GridCell, bcell: BodyTableCell, w: number, h: number): void;
    protected _changed(): void;
    protected _getValue(grid: GridBase$1, model: GridCell, fieldName: string): any;
    protected _makeText(grid: GridBase$1, model: GridCell, bcell: BodyTableCell): string;
    protected _clearHeight(): void;
    protected _setHeight(value: number): void;
    protected _isEmpty(value: any): boolean;
    protected _doInitOptions(): void;
}

/** @internal */
declare abstract class SummaryCell extends GridCell {
    protected _childIndex: number;
    private _value;
    private _error;
    private _errorDetail;
    constructor(name: string);
    protected _doDispose(): void;
    /** level */
    get level(): number;
    /** error */
    get error(): any;
    /** errorDetail */
    get errorDetail(): string;
    calculate(): void;
    /** text */
    get text(): string;
    /** value */
    get value(): any;
    getDisplayText(cf: CellFormatter): string;
    getSummary(): ColumnSummary;
    getTemplate(cf: CellFormatter): string;
    protected abstract _getSummary(column: ValueColumn, childIndex: number): ColumnSummary;
}
/**
 * @internal
 * {@link GridFooter}와 {@link HeaderSummary}의 기반 모델
 *
 * @remarks
 * GridSummaryObject 의 모든 속성은 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 */
declare abstract class GridSummaryObject extends VisualObject {
    private _styleName;
    private _minHeight;
    private _height;
    private _cellStyleCallback;
    private _formatter;
    /**
     * @internal
     */
    protected $_owner: SummaryCollection;
    /**
     * @internal
     */
    protected _childIndex: number;
    /**
     * @internal
     */
    protected _displayIndex: number;
    private _cell;
    private _runtime;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 스타일 클래스 이름
     */
    get styleName(): string;
    set styleName(value: string);
    /**
     *
     */
    get displayIndex(): number;
    /**
     * 최소 높이
     *
     * @defaultValue `23`
     */
    get minHeight(): number;
    set minHeight(value: number);
    /**
     * 높이
     *
     * @remarks
     * `0`이면 자동으로 계산하여 지정한다. `0` 이상이면 {@link GridSummaryObject.minHeight}와 비교하여 더 큰 값으로 지정한다.
     *
     * @defaultValue `0`
     */
    get height(): number;
    set height(value: number);
    /**
     * 셀 스타일을 지정하기 위한 콜백
     * @eventProperty 각각의 모델에서 처리해주기 혹은 새로 interface 생성하기
     *
     * @example
     * ```js
     * // 푸터 적용
     * const f = function (grid, cell) {
     *      return {
     *          styleName: 'custom-cell'
     *      }
     * }
     * footer.cellStyleCallback = f;
     * ```
     * @internal
     */
    get cellStyleCallback(): CellStyleCallback;
    set cellStyleCallback(value: CellStyleCallback);
    /**
     * @internal
     */
    abstract getCellStyleName(): string;
    /**
     * @internal
     */
    getCell(layout: CellLayoutItem): SummaryCell;
    /**
     * @internal
     */
    getCellStyle(model: SummaryCell, cs: ColumnSummaryStyle, addDefaultStyle?: boolean): ColumnSummaryStyle;
    /**
     * @internal
     */
    getCellFormatters(summary: ColumnSummary, cf: CellFormatter): CellFormatter;
    /**
     * @internal
     */
    protected _visibleChanged(): void;
    /**
     * @internal
     */
    protected abstract _createCell(): SummaryCell;
}
/**
 * 푸터 영역의 설정 모델
 * @internal
 */
declare class GridFooter extends GridSummaryObject {
    private static readonly CELL_CSS;
    constructor(grid: GridBase$1);
    /**
     * 푸터의 순서
     */
    get footerIndex(): number;
    /**
     * @internal
     */
    getCellStyleName(): string;
    /**
     * @internal
     */
    protected _createCell(): SummaryCell;
}
/** @internal */
declare abstract class SummaryCollection extends VisualObject {
    protected _items: GridSummaryObject[];
    protected _visibles: GridSummaryObject[];
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** canShow */
    get canShow(): boolean;
    /** count */
    get count(): number;
    /** visibleCount */
    get visibleCount(): number;
    get(index: number): GridSummaryObject;
    getVisible(index: number): GridSummaryObject;
    isVisible(): boolean;
    protected abstract _createSummary(grid?: GridBase$1): GridSummaryObject;
    assignFrom(source: any): void;
    clean(): void;
    toProxy(): ConfigObject;
    private $_visibleChanged;
    private $_resetVisibles;
}
/**
 * @internal
 */
declare class GridFooterCollection extends SummaryCollection implements GridFooterCollection$1 {
    protected _createSummary(grid?: GridBase$1): GridFooter;
}

/**
 * 셀 렌더러들의 기반 모델
 *
 * @remarks
 * 데이터 셀들의 값을 그리드에 표시하기 위한 장치이다.
 *
 * CellRenderer 의 모든 프로퍼티는 이를 상속한 클래스에서만 호출 / 설정할 수 있다. 아래 목록을 참조할 것.
 *
 * 이전 버전의 셀 렌더러는 기본적으로 컬럼에서 생성되는 스타일 정보를 이용해서 렌더링하지만, 2.0 부터는 css style class 로 적용된다.
 *
 * 각각의 {@link ValueColumn.renderer | 컬럼}에 셀렌더러의 종류와 속성들을 지정한다.
 *
 * 셀 렌더러 별로 지정할 수 있는 속성이 있으며, DataColumn 에 지정하지 않을 시 {@link TextCellRenderer} 가 기본으로 설정된다.
 *
 * 또, 오브젝트 형태일 때 `type` 속성을 {@link ValueColumn.renderer | column.renderer} 에 문자열 형태로 지정 가능하다.
 *
 * [목록]
 *
 * {@link TextCellRenderer}: 기본 텍스트 렌더러
 *
 * {@link BarCellRenderer}: 바 렌더러
 *
 * {@link ImageCellRenderer}: 이미지 렌더러
 *
 * {@link IconCellRenderer}: 아이콘 렌더러
 *
 * {@link CheckCellRenderer}: 체크 셀 렌더러
 *
 * {@link ButtonCellRenderer}: 버튼 렌더러
 *
 * {@link ShapeCellRenderer}: 도형 렌더러
 *
 * {@link LinkCellRenderer}: 링크 셀 렌더러
 *
 * {@link SignalBarCellRenderer}: 시그널 바 렌더러
 *
 * {@link Code39CellRenderer}: 바코드 렌더러
 *
 * {@link Code128CellRenderer}: 바코드 렌더러
 *
 * {@link SeriesTextCellRenderer}: 시리즈 텍스트 렌더러
 *
 * {@link SparkLineRenderer}: 시리즈 스파크 라인 렌더러
 *
 * {@link SparkColumnRenderer}: 시리즈 컬럼 렌더러
 *
 * {@link SparkWinLossRenderer}: 시리즈 윈 로스 렌더러
 *
 * {@link TemplateCellRenderer}: 템플릿 렌더러
 *
 * @warning CellRenderer 로 직접 설정하거나 호출할 수 없다.
 *
 * @example
 * ```js
 * // string type
 * column.renderer = "text"
 *
 * // object type
 * column.renderer = { type: "text", showTooltip: true}
 * ```
 */
interface CellRenderer {
    /**
     * 렌더러의 종류
     *
     * @remarks
     * {@link TextCellRenderer}: `'text'`
     *
     * {@link BarCellRenderer}: `'bar'`
     *
     * {@link ImageCellRenderer}: `'image'`
     *
     * {@link IconCellRenderer}: `'icon'`
     *
     * {@link CheckCellRenderer}: `'check'`
     *
     * {@link ButtonCellRenderer}: `'button'`
     *
     * {@link ShapeCellRenderer}: `'shape'`
     *
     * {@link LinkCellRenderer}: `'link'`
     *
     * {@link SignalBarCellRenderer}: `'signalbar'`
     *
     * {@link Code39CellRenderer}: `'code39'`
     *
     * {@link Code128CellRenderer}: `'code128'`
     *
     * {@link SeriesTextCellRenderer}: `'series'`
     *
     * {@link SparkLineRenderer}: `'sparkline'`
     *
     * {@link SparkColumnRenderer}: `'sparkcolumn'`
     *
     * {@link SparkWinLossRenderer}: `'sparkswinloss'`
     *
     * {@link TemplateCellRenderer}: `'template'`
     */
    type?: string;
    /**
     * 툴팁 표시 여부
     */
    showTooltip?: boolean;
    /**
     * aria-label을 직접 설정할경우 사용하는 콜백
     *
     *
     * @remarks
     * 스크린 리더가 셀의 정보를 읽을때 사용할 문자열을 설정한다.
     *
     * {@link GetAriaLabelCallback} 의 형식을 따른다.
     *
     * [프로퍼티 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `model` - 그리드의 셀
     *
     * @eventProperty
     * @example
     * ```js
     * const f = function(grid, model) {
     *      var s = model.value;
     *      var date = grid.getValue(model.item.index, "date")
     *      s += (date.getTime() > Date.now() - 60*60*24*7*1000) ? " 신규" : "";
     *      return s;
     * }
     *
     * column.renderer = {
     *      type: 'text',
     *      ariaLabelCallback: f
     * }
     * ```
     */
    ariaLabelCallback?: GetAriaLabelCallback;
}
/**
 * 사용자 지정 셀 렌더러를 설정할 때 사용하는 오브젝트
 *
 * @remarks
 * {@link GridBase.registerCustomRenderer} 로 사용 가능하다.
 *
 * @example
 * ```js
 * gridView.registerCustomRenderer("renderer01", {
 *     initContent(parent) {
 *         var span = this._span = document.createElement("span");
 *         parent.append(span);
 *     },
 *     ...
 * }
 * ```
 */
interface CustomCellRenderer {
    /**
     * 내용 초기화 시에 실행 될 콜백
     * @eventProperty
     *
     * [매개변수 목록]
     *
     * `dom` - parent element
     *
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      initContent: function(dom) {
     *          let span = this._span = document.createElement("span");
     *          span.className = "custom_render_span"
     *          dom.appendChild(span);
     *
     *          dom.appendChild(this._button1 = document.createElement("span"));
     *          dom.appendChild(this._button2 = document.createElement("span"));
     *
     *          let a = this._href = document.createElement("a");
     *          a.href = "http://realgrid.com";
     *          a.target = "_blank";
     *          a.tabIndex = -1;
     *          a.textContent = "real";
     *          dom.appendChild(a);
     *      }
     * }
     * ```
     */
    initContent?: (dom: HTMLElement) => void;
    /**
     * 내용 초기화 시에 실행 될 콜백
     *
     * @remarks
     * {@link GridBase.destroy | grid.destroy} 를 실행했을때 호출되는 method 이다.
     *
     * 메모리 누수를 방지하기 위해서 {@link CustomCellRenderer.initContent | initContent} 에서 생성되거나 참조하는 객체들을 모두 해제해 주어야 한다.
     *
     * `addEventListener` 또는 `onclick`등으로 연결한 이벤트가 있는 경우 반드시 해제를 해주어야 한다
     *
     * [매개변수 목록]
     *
     * `dom` - parent element
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      clearContent: function(dom) {
     *          dom.innerHTML = "";
     *      }
     * }
     * ```
     */
    clearContent?: (dom: HTMLElement) => void;
    /**
     * 렌더링 시에 실행 될 콜백
     *
     * @remarks
     * element 내의 text 나 style 을 적용 시킬 수 있다.
     *
     * [매개변수 목록]
     *
     * `grid` - {@link GridBase} 컨트롤
     *
     * `model` - GridCell 객체
     *
     * `w` - 폭
     *
     * `h` - 너비
     *
     * `info` - 추가정보
     *
     * @eventProperty
     *
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      render: function(grid, model, w, h, info) {
     *           let span = this._span;
     *
     *           // text설정.
     *           span.textContent = model.value + "-YYY";
     *           this._value = model.value;
     *
     *           // className 또는 style에 직접설정
     *           // style에 직접설정하는 경우 className을 이용하는것보다 속도가 느려질수 있다.
     *           // 가능하다면 className을 이용한다.
     *           this._button1.className = "custom_none";
     *           this._button2.className = "custom_none";
     *
     *           switch(model.value) {
     *               case "Germany":
     *                   this._button1.className = "custom_search custom-hover";
     *                   this._button2.className = "custom_de custom-hover";
     *                   break;
     *               case "France":
     *                   this._button1.className = "custom_fr custom-hover";
     *                   break;
     *               case "Brazil":
     *                   this._button1.className = "custom_br custom-hover";
     *                   break;
     *           }
     *      }
     * }
     * ```
     */
    render?: (grid: any, model: GridCell$1, w: number, h: number, info: any) => void;
    /**
     * 그리드의 클릭 이벤트를 사용할지 결정하기 위한 콜백
     *
     * @remarks
     * `false` 를 반환하면 그리드는 더 이상 이벤트를 처리하지 않고, element 의 기본동작이 실행된다.
     *
     * 해당 콜백을 등록하지 않는 경우 `false` 를 반환한다.
     *
     * {@link CustomCellRenderer.click} 을 사용하기 위해서는 `true`를 반환하는 함수로 설정해야 한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canClick : function() {
     *          return true;
     *      }
     * }
     * ```
     */
    canClick?: (event: MouseEvent) => boolean;
    /**
     * 클릭 시에 실행 될 콜백
     *
     * @remarks
     * element 의 click event 와는 별개로 처리된다.
     *
     * `event.target`이 클릭 가능하면 {@link ClickData} 를 반환해야 한다.
     *
     * 반환 된 데이터는 {@link GridBase.onCellItemClicked} 이벤트로 전달된다.
     *
     * `false` 반환 시 해당 이벤트를 중지시킨 후 {@link CustomCellRenderer.preventClick | preventClick} 을 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      click: function(event) {
     *          let index = this.index.toProxy();
     *          if ( event.target === this._button1 ||  event.target === this._button2 || event.target === this._href) {
     *              return {
     *                  cellType:"data",
     *                  target : event.target,
     *                  index: index,
     *                  value: this._value
     *              }
     *          }
     *      }
     * }
     * ```
     */
    click?: (event: MouseEvent) => any;
    /**
     * 클릭을 중지시키기 위한 콜백
     *
     * @remarks
     * `event.preventDefault()` 를 자유롭게 호출하기 위해 만들어졌다.
     *
     * 해당 콜백을 지정하지 않으면, {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault | Event.preventDefault} 가 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 클릭 이벤트
     * @eventProperty
     */
    preventClick?: (event: MouseEvent) => void;
    /**
     * 편집 가능한 렌더러인지의 여부
     *
     * @remarks
     * [매개변수 목록]
     *
     * `event` - 마우스 이벤트
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canEdit: function() {
     *          return true;
     *      }
     * }
     * ```
     */
    canEdit?: (event: MouseEvent) => boolean;
    /**
     * 편집 완료 행위를 결정하는 콜백
     *
     * @remarks
     * `false` 반환 시 {@link CustomCellRenderer.preventEditClick} 을 호출한다.
     *
     * [매개변수 목록]
     *
     * `index` - 편집
     *
     * `event` - 마우스 이벤트
     *
     * `result` - 편집 완료 결과
     * @eventProperty
     */
    editClick?: (index: CellIndex$1, event: MouseEvent, result: RendererEditResult) => boolean;
    /**
     * 편집 시 편집 완료를 중지시키기 위한 콜백
     *
     * @remarks
     * `event.preventDefault()` 를 자유롭게 호출하기 위해 만들어졌다.
     *
     * 해당 콜백을 지정하지 않으면, {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault | Event.preventDefault} 가 호출한다.
     *
     * [매개변수 목록]
     *
     * `event` - 마우스 이벤트
     * @eventProperty
     */
    preventEditClick?: (event: MouseEvent) => void;
    /**
     * 편집 단축키를 지정하는 것을 결정하기 위한 콜백
     *
     * @remarks
     * `false` 를 반환하면 특정 키를 눌렀을 때 편집하는 기능을 반영하지 않는다.
     *
     * [매개변수 목록]
     *
     * `event` - 키보드 이벤트
     *
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      canEditKey: function(event) {
     *          return event.ctrlKey && event.keyCode === 65;
     *      }
     * }
     * ```
     */
    canEditKey?: (event: KeyboardEvent) => boolean;
    /**
     * 설정한 편집 단축키로 편집을 하기 위한 콜백
     *
     * @remarks
     * `false` 반환 시 편집을 취소한다.
     *
     * [매개변수 목록]
     *
     * `index` - 편집
     *
     * `event` - 마우스 이벤트
     *
     * `result` - 편집 완료 결과
     * @eventProperty
     * @example
     * ```js
     * grid.registerCustomRenderer("renderer01", {
     *      editKey: function(index, event, result) {
     *          result.commit = false;
     *          if (event.ctrlKey && event.keyCode === 65) {
     *              result.commit = true;
     *              result.value = '가나다라';
     *              return true;
     *          }
     *          return false;
     *      }
     * }
     * ```
     */
    editKey?: (index: CellIndex$1, event: KeyboardEvent, result: RendererEditResult) => boolean;
}
/**
 * 사용자 지정 렌더러의 편집 완료 결과 모델
 *
 * @remarks
 * {@link CustomCellRenderer.editClick} 에서 반환되어야 한다.
 */
interface RendererEditResult {
    /**
     * 커밋 여부
     *
     * @defaultValue `true`
     */
    commit: boolean;
    /**
     * 수정된 값
     */
    value: any;
}

/**
 * {@link RowStyleCallback} 으로 행의 스타이을 변경시 반환되는 스타일 모델
 *
 * @remarks
 * {@link GridBase.setRowStyleCallback}에서 사용된다.
 *
 * @example
 * ```js
 * cosnt f = function(grid, item fixed) {
 *   if (dataProvider.getValue(item.dataRow, "fieldName") === "value") {
 *     return {
 *       editable: false,
 *       styleName: "userStyleName"
 *     }
 *   }
 * }
 * gridView.setRowStyleCallback(f);
 * ```
 */
interface RowStyleObject {
    /**
     * 행전체의 editable 여부
     *
     * @remarks
     * 지정하지않으면 다음 순위의 editable이 적용된다.
     */
    editable?: boolean;
    /**
     * 행전체의 readOnly여부
     * @remarks
     * 지정하지않으면 다음 순위의 editable이 적용된다.
     */
    readOnly?: boolean;
    /**
     * 행의 className
     * @remarks
     * 지정하지 않으면 그리드의 기본 스타일명이 사용된다.
     */
    styleName?: string;
    /**
     * excel로 export할때 적용되는 스타일 명
     */
    exportStyleName?: string;
}
/**
 * {@link CellStyleCallback} 으로 셀 스타일 변경 시 반환해야 하는 스타일 모델 중 하나
 *
 * @remarks
 * {@link GridBase.setCellStyleCallback} 또는 {@link ValueColumn.styleCallback} 에서 사용된다.
 *
 * @example
 * ```js
 * // column 별 적용
 * let column = gridView.columnByName('Company');
 *
 * const f = function (grid, cell) {
 *      return {
 *          styleName: 'custom-column'
 *      }
 * }
 * column.styleCallback = f;
 *
 * // data cell 별 적용
 * gridView.setCellStyleCallback(f);
 * ```
 */
interface ColumnStyleObject {
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * excel로 export될때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 렌더러
     */
    renderer?: CellRenderer;
    /**
     * 편집기로 수정 가능 여부
     */
    editable?: boolean;
    /**
     * 수정 가능 금지 여부
     */
    readOnly?: boolean;
    /**
     * 에디터
     */
    editor?: CellEditor$1;
    /**
     * 텍스트 형식의 값일 때 서식
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 값의 앞쪽에 덧붙여 표시할 텍스트
     */
    prefix?: string;
    /**
     * 값의 뒤쪽에 덧붙여 표시할 텍스트
     */
    suffix?: string;
    /**
     * 엑셀로 export할때 format을 지정한다.
     *
     * @remarks
     * 지정하지 않으면 {@link DataColumn.excelFormat} 또는 dataType에 따른 format이 적용된다.
     */
    excelFormat?: string;
    /**
     * 엑셀로 export할때 셀 잠금 또는 수식 숨기기를 설정한다.
     *
     * @remarks
     * 지정하지 않으면 {@link DataColumn.cellProtectProps}가 적용된다.
     * {@link GridExportOptions.sheetProtect}와 함께 사용한다.
     */
    cellProtectProps?: CellProtectProperties;
}
/**
 * {@link CellStyleCallback} 으로 셀 스타일 변경 시 반환해야하는 스타일 모델 중 하나
 *
 * @remarks
 * {@link GridFooter.cellStyleCallback}, {@link HeaderSummary.cellStyleCallback} 에서 사용된다.
 *
 * @example
 * ```js
 * // 푸터 적용
 * const f = function (grid, cell) {
 *      return {
 *          styleName: 'custom-footer'
 *      }
 * }
 * footer.cellStyleCallback = f;
 *
 * const f2 = function (grid, cell) {
 *      return {
 *          styleName: 'custom-summary'
 *      }
 * }
 *
 * headerSummary.cellStyleCallback = f2;
 * ```
 */
interface ColumnSummaryStyleObject {
    /**
     * 스타일 명
     */
    styleName?: string;
    /**
     * excel로 export할때 적용될 스타일 명
     */
    exportStyleName?: string;
    /**
     * 텍스트 형식의 값일 때 서식
     */
    textFormat?: string;
    /**
     * 날짜 형식의 값일 때 서식
     */
    datetimeFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     */
    numberFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 값의 앞쪽에 덧붙여 표시할 텍스트
     */
    prefix?: string;
    /**
     * 값의 뒤쪽에 덧붙여 표시할 텍스트
     */
    suffix?: string;
}

/**
 * 아이템의 상태
 */
declare enum ItemState {
    /**
     * 편집, 추가, 입력 중이 아닌 경우
     */
    NORMAL = "normal",
    /**
     * 입력된 인덱스가 현재 편집 중인 아이템의 인덱스인 경우
     */
    FOCUSED = "focused",
    /**
     * 편집 중인 경우
     */
    UPDATING = "updating",
    /**
     * 삽입 중인 경우
     */
    INSERTING = "inserting",
    /**
     * 추가 중인 경우
     */
    APPENDING = "appending",
    /**
     * 더미
     */
    DUMMY = "dummy"
}
/**
 * @internal
 */
declare class RowStyle implements RowStyleObject {
    styleName: string;
    editable: boolean;
    readOnly: boolean;
    exportStyleName: string;
    style: ConfigObject;
    clear(): this;
    assign(source: string | ConfigObject): void;
}
/** @internal */
declare abstract class GridItem {
    static readonly PARENT = "_parent";
    static $$_grid_item_id: number;
    private _id;
    private _index;
    private _parent;
    private _heights;
    constructor();
    dispose(): void;
    abstract get type(): ItemType;
    /** id  */
    get id(): number;
    /** index  */
    get index(): number;
    /** parent  */
    get parent(): GroupItem | null;
    /** parentIndex  */
    get parentIndex(): number;
    /** root  */
    get root(): GroupItem | null;
    /** childIndex  */
    get childIndex(): number;
    /** level */
    get level(): number;
    /** isLeaf */
    abstract get isLeaf(): boolean;
    /** isData */
    get isData(): boolean;
    /** isDataRow */
    get isDataRow(): boolean;
    /** isVisible */
    get visible(): boolean;
    /** displayLevel */
    get displayLevel(): number;
    /** provider */
    get provider(): ItemProvider;
    /** dataSource */
    get dataSource(): DataSource;
    /** dataRow */
    get dataRow(): number;
    /** dataId */
    get dataId(): number;
    /** rowState */
    get rowState(): RowState;
    /** itemState */
    get itemState(): ItemState;
    /** checked */
    get checked(): boolean;
    /** checkable */
    get checkable(): boolean;
    /** editable */
    get editable(): boolean;
    /** readOnly */
    get readOnly(): boolean;
    set readOnly(value: boolean);
    /** resizable */
    get resizable(): boolean;
    /** merged */
    get merged(): boolean;
    /** height */
    get height(): number;
    private $_setHeight;
    protected $_clearHeight(all: boolean): void;
    /** heights */
    get heights(): number[];
    set heights(value: number[]);
    getShadowRow(): number;
    getHeight(index: number): number;
    setChecked(value: boolean, checkEvent: boolean): void;
    setCheckable(value: boolean): void;
    getAncestor(level: number): GroupItem;
    getVisibleAncestor(): GroupItem;
    getAncestors(): GroupItem[];
    isDescendantOf(group: GroupItem): boolean;
    getData(field: number): any;
    setData(field: number, value: any): void;
    getRowData(): RowValues;
    getRowObject(): RowObject;
    isChanged(field: number): boolean;
    canEdit(): boolean;
    protected abstract _getExtents(): number;
    protected abstract _setExtents(value: number): void;
    protected _setIndex(value: number): void;
    protected _setChecked(value: boolean): void;
    protected _setCheckable(value: boolean): void;
}
/** @internal */
declare class GridRow extends GridItem {
    private _dataRow;
    private _dataRowId;
    private _displayLevel;
    private _extents;
    private _editable;
    private _readOnly;
    constructor(dataRow: number);
    /** dataRowId */
    get dataRowId(): number;
    get editable(): boolean;
    get readOnly(): boolean;
    setEditable(editable: boolean, readOnly: boolean): void;
    protected _getExtents(): number;
    protected _setExtents(value: number): void;
    get isData(): boolean;
    get isDataRow(): boolean;
    get dataRow(): number;
    get dataId(): number;
    get isLeaf(): boolean;
    get resizable(): boolean;
    get displayLevel(): number;
    get type(): ItemType;
    canEdit(): boolean;
    getShadowRow(): number;
    protected $_setDisplayLevel(value: number): void;
}
/** @internal */
declare abstract class GroupItem extends GridItem {
    private _children;
    private _expanded;
    private _descendantCount;
    private _summaries;
    private _rows;
    constructor();
    dispose(): void;
    /** expanded */
    get expanded(): boolean;
    /** collapsed */
    get collapsed(): boolean;
    /** count */
    get count(): number;
    /** children */
    get children(): GridItem[];
    /** footer */
    abstract get footer(): GridItem;
    /** footerCount */
    abstract get footerCount(): number;
    get allFooterCount(): number;
    /** first */
    get first(): GridItem;
    /** last */
    get last(): GridItem;
    /** firstItem */
    get firstItem(): GridItem;
    /** firstDataItem */
    get firstDataItem(): GridRow;
    /** lastItem */
    getLastItem(checkFooter: boolean): GridItem;
    /** lastDataItem */
    get lastDataItem(): GridRow | null;
    /** descendantCount */
    get descendantCount(): number;
    /** expandable */
    get expandable(): boolean;
    /** collapsable */
    get collapsable(): boolean;
    getItem(index: number): GridItem;
    getRows(): number[];
    abstract getFooter(index: number): GridItem;
    abstract isFooter(item: GridItem): boolean;
    getFooterIndex(item: GridItem): number;
    itemOfRow(dataRow: number): GridItem;
    indexOf(item: GridItem): number;
    isDescendant(item: GridItem): boolean;
    getDescendants(visibleOnly: boolean): GridItem[];
    clear(): void;
    insert(index: number, item: GridItem): void;
    add(item: GridItem): void;
    addAll(items: GridItem[]): void;
    remove(item: GridItem): void;
    setItem(item: GridItem, newItem: GridItem): void;
    setExpanded(value: boolean, recursive: boolean, force: boolean): void;
    getNumber(field: number): number;
    getDataCount(field: number): number;
    getDataAvg(field: number): number;
    getSum(field: number): number;
    getMax(field: number): number;
    getMin(field: number): number;
    getAvg(field: number): number;
    getVar(field: number, n: number): number;
    getStdev(field: number, n: number): number;
    get isLeaf(): boolean;
    private _setExpanded;
    private _incDescendants;
    private _insertChild;
    protected _addChild(item: GridItem, index: number): void;
    protected _addChildren(items: GridItem[]): void;
    private _removeChild;
    protected _exchangeItems(index1: number, index2: number): void;
    private _moveChild;
    private $_collectRows;
    $_getSummary(field: number): any;
    private $_summarize;
    protected _saveExpanded(): void;
    protected _restoreExpanded(recursive?: boolean): void;
}
/** @internal */
declare class GroupItemImpl extends GroupItem {
    private _groupField;
    private _footer;
    private _footers;
    private _extents;
    private _allFooters;
    constructor(field: number);
    dispose(): void;
    /** groupField */
    get groupField(): number;
    protected _getExtents(): number;
    protected _setExtents(value: number): void;
    get footer(): GridItem;
    get type(): ItemType;
    /*************
     주의.. 특이한것이 하나있다.
     mergeMode == true인경우만 발생한다.
     collapsedAdornments가 "summary"일때  createFooterCallback을 이용해서 footer를 숨겨버리면 group자체가 사라지기 때문에 craeteFooter에 상관없이 footer을 추가해 버린다.
     더 문제가 되는 것은 footer가 2개이면서 보여지는 footer가 1개일때와 0개일때 동작이 다르다는 것이다.
     1개일때는 보여지는 footer가 있기 때문에 1개만 표시하지만
     0개일때는 보여지는 footer가 없기 때문에 모두 표시를 해버린다. 그래서 allFooterCount가 별도로 존재한다.
     일반적으로는 상관없지만 export할때는 많은 테스트가 필요하다.

     mergeMode가 false일때도 expandedAdornments가 summary인 경우 footer가 없다면 group을 접거나 펼칠수 없기 때문에 문제가 발생한다.
     */
    get footerCount(): number;
    get allFooterCount(): number;
    getHiddenFooterCount(): number;
    getFooter(index: number): GridItem;
    getFooterIndex(item: GridItem): number;
    isFooter(item: GridItem): boolean;
    protected _addChild(item: GridItem, index: number): void;
}

/**
 * @internal
 */
declare enum ActiveState {
    ACTIVE = "active",
    UNACTIVE = "unactive",
    INDETERMINATE = "indeterminate"
}
/**
 * 필터 콜백
 *
 * @remarks
 * {@link ColumnFilter.callback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * `ds` - Provider 컨트롤
 *
 * `dataRow` - 행의 인덱스
 *
 * `level` - 수준
 *
 * `field` - 필드명
 *
 * `filter` - {@link ColumnFilter} 객체
 *
 * `value` - 값
 *
 * [반환값] - 필터링 결정 여부
 *
 * @example
 * ```js
 * const f = function(ds, dataRow, level, field, filter, value) {
 *      let res = isMatched(value, filter.criteria);
 *      return res;
 * }
 * ```
 */
declare type FilterCallback = (ds: DataSource, dataRow: number, level: number, field: number, filter: ColumnFilter, value: any) => boolean;
/**
 * 컬럼 필터
 * @internal
 */
declare class ColumnFilter extends EventAware {
    static readonly CHANGED = "onColumnFilterChanged";
    private _name;
    private _criteria;
    private _callback;
    private _text;
    private _description;
    private _active;
    private _visible;
    private _tag;
    private _level;
    private _category;
    constructor(criteria: string);
    protected _doDispose(): void;
    /** name */
    get name(): string;
    set name(value: string);
    /** criteria */
    get criteria(): string;
    set criteria(value: string);
    /** callback */
    get callback(): FilterCallback;
    set callback(value: FilterCallback);
    /** text */
    get text(): string;
    set text(value: string);
    /** description */
    get description(): string;
    set description(value: string);
    /** active */
    get active(): boolean;
    set active(value: boolean);
    /** visible */
    get visible(): boolean;
    set visible(value: boolean);
    /** tag */
    get tag(): any;
    set tag(value: any);
    /** @internal */
    get category(): ColumnFilterCategory;
    set category(value: ColumnFilterCategory);
    /** @internal */
    get level(): number;
    set level(value: number);
    toString(): string;
    protected changed(): void;
    protected criteriaChanged(): void;
    protected callbackChanged(): void;
}
/** @internal */
declare class ColumnFilterCategory extends ColumnFilter {
    private _childs;
    get active(): boolean;
    set active(value: boolean);
    get count(): number;
    get activeState(): ActiveState;
    constructor();
    protected _doDispose(): void;
    clear(): void;
    add(collection: ColumnFilterCollection, name: string, text: string, criteria: string, active: boolean): ColumnFilter;
    addChild(child: ColumnFilter): void;
    getChild(index: number): ColumnFilter;
}
/** @internal */
declare class ColumnFilterRun {
    private _model;
    private _exprNode;
    constructor(model: ColumnFilter);
    protected _doDispose(): void;
    /** filter */
    get model(): ColumnFilter;
    prepare(runtime: ColumnFilterRuntime, dataSource: DataSource): void;
    select(runtime: ColumnFilterRuntime, parent: GroupItem, item: GridItem, field: number): boolean;
    protected criteriaChanged(): void;
    parse(): void;
}
/** @internal */
declare class ColumnFilterCollection extends EventAware {
    private _owner;
    private _items;
    private _names;
    private _updating;
    private _nextId;
    constructor(owner: DataColumn);
    protected _doDispose(): void;
    /** count */
    get count(): number;
    /** activeCount */
    get activeCount(): number;
    /** items */
    get items(): ColumnFilter[];
    /** visible */
    get isVisible(): boolean;
    getOwner(): any;
    getItem(index: number): ColumnFilter;
    itemByName(name: string): ColumnFilter;
    indexOf(name: string): number;
    getActiveItems(active: boolean): ColumnFilter[];
    assignFrom(source: any): void;
    clear(fireEvent?: boolean): boolean;
    add(filter: ColumnFilter | ConfigObject, apply?: boolean): void;
    addAll(filters: (ColumnFilter | ConfigObject)[], overwrite: boolean): void;
    remove(filterName: string): boolean;
    removeItems(filterNames: string[]): void;
    activateItems(filterNames: string[], active: boolean, apply?: boolean): void;
    activateAll(active: boolean): void;
    hideFilters(filterNames: string[], hide: boolean): void;
    hideAllFilters(hide: boolean): void;
    toggleItems(filterNames: string[]): void;
    toggleAll(): void;
    private changed;
    private $_checkName;
    private $_userFilterAdd;
    onColumnFilterChanged(filter: ColumnFilter): void;
    onColumnFilterSelectorChanged(): void;
    onColumnFilterUserAdd(selector: any, filter: ColumnFilter, apply: boolean): void;
}
/** @internal */
declare class ColumnFilterRuntime extends ExpressionRuntime {
    private static readonly ID_VALUE;
    private static readonly ID_FIELD;
    private static readonly ID_VALUES;
    private static readonly ID_STATE;
    private static readonly ID_CHANGED_CELL;
    private static readonly ID_MAX;
    private static readonly ID_MIN;
    private static readonly ID_MEAN;
    private static readonly IDENTS;
    private _item;
    private _field;
    private _ds;
    private _fieldCount;
    constructor();
    protected _doDispose(): void;
    setDataSource(ds: DataSource): void;
    setData(item: GridItem, field: number): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
}

/**
 * @internal
 */
declare abstract class ColumnObject extends GridObject {
    private _column;
    private _template;
    private _values;
    private _popupMenu;
    private _popupMenuName;
    constructor(column: GridColumn);
    protected _doDispose(): void;
    /** 해당 컬럼 */
    get column(): GridColumn;
    /** 적용되어 표시될 html 템플릿 */
    get template(): string;
    set template(value: string);
    /** 값들 */
    get values(): ConfigObject;
    set values(value: ConfigObject);
    /** 팝업 메뉴 */
    get popupMenu(): ConfigObject[];
    set popupMenu(value: ConfigObject[]);
    /** 팝업 메뉴의 이름 */
    get popupMenuName(): string;
    set popupMenuName(value: string);
    getValue(key: string): any;
    setValue(key: string, value: any): void;
}
/**
 * @internal
 */
declare class ColumnSummaryStyle implements ColumnSummaryStyleObject {
    styleName: string;
    exportStyleName: string;
    textFormat: string;
    datetimeFormat: string;
    numberFormat: string;
    booleanFormat: string;
    prefix: string;
    suffix: string;
    clear(): ColumnSummaryStyle;
    assign(source: any): ColumnSummaryStyle;
}
/**
 * @internal
 */
declare type ColumnSummaryCallback = (grid: any, column: any, footerIndex: number, summary: ColumnSummary, value: any) => void;
/**
 * @internal
 */
declare type ColumnGroupSummaryCallback = (grid: any, column: any, footerIndex: number, model: any, value: any) => void;
/**
 * @internal
 */
declare type ColumnObjectCallback = (fieldName: string, dataRow: number, value: any) => any;
/**
 * @internal
 */
declare abstract class ColumnSummary extends ColumnObject {
    private _valueCallback;
    private _text;
    private _expression;
    private _styleName;
    private _exportStyleName;
    private _styleCallback;
    private _numberFormat;
    private _datetimeFormat;
    private _booleanFormat;
    private _textFormat;
    private _prefix;
    private _suffix;
    private _index;
    private _exprNode;
    private _textFormatter;
    private _numberFormatter;
    private _datetimeWriter;
    private _boolFormatter;
    protected $_owner: ColumnSummaryCollection;
    constructor(column: GridColumn);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 인덱스
     */
    get index(): number;
    /**
     * @alpha
     */
    get valueCallback(): ColumnSummaryCallback | ColumnGroupSummaryCallback;
    set valueCallback(value: ColumnSummaryCallback | ColumnGroupSummaryCallback);
    /**
     * 텍스트
     */
    get text(): string;
    set text(value: string);
    /**
     * 정규표현식
     */
    get expression(): string;
    set expression(value: string);
    /**
     * 스타일 클래스 명
     */
    get styleName(): string;
    set styleName(value: string);
    /** export시 사용될 style class 명 */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    /**
     * 스타일을 지정하기 위한 콜백
     *
     * @eventProperty
     */
    get styleCallback(): CellStyleCallback;
    set styleCallback(value: CellStyleCallback);
    /**
     * 숫자 형식의 값일 때 표시되는 서식
     */
    get numberFormat(): string;
    set numberFormat(value: string);
    /**
     * 날짜 형식의 값일 때 표시되는 서식
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * Boolean 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * 텍스트 형식의 값일 때 표시되는 편집기의 서식
     */
    get textFormat(): string;
    set textFormat(value: string);
    /**
     * 앞에 추가 될 텍스트
     */
    get prefix(): string;
    set prefix(value: string);
    /**
     * 뒤에 추가 될 텍스트
     */
    get suffix(): string;
    set suffix(value: string);
    /**
     * @internal
     */
    get textFormatter(): TextFormatter;
    /**
     * @internal
     */
    get numberFormatter(): DecimalFormatter;
    /**
     * @internal
     */
    get datetimeWriter(): DateTimeWriter;
    /**
     * @internal
     */
    get boolFormatter(): BooleanFormatter;
    /**
     * @internal
     */
    evaluate(runtime: ExpressionRuntime, index?: number): any;
    /**
     * @internal
     */
    realizeSummary(cell: SummaryCell, cf: CellFormatter): string;
    /**
     * @internal
     */
    realizeGroupSummary(cell: RowGroupFooterCell, cf: CellFormatter): string;
    /**
     * @internal
     */
    protected doAssignSimple(src: any): boolean;
    /**
     * @internal
     */
    protected _doChanged(): void;
}
/**
 * @internal
 */
declare abstract class ColumnSummaryCollection extends Base {
    protected _column: GridColumn;
    protected _items: ColumnSummary[];
    protected _type: SummaryItemType;
    constructor(column: GridColumn, summaryType: SummaryItemType);
    protected _doDispose(): void;
    /**
     * 해당 컬럼
     */
    get column(): GridColumn;
    /**
     * Summary 개수
     */
    get count(): number;
    get type(): SummaryItemType;
    /**
     */
    get(index: number): ColumnSummary;
    /**
     */
    assignFrom(source: any): void;
    protected abstract $_createSummary(): ColumnSummary;
}
/**
 * @internal
 */
declare class ColumnHeaderSummary extends ColumnSummary {
    constructor(owner: ColumnSummaryCollection);
    /**
     * @internal
     */
    protected _doChanged(): void;
}
/**
 * @internal
 */
declare class ColumnHeaderSummaryCollection extends ColumnSummaryCollection {
    constructor(column: GridColumn, type: SummaryItemType);
    protected $_createSummary(): ColumnHeaderSummary;
}
/**
 * @internal
 */
declare class ColumnHeader extends ColumnObject {
    private _text;
    private _itemOffset;
    private _itemGap;
    private _checkLocation;
    private _showTooltip;
    private _tooltip;
    private _styleName;
    private _exportStyleName;
    private _edgeMark;
    constructor(column: GridColumn);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 컬럼 헤더에 표시될 문자열
     */
    get text(): string;
    set text(value: string);
    /**
     * 이미지나 체크박스와 셀 경계와의 공백
     */
    get itemOffset(): number;
    set itemOffset(value: number);
    /**
     * 헤더 문자열과 이미지나 체크박스와의 간격
     */
    get itemGap(): number;
    set itemGap(value: number);
    /**
     * 헤더 문자열을 기준으로한 체크박스의 위치
     */
    get checkLocation(): ColumnHeaderItemLocation;
    set checkLocation(value: ColumnHeaderItemLocation);
    /**
     * 툴팁 표시 여부
     */
    get showTooltip(): boolean;
    set showTooltip(value: boolean);
    /**
     * 표시할 툴팁 메시지
     */
    get tooltip(): string;
    set tooltip(value: string);
    /**
     *
     * edgeMark 표시여부
     *
     * @remarks
     * Header에 강조 표시를 할때 사용한다.
     */
    get edgeMark(): EdgeMark;
    set edgeMark(value: EdgeMark);
    /**
     * 디스플레이 텍스트
     */
    get displayText(): string;
    /**
     * 스타일 클래스 이름
     */
    get styleName(): string;
    set styleName(value: string);
    /** export시 사용될 styleName */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    /**
     * @internal
     */
    realizeTemplate(): string;
    /**
     * @internal
     */
    _doChanged(): void;
    /**
     * @internal
     */
    protected doAssignSimple(value: any): boolean;
}
/**
 * @internal
 */
declare class ColumnFooter extends ColumnSummary {
    constructor(owner: ColumnSummaryCollection);
    /**
     * @internal
     */
    protected _doChanged(): void;
}
/**
 * @internal
 */
declare class ColumnFooterCollection extends ColumnSummaryCollection {
    constructor(column: GridColumn, summaryType: SummaryItemType);
    protected $_createSummary(): ColumnSummary;
}
/**
 * @internal
 */
declare class ColumnStyle implements ColumnStyleObject {
    styleName: string;
    exportStyleName: string;
    renderer: any;
    editable: boolean;
    readOnly: boolean;
    editor: any;
    textFormat: string;
    datetimeFormat: string;
    numberFormat: string;
    booleanFormat: string;
    prefix: string;
    suffix: string;
    edgeMark: EdgeMark;
    style: ConfigObject;
    excelFormat: string;
    cellProtectProps: CellProtectProperties;
    clear(): ColumnStyle;
    assign(source: any): ColumnStyle;
    toFormatter(cf: CellFormatter): CellFormatter;
}
/**
 * @internal
 */
declare abstract class GridColumn extends Base {
    private _name;
    private _visible;
    private _width;
    private _resizable;
    private _movable;
    private _checked;
    private _tag;
    private _fillWidth;
    private _header;
    private _footers;
    private _headerSummaries;
    private _groupFooters;
    private _dirty;
    private _index;
    private _states;
    private _layout;
    private $_owner;
    constructor(config?: ConfigObject);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 컬럼 이름
     */
    get name(): string;
    set name(value: string);
    /**
     * @internal
     */
    protected _layoutChanged(): void;
    /**
     * 컬럼 표시 여부
     *
     * @remarks
     * `false` 이면 연결된 layout의 visible이 `true` 여도 표시되지 않는다.
     * 즉, layout과 컬럼의 visible이 모두 `true` 여야 한다.
     */
    get visible(): boolean;
    set visible(value: boolean);
    /**
     * 컬럼 너비
     */
    get width(): number;
    set width(value: number);
    /**
     * 컬럼 그룹 내 너비
     *
     * @remarks
     * 비율로 지정된다.
     *
     * @defaultValue `NaN`
     */
    get fillWidth(): number;
    set fillWidth(value: number);
    /**
     * 컬럼 너비 조절 가능 여부
     */
    get resizable(): boolean;
    set resizable(value: boolean);
    /**
     * 컬럼 이동 가능 여부
     */
    get movable(): boolean;
    set movable(value: boolean);
    /**
     * 체크 여부
     */
    get checked(): boolean;
    set checked(value: boolean);
    /**
     * 컬럼 헤더
     */
    get header(): ColumnHeader;
    /**
     * @internal
     */
    setHeader(value: any): void;
    /**
     * 컬럼 푸터들, 컬렉션 오브젝트
     *
     */
    get footers(): ColumnFooterCollection;
    /**
     * @internal
     */
    setFooters(value: any[]): void;
    /**
     * 컬럼 푸터 (여러 개 있을 경우 첫 번째 아이템)
     */
    get footer(): ColumnFooter;
    /**
     * @internal
     */
    setFooter(value: any): void;
    /**
     * 헤더 Summary 들, 컬렉션 오브젝트.
     */
    get headerSummaries(): ColumnHeaderSummaryCollection;
    /**
     * @internal
     */
    setHeaderSummaries(value: any[]): void;
    /**
     * 헤더 Summary (여러 개일 경우 첫 번째 아이템)
     */
    get headerSummary(): ColumnHeaderSummary;
    /**
     * @internal
     */
    setHeaderSummary(value: any): void;
    /**
     * 그룹 푸터들, 컬렉션 오브젝트.
     */
    get groupFooters(): ColumnFooterCollection;
    /**
     * @internal
     */
    setGroupFooters(value: any[]): void;
    /**
     * 그룹 푸터 (여러 개일 경우 첫번째 아이템)
     */
    get groupFooter(): ColumnFooter;
    /**
     * @internal
     */
    setGroupFooter(value: any): void;
    /**
     * 그리드
     * @readonly
     */
    get grid(): GridBase$1;
    /**
     * 태그
     */
    get tag(): any;
    set tag(value: any);
    /**
     * 순서
     * @readonly
     */
    get index(): number;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 텍스트
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    get displayText(): string;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 너비
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    get displayWidth(): number;
    /**
     * 컬럼이 속한 컬럼그룹내에서 컬럼의 표시 순서를 나타낸다.
     * @remarks
     * 읽기만 가능한 값이다.
     * @readonly
     */
    get displayIndex(): number;
    /**
     * @internal
     */
    get dataRoot(): GridColumn;
    /**
     * 레이아웃 아이템 객체
     *
     * @remarks
     * 속성으로 접근하여 설정할 수 있다.
     *
     * @example
     * ```js
     * column.layout.spanCallback = function (grid, layout, itemIndex) {
     *     var value = grid.getValue(itemIndex, layout.column.name);
     *     if (value) {
     *         return value[0] === "B" ? 2 : value[0] === "F" ? 3 : 1;
     *     }
     * };
     * ```
     */
    get layout(): CellLayoutColumnItem;
    /**
     * @internal
     */
    clean(): void;
    /**
     * @internal
     */
    isWritable(): boolean;
    /**
     * @internal
     */
    stateFor(state: string): any;
    /**
     * @internal
     */
    setState(state: string, value: any): void;
    /**
     * @internal
     * @param index -
     */
    getFooter(index: number): ColumnFooter;
    /**
     * @internal
     * @param index -
     */
    getHeaderSummary(index: number): ColumnHeaderSummary;
    /**
     * @internal
     */
    assignFrom(source: ConfigObject): void;
    /**
     * @internal
     */
    toString(): string;
    /**
     * @internal
     */
    protected _prepareLayout(grid: GridBase$1, layout: CellLayoutColumnItem): void;
    /**
     * @internal
     */
    protected _changed(): void;
    /**
     * @internal
     */
    protected _propChanged(prop: string, value: any, oldValue: any): void;
    /**
     * @internal
     */
    private $_setIndex;
    /**
     * @internal
     */
    protected _headerChanged(): void;
    /**
     * @internal
     */
    protected _headerSummaryChanged(): void;
    /**
     * @internal
     */
    protected _footerChanged(): void;
    /**
     * @internal
     */
    protected _resetIndices(grid: GridBase$1): void;
    private $_layoutIndexChanged;
    private $_layoutWidthChanged;
}
/**
 * @internal
 * 동적 셀 스타일 변경을 위한 콜백
 */
declare type CellStyleCallback = (grid: GridBase$1, model: GridCell) => string | ColumnStyleObject | ColumnSummaryStyleObject;
/**
 * @internal
 */
declare type ButtonVisibleCallback = (grid: GridBase$1, index: any, focused: boolean, mouseEntered: boolean) => boolean;
/**
 * @internal
 */
declare class ValueColumn extends GridColumn {
    private _textFormat;
    private _numberFormat;
    private _datetimeFormat;
    private _booleanFormat;
    private _prefix;
    private _suffix;
    private _blankWhenCopy;
    private _blankWhenExport;
    private _ignoreDefaultDynamicStyles;
    private _textInputCase;
    private _styleName;
    private _exportStyleName;
    private _styleCallback;
    private _renderer;
    private _editor;
    private _button;
    private _buttonVisibility;
    private _editButtonVisibility;
    private _buttonVisibleCallback;
    private _displayMinusZero;
    private _popupMenu;
    private _popupMenuName;
    private _edgeMark;
    private _textFormatter;
    private _numberFormatter;
    private _datetimeWriter;
    private _boolFormatter;
    constructor(config?: ConfigObject);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 컬럼에 지정되어 있는 숫자 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    get numberFormat(): string;
    set numberFormat(value: string);
    /**
     * -0.00 처럼 표시되는것을 0.00 으로 표시 여부
     *
     * @defaultValue `true`
     */
    get displayMinusZero(): boolean;
    set displayMinusZero(value: boolean);
    /**
     * 컬럼에 지정되어 있는 날짜 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 예) `'yy-M-dd'`
     *
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * 컬럼에 지정되어 있는 Boolean 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * 텍스트 형식의 값일 때 표시되는 서식
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    get textFormat(): string;
    set textFormat(value: string);
    /**
     * 앞에 추가 될 텍스트
     *
     * @remarks
     * 데이터를 표시할 때 지정한 앞에 추가 될 텍스트를 값의 앞에 붙여 표시한다.
     */
    get prefix(): string;
    set prefix(value: string);
    /**
     * 뒤에 추가 될 텍스트
     *
     * @remarks
     * 데이터를 표시할 때 지정한 뒤에 추가 될 텍스트를 값의 뒤에 붙여 표시한다.
     */
    get suffix(): string;
    set suffix(value: string);
    /**
     * 클립 보드에 복사 시 빈 값을 넘겨줄지의 여부
     *
     * @defaultValue `false`
     */
    get blankWhenCopy(): boolean;
    set blankWhenCopy(value: boolean);
    /**
     * Export 시 빈 값을 넘겨줄지의 여부
     *
     * @defaultValue `false`
     */
    get blankWhenExport(): boolean;
    set blankWhenExport(value: boolean);
    /**
     * ignoreDefaultDynamicStyles
     * @alpha
     */
    get ignoreDefaultDynamicStyles(): boolean;
    set ignoreDefaultDynamicStyles(value: boolean);
    /**
     * 편집기에 입력되는 값의 대소문자 변환 형태
     *
     * @defaultValue {@link TextInputCase.NORMAL}
     */
    get textInputCase(): TextInputCase;
    set textInputCase(value: TextInputCase);
    /**
     * 스타일 클래스 명
     */
    get styleName(): string;
    set styleName(value: string);
    /** exportStyleName */
    get exportStyleName(): string;
    set exportStyleName(value: string);
    /**
     * 스타일을 지정하기 위한 콜백
     *
     * @eventProperty
     *  @example
     * ```js
     * const f = function (grid, cell) {
     *      return {
     *          styleName: 'custom-cell'
     *          editor: 'text'
     *      }
     * }
     * column.styleCallback = f;
     * ```
     */
    get styleCallback(): CellStyleCallback;
    set styleCallback(value: CellStyleCallback);
    /**
     * 렌더러
     *
     * @remarks
     * {@link CellRenderer} 참조
     */
    get renderer(): CellRenderer;
    set renderer(value: CellRenderer);
    /**
     * 편집기
     *
     * @remarks
     * {@link CellEditor} 참조
     */
    get editor(): CellEditor$1;
    set editor(value: CellEditor$1);
    /**
     * 데이터 셀 우측에 표시할 버튼
     *
     * @defaultValue {@link CellButton.NONE}
     *
     * ```js
     * column.button = 'popup';
     * ```
     */
    get button(): CellButton;
    set button(value: CellButton);
    /**
     * 컬럼 버튼의 표시 방법
     * @defaultValue {@link ButtonVisibility.DEFAULT}
     */
    get buttonVisibility(): ButtonVisibility;
    set buttonVisibility(value: ButtonVisibility);
    /**
     * @internal
     */
    get buttonVisibleCallback(): ButtonVisibleCallback;
    set buttonVisibleCallback(value: ButtonVisibleCallback);
    /**
     * @internal
     */
    get editButtonVisibility(): ButtonVisibility;
    set editButtonVisibility(value: ButtonVisibility);
    /**
     * @internal
     * textFormatter
     */
    get textFormatter(): TextFormatter;
    /**
     * numberFormatter
     * @internal
     */
    get numberFormatter(): DecimalFormatter;
    /**
     * datetimeWriter
     * @internal
     */
    get datetimeWriter(): DateTimeWriter;
    /**
     * boolFormatter
     * @internal
     */
    get boolFormatter(): BooleanFormatter;
    /**
     * 팝업메뉴
     *
     * @remarks
     * 메뉴가 지정되면 데이터 셀 위로 마우스가 진입하거나 focus를 가질 때 메뉴 버튼이 활성화된다.
     * {@link MenuItem} 모델의 배열 형태다.
     */
    get popupMenu(): ConfigObject[];
    set popupMenu(value: ConfigObject[]);
    /**
     * 팝업메뉴 이름
     *
     * @remarks
     * {@link GridBase.addPopupMenu}로 등록한 메뉴를 컬럼의 팝업메뉴로 사용한다.
     */
    get popupMenuName(): string;
    set popupMenuName(value: string);
    /**
     *
     * edgeMark 표시여부
     *
     * @remarks
     * 셀에 강조 표시를 할때 사용한다.
     */
    get edgeMark(): EdgeMark;
    set edgeMark(value: EdgeMark);
    /**
     * @internal
     */
    getCellStyle(model: GridCell): string | object;
    /**
     * @internal
     */
    affix(s: string): string;
    /**
     * @internal
     */
    protected _prepareLayout(grid: GridBase$1, layout: CellLayoutColumnItem): void;
}
/**
* @internal
*/
declare type DisplayCallback = (grid: GridBase$1, index: CellIndex, value: any) => any;
/**
 * @internal
 */
declare class DataColumn extends ValueColumn {
    private static readonly CAPITAL_INDEXERS;
    private _fieldIndex;
    private _fieldName;
    private _editable;
    private _readOnly;
    private _nanText;
    private _zeroText;
    private _defaultValue;
    private _valueSeparator;
    private _mergeRule;
    private _breakMergeOnEmpty;
    private _equalBlank;
    private _equalBlankExpression;
    private _mergeEdit;
    private _excelFormat;
    private _excelFormulaStatement;
    private _cellProtectProps;
    private _values;
    private _labels;
    private _lookupDisplay;
    private _lookupSource;
    private _lookupKeyFields;
    private _lookupKeyFieldIds;
    private _textOfInvalid;
    private _displayCallback;
    private _placeHolder;
    private _placeHolderStyleName;
    private _mergeGrouped;
    private _sortable;
    private _sortOrder;
    private _sortDirection;
    private _sortByLabel;
    private _filterable;
    private _autoFilter;
    private _filters;
    private _autoFilters;
    private _lookupData;
    private _lookupSourceId;
    private _lookupMap;
    private _labelField;
    private _required;
    private _requiredMessage;
    private _requiredLevel;
    private _validations;
    private _groupable;
    private _objectKey;
    private _objectCallback;
    private _dataIndex;
    private _baseIndex;
    private _valueType;
    private _groupLevel;
    private _mergeRuleObj;
    private _equalBlankNode;
    private _excelFormulaExprStatement;
    private _labelFieldIndex;
    constructor(config?: ConfigObject);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 컬럼이 표시하는 필드의 인덱스
     *
     * @defaultValue `-1`
     */
    get fieldIndex(): number;
    set fieldIndex(value: number);
    /**
     * 컬럼이 표시하는 데이터 필드의 이름
     *
     * @remarks
     * 존재하지 않는 필드 이름을 지정하거나 지정하지 않으면 이 컬럼에 해당하는 셀은 아무것도 표시하지 않는다.
     */
    get fieldName(): string;
    set fieldName(value: string);
    /**
     * 편집 가능 여부
     *
     * @defaultValue `undefined`
     */
    get editable(): boolean;
    set editable(value: boolean);
    /**
     * 그리드 수준에서 데이터 셀의 값 수정 금지 여부
     *
     * @defaultValue `false`
     */
    get readOnly(): boolean;
    set readOnly(value: boolean);
    /**
     * 값이 `NaN` 일 경우 표시되는 텍스트
     */
    get nanText(): string;
    set nanText(value: string);
    /**
     * 값이 `0`일 때 표시되는 텍스트
     *
     * @remarks
     * dataType 이 숫자인 경우에만 가능
     */
    get zeroText(): string;
    set zeroText(value: string);
    /**
     * 초기값
     */
    get defaultValue(): any;
    set defaultValue(value: any);
    /**
     * 각 값을 구분하기 위한 구분자
     */
    get valueSeparator(): string;
    set valueSeparator(value: string);
    /**
     * 컬럼 머지 규칙
     *
     * @remarks
     * 컬럼에 속한 셀들을 묶어서 표시할 수 있다. criteria 속성에 이전 행의 셀과 병합할 것인 지를 판단할 수식을 설정한다.
     */
    get mergeRule(): string;
    set mergeRule(value: string);
    /**
     * 빈 셀일 때 머지 중단 여부
     *
     * @defaultValue `false`
     */
    get breakMergeOnEmpty(): boolean;
    set breakMergeOnEmpty(value: boolean);
    /**
     * 같은 컬럼의 이전 행의 셀과 값이 동일할때 셀의 묶음 여부
     *
     * @defaultValue `false`
     */
    get equalBlank(): boolean;
    set equalBlank(value: boolean);
    /**
     * {@link DataColumn.equalBlank | equalBlank } 가 `true`인 경우 같은 값으로 처리할 수식
     */
    get equalBlankExpression(): string;
    set equalBlankExpression(value: string);
    /**
     * mergeEdit
     * `true`이면 merge된 셀을 편집시 merge된 item을 모두 update한다.
     */
    get mergeEdit(): boolean;
    set mergeEdit(value: boolean);
    /**
     * 엑셀 export 시 출력되는 서식
     *
     * @remarks
     * 예) `excelFormat: "#,##0;[Red]-#,##0;-"`
     */
    get excelFormat(): string;
    set excelFormat(value: string);
    /**
     * 엑셀 export시 출력되는 수식
     *
     * @remarks
     * 예) `excelFormulaStatement: '${excelcolumn[‘컬럼1’]}${row} + ${excelcolumn[‘컬럼2’]}${row}'`
     */
    get excelFormulaStatement(): string;
    set excelFormulaStatement(value: string);
    /**
     * @internal
     */
    get excelFormulaExprStatement(): ExpressionStatement;
    /**
     * @internal
     */
    get dataIndex(): number;
    /**
     * @internal
     */
    get baseIndex(): number;
    /**
     * @internal
     */
    get valueType(): ValueType;
    /**
     * @internal
     */
    get groupLevel(): number;
    /**
     * 컬럼 셀에 실제 값의 목록
     *
     * @remarks
     * values 에 셀 값에 해당하는 항목이 없으면 셀 값이 그대로 표시된다.
     *
     * @defaultValue `null`
     */
    get values(): string[];
    set values(value: string[]);
    /**
     * 컬럼 셀에 표시될 값의 목록
     *
     * @remarks
     * values 에 셀 값에 해당하는 항목이 없으면 셀 값이 그대로 표시된다.
     *
     * @defaultValue `null`
     */
    get labels(): string[];
    set labels(value: string[]);
    /**
     * 컬럼 셀에 values 목록 중 셀의 값에 해당하는 위치에 있는 labels 항목의 값의 표시 여부
     */
    get lookupDisplay(): boolean;
    set lookupDisplay(value: boolean);
    /**
     * lookup source
     * @internal
     */
    get lookupSource(): any;
    /**
     * 등록한 lookup source 의 트리의 id
     */
    get lookupSourceId(): string;
    set lookupSourceId(value: string);
    /** lookupKeyFields */
    get lookupKeyFields(): string[];
    set lookupKeyFields(value: string[]);
    /**
     * lookupKeyFieldIds
     * @internal
     */
    get lookupKeyFieldIds(): number[];
    /**
     * 컬럼 셀에 표시될 값의 목록을 지정하는 필드
     *
     * @remarks
     * labelField 가 다른 필드로 지정되면, 해당 컬럼 셀에는 실제 값 대신 이 필드의 셀과 같은 행에 있는 labelField 의 값을 표시한다.
     * values, labels 속성보다 labelField 속성이 우선한다.
     */
    get labelField(): string;
    set labelField(value: string);
    /**
     * 셀 데이터가 lookup data 에 없는 상태일 때의 텍스트
     *
     * @remarks
     * 문자열을 지정하면 해당 문자열이 표시된다.
     */
    get textOfInvalid(): string;
    set textOfInvalid(value: string);
    /**
     * 셀 데이터가 없는 경우 표시되는 문자열
     *
     * @remarks
     * 데이터가 없는 경우 해당 문자열이 표시된다.
     */
    get placeHolder(): string;
    set placeHolder(value: string);
    /**
     * 셀 데이터가 없는 경우 적용되는 class명
     *
     * @defaultValue `rg-data-empty-cell`
     */
    get placeHolderStyleName(): string;
    set placeHolderStyleName(value: string);
    /**
     * @internal
     */
    get labelFieldIndex(): number;
    /**
     * 화면에 표시하는 값을 설정하기 위한 콜백
     * @eventProperty
     */
    get displayCallback(): DisplayCallback;
    set displayCallback(value: DisplayCallback);
    /**
     * @internal
     *
     * @defaultValue `false`
     */
    get mergeGrouped(): boolean;
    /**
     * 정렬 가능 여부
     */
    get sortable(): boolean;
    set sortable(value: boolean);
    /**
     * 정렬 순서
     *
     * @defaultValue `-1`
     */
    get sortOrder(): number;
    set sortOrder(value: number);
    /**
     * 정렬 방식
     */
    get sortDirection(): SortDirection;
    set sortDirection(value: SortDirection);
    /**
     * Label 기준으로 정렬 여부
     *
     * @defaultValue `false`
     */
    get sortByLabel(): boolean;
    set sortByLabel(value: boolean);
    /**
     * 필터링 가능 여부
     *
     * @defaultValue `true`
     */
    get filterable(): boolean;
    set filterable(value: boolean);
    /**
     * 자동 필터링 적용 여부
     *
     * @defaultValue `false`
     */
    get autoFilter(): boolean;
    set autoFilter(value: boolean);
    /**
     * 필터들
     *
     * @remarks
     * 반환할 때는 {@link ColumnFilterCollection} 모델만을 따르지만, 설정할 때는 {@link GridBase.setColumnFilters} 의 매개변수 형식과 동일하다.
     */
    get filters(): ColumnFilterCollection;
    set filters(value: ColumnFilterCollection);
    get autoFilters(): ColumnFilterCollection;
    /**
     * 필수 여부
     *
     * @defaultValue `false`
     */
    get required(): boolean;
    set required(value: boolean);
    /**
     * 검증 시 값이 요구될 때 발생하는 메시지
     */
    get requiredMessage(): string;
    set requiredMessage(value: string);
    /**
     * 검증 시 값이 요구될 때 표시될 레벨
     *
     * @defaultValue {@link ValidationLevel.ERROR}
     */
    get requiredLevel(): ValidationLevel;
    set requiredLevel(value: ValidationLevel);
    /**
     * 이 컬럼에 적용할 {@link EditValidation} 목록
     * @remarks
     * 반환할 때는 {@link EditValidationCollection} 모델을 따르지만, 설정할 때는 {@link GridBase.setValidations} 의 매개변수 형식과 동일하다.
     */
    get validations(): any | EditValidationCollection$1;
    set validations(value: any);
    /**
     * true로 지정하면 사용자가 컬럼 헤더를 마우스로 드래깅해서 그룹핑을 할 수 있다.
     *
     * @defaultValue `true`
     */
    get groupable(): boolean;
    set groupable(value: boolean);
    /**
     * field의 dataType이 `object`인 경우 화면에 보여주고자하는 `name`
     *
     * @remarks
     * objectKey가 지정되면 해당 `name`은 편집이 가능.
     *
     * @defaultValue `undefined`
     */
    get objectKey(): string;
    set objectKey(value: string);
    /**
     * @eventProperty
     * field의 dataType이 `object`인 경우 화면에 표시하는 값을 설정하기 위한 콜백
     *
     */
    get objectCallback(): ColumnObjectCallback;
    set objectCallback(value: ColumnObjectCallback);
    /**
     * header/export/feedback에 표시되는 text;
     */
    get displayText(): string;
    get lookupData(): ConfigObject;
    set lookupData(values: ConfigObject);
    get cellProtectProps(): CellProtectProperties;
    set cellProtectProps(value: CellProtectProperties);
    /**
     * @internal
     */
    getField(): DataField;
    /**
     * @internal
     */
    getLookupLabel(value: string): string;
    /**
     * @internal
     */
    getLookupIndex(value: any): number;
    /**
     * @internal
     */
    getLookupIndices(value: (string | string[])): any[];
    /**
     * @internal
     */
    getLookupValue(index: number): any;
    /**
     * @internal
     */
    getLookupValues(indices: number[]): any[];
    /**
     * @internal
     */
    getSourceValue(label: string): any;
    /**
     * @internal
     */
    getSourceValues(labels: (string | string[])): string;
    /**
     * @internal
     */
    private get $_filters();
    /**
     * @internal
     */
    clearFilters(): void;
    /**
     * @internal
     */
    addFilters(filters: (ColumnFilter | ConfigObject) | (ColumnFilter | ConfigObject)[], overwrite?: boolean): void;
    /**
     * @internal
     */
    removeFilters(filterNames: string | string[]): void;
    /**
     * @internal
     */
    activateFilters(filterNames: string | string[], active: boolean): void;
    /**
     * @internal
     */
    activateAllFilters(active: boolean): void;
    /**
     * @internal
     */
    hideColumnFilters(filterNames: string | string[], hide: boolean): void;
    /**
     * @internal
     */
    hideAllColumnFilters(hide: boolean): void;
    /**
     * @internal
     */
    toggleFilters(filterNames: string | string[]): void;
    toggleAllFilters(): void;
    getFilter(filterName: string): ColumnFilter;
    getActiveFilters(active: boolean): ColumnFilter[];
    get hasFilters(): boolean;
    isFiltered(): boolean;
    setFilters(value: (ColumnFilter | ConfigObject)[]): void;
    autoFilterRefresh(applyFilters: boolean): void;
    /**
     * @internal
     */
    onColumnFilterChanged(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    /**
     * @internal
     */
    protected _prepareLayout(grid: GridBase$1, layout: CellLayoutColumnItem): void;
    /**
     * @internal
     */
    protected _resetIndices(grid: GridBase$1): void;
    /**
     * @internal
     */
    isWritable(): boolean;
    /**
     * @internal
     */
    assignFrom(source: ConfigObject): void;
    private $_setMergeGrouped;
    private $_setGroupLevel;
    private $_resetLookup;
    /**
     * @internal
     */
    protected _changed(): void;
}

/**
 * @internal
 * 행들의 상태를 표시하는 상태바와 관련된 설정 모델
 */
declare class StateBar extends SectionObject implements StateBar$1 {
    private _width;
    private _mark;
    private _stateTexts;
    private _errorVisible;
    private _cell;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 너비
     *
     * @defaultValue `20`
     */
    get width(): number;
    set width(value: number);
    /**
     * 상태바에 표시되는 상태의 형태
     *
     * @defaultValue {@link StateMark.IMAGE}
     */
    get mark(): StateMark;
    set mark(value: StateMark);
    /**
     * 상태 바에 표시될 상태 텍스트들
     *
     * @remarks
     * 기본값들
     * `'C'`: stateTexts[RowState.CREATED]
     * `'U'`: stateTexts[RowState.UPDATED]
     * `'D'`: stateTexts[RowState.DELETED]
     * `'X'`: stateTexts[RowState.CREATE_AND_DELETED]
     */
    get stateTexts(): StateTexts;
    set stateTexts(value: StateTexts);
    /** errorVisible */
    get errorVisible(): boolean;
    set errorVisible(value: boolean);
    getCellType(): GridCellType;
    get staticOrder(): number;
    /**
     * @internal
     */
    getCell(index: CellIndex): GridCell;
    /**
     * @internal
     */
    getHeadStyleName(): string;
    /**
     * @internal
     */
    getFootStyleName(): string;
    /**
     * @internal
     */
    getSumStyleName(): string;
}

/**
 * @internal
 *
 * 그리드의 고정 행 및 컬럼 영역에 대한 설정 모델
 *
 * @remarks
 * 그리드 위쪽에 하나 이상의 행을 수직 스크롤링에서 제외할 수 있다.
 * 하나 이상의 최상위 컬럼을 수평 스크롤에서 제외할 수 있다.
 */
declare class FixedOptions extends GridBaseOptions implements FixedOptions$1 {
    static readonly ROW_BAR_STYLE = "rg-fixed-row-bar";
    static readonly ROW_BAR_CELL_STYLE = "rg-fixed-row-bar-cell";
    static readonly COLUMN_BAR_STYLE = "rg-fixed-column-bar";
    private _colCount;
    private _rightCount;
    private _rowCount;
    private _rightFixed;
    private _exceptFromFiltering;
    private _exceptFromSorting;
    private _editable;
    private _rowEditable;
    private _resizable;
    private _rowResizable;
    private _movable;
    private _colBarWidth;
    private _rightBarWidth;
    private _rowBarHeight;
    private _mergeRows;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 왼쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     */
    get colCount(): number;
    set colCount(value: number);
    /**
     * 오른쪽 고정 컬럼의 개수
     *
     * @remarks
     * 최상위 컬럼 단위로 지정
     *
     * @defaultValue `0`
     *
     */
    get rightCount(): number;
    set rightCount(value: number);
    /**
     * 위쪽 고정 행의 개수
     *
     * @defaultValue `0`
     *
     */
    get rowCount(): number;
    set rowCount(value: number);
    /**
     * 오른쪽 고정 컬럼의 위치
     *
     * @remarks
     * true일 경우 컨테이너 오른쪽에, false일 경우 맨 오른쪽 컬럼 뒤에 고정
     *
     * @defaultValue `true`
     */
    get rightFixed(): boolean;
    set rightFixed(value: boolean);
    /**
     * 고정 행의 필터링 불가 여부
     *
     * @defaultValue `true`
     */
    get exceptFromFiltering(): boolean;
    set exceptFromFiltering(value: boolean);
    /**
     * 고정 행의 정렬 불가 여부
     *
     * @defaultValue `true`
     */
    get exceptFromSorting(): boolean;
    set exceptFromSorting(value: boolean);
    /**
     * 고정 컬럼의 수정 가능 여부
     *
     * @remarks
     * false 시 다른 속성들과 상관 없이 고정된 컬럼을 수정 불가
     *
     * @defaultValue `true`
     */
    get editable(): boolean;
    set editable(value: boolean);
    /**
     * 고정 행의 수정 가능 여부
     *
     * @remarks
     * false 시 다른 속성들과 상관 없이 고정된 행을 수정 불가
     *
     * @defaultValue `true`
     */
    get rowEditable(): boolean;
    set rowEditable(value: boolean);
    /**
     * 고정 컬럼의 너비 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 너비를 변경 불가
     *
     * @defaultValue `false`
     */
    get resizable(): boolean;
    set resizable(value: boolean);
    /**
     * 고정 행의 높이 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 행의 높이를 변경 불가
     *
     * @defaultValue `false`
     */
    get rowResizable(): boolean;
    set rowResizable(value: boolean);
    /**
     * 고정 컬럼의 위치 변경 가능 여부
     *
     * @remarks
     * false시 다른 속성들과 상관 없이 사용자가 고정 컬럼의 위치를 변경할 수 없다.
     * 고정 컬럼 그룹에 포함된 컬럼들은 그룹 내에서 이동 가능하다.
     * 최상위 컬럼에만 해당된다.
     *
     * @defaultValue `false`
     */
    get movable(): boolean;
    set movable(value: boolean);
    /**
     * 왼쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    get colBarWidth(): number;
    set colBarWidth(value: number);
    /**
     * 오른쪽 고정 컬럼 구분 바의 너비
     *
     * @defaultValue `3`
     */
    get rightBarWidth(): number;
    set rightBarWidth(value: number);
    /**
     * 고정 행 구분 바의 높이
     *
     * @defaultValue `3`
     */
    get rowBarHeight(): number;
    set rowBarHeight(value: number);
    /**
     * 고정 행들을 컬럼 병합에 포함시킬 지 여부.
     *
     * @defaultValue false
     */
    get mergeRows(): boolean;
    set mergeRows(value: boolean);
    private $_resetItemSource;
}

/**
 * 헤더에 표시되는 summary에 대한 설정 모델
 * @internal
 */
declare class HeaderSummary extends GridSummaryObject {
    private static readonly CELL_CSS;
    constructor(grid: GridBase$1);
    /**
     * 인덱스
     */
    get summaryIndex(): number;
    /**
     * @internal
     */
    getCellStyleName(): string;
    /**
     * @internal
     */
    protected _createCell(): SummaryCell;
}
/** @internal */
declare class HeaderSummaryCollection extends SummaryCollection implements HeaderSummaryCollection$1 {
    constructor(grid: GridBase$1);
    protected _createSummary(grid?: GridBase$1): HeaderSummary;
}

/** @internal */
declare class SummaryTableCell extends TableCell {
    summaryIndex: number;
    rendererClass: string;
    style: ColumnSummaryStyle;
    numberFormatter: DecimalFormatter;
    datetimeWriter: DateTimeWriter;
    booleanFormatter: BooleanFormatter;
    textFormatter: TextFormatter;
    prefix: string;
    suffix: string;
    html: any;
    constructor(td: HTMLTableCellElement);
    dispose(): void;
    span(): void;
    clear(visible: boolean): SummaryTableCell;
    refreshFormatters(cs: ColumnSummaryStyle): void;
    setText(value: string): void;
    setHtml(value: string): void;
    setClassName(value: string): boolean;
    setRendererClassName(value: string): void;
}
/** @internal */
declare abstract class SummaryElement extends SimpleTableElement {
    protected _rowPoints: number[];
    protected _cells: SummaryTableCell[][];
    constructor(doc: Document, model: VisualObject, name: string);
    protected _doDispose(): void;
    tableCellByCell(cell: HTMLTableCellElement): SummaryTableCell;
    layoutByCell(cell: HTMLTableCellElement): CellLayoutColumnItem;
    columnByCell(cell: HTMLTableCellElement): GridColumn;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    protected _doDrawCell(row: number, col: number, dom: HTMLTableCellElement): void;
    protected _doRender(dom: HTMLElement): void;
    protected _getFirstCell(lm: GridLayoutManager): number;
    protected _getLastCell(lm: GridLayoutManager): number;
    protected _getStartCell(lm: GridLayoutManager): number;
    protected _getEndCell(lm: GridLayoutManager): number;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected abstract _getRendererStyle(): string;
    protected abstract _getSummaryRows(lm: GridLayoutManager): number;
    protected abstract _getSummaryCount(lm: GridLayoutManager): number;
    protected abstract _getCollection(): GridFooterCollection | HeaderSummaryCollection;
    protected abstract _getSummaryHeight(heightMeasurer: GridMeasurer): number;
    protected abstract _getSummaryItem(layout: CellLayoutItem, index: number): ColumnSummary;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    private $_refreshHeadTitle;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _updateCell(grid: GridBase$1, summary: GridSummaryObject, model: GridCell, tcell: SummaryTableCell): void;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _refreshCells(lm: GridLayoutManager, summaryCount: number, summaryLayouts: CellLayoutItem[][], tbody: HTMLTableSectionElement): void;
    protected abstract _getSpanOf(layout: CellLayoutItem, index: number): number;
    protected abstract _getUserSpanOf(layout: CellLayoutItem, index: number): UserSpan;
    private $_refreshSpans;
    protected _doPrepareTableRow(lm: GridLayoutManager, index: number, tindex: number, tr: HTMLTableRowElement): void;
}

/**
 * @internal
 */
declare class FooterElement extends SummaryElement {
    constructor(doc: Document, model: GridFooterCollection);
    protected _doDispose(): void;
    _getCssSelector(): string;
    protected _getRendererStyle(): string;
    protected _getSummaryRows(lm: GridLayoutManager): number;
    protected _getCollection(): GridFooterCollection;
    protected _getSummaryHeight(heightMeasurer: GridMeasurer): number;
    protected _getSummaryCount(lm: GridLayoutManager): number;
    protected _getSpanOf(layout: CellLayoutItem, index: number): number;
    protected _getUserSpanOf(layout: CellLayoutItem, index: number): UserSpan;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected _getSummaryItem(layout: CellLayoutItem, index: number): ColumnSummary;
}

declare enum ScrollEventType {
    LINE = "line",
    PAGE = "page",
    THUMB_TRACK = "thumbTrack",
    THUMB_END = "thumbEnd",
    SCROLL_END = "scrollEnd"
}
/** @internal */
declare class ScrollBar extends VisualElement {
    static readonly SCROLLED = "onScrollBarScrolled";
    private _lineScrollSize;
    private _pageScrollSize;
    private _minThumbSize;
    private _container;
    private _vertical;
    private _track;
    private _thumb;
    private _nearButton;
    private _farButton;
    private _min;
    private _max;
    private _pos;
    private _page;
    private _maxPosition;
    private _buttonSize;
    private _needLayout;
    private _tipView;
    constructor(container: VisualContainer, vertical?: boolean);
    protected _doDispose(): void;
    /** container */
    get container(): VisualContainer;
    /** lineScrollSize */
    get lineScrollSize(): number;
    set lineScrollSize(value: number);
    /** pageScrollSize */
    get pageScrollSize(): number;
    set pageScrollSize(value: number);
    /** minThumbSize */
    get minThumbSize(): number;
    set minThumbSize(value: number);
    /** vertical */
    get vertical(): boolean;
    /** pos */
    get pos(): number;
    /** maxPosition */
    get maxPosition(): number;
    /** buttonSize */
    get buttonSize(): number;
    /** tipView */
    set tipView(value: ScrollTipView);
    layoutContent(): void;
    setProperties(min: number, max: number, page: number): void;
    setPosition(value: number, layout?: boolean): void;
    ptInTrack(x: number, y: number, far: boolean): boolean;
    setText(text: string): void;
    _getCssSelector(): string;
    draw(): void;
    protected _doDraw(dom: HTMLElement): void;
    protected _doSizeChanged(): void;
    invalidateLayout(): void;
    private _doLayoutContent;
    private _doScroll;
}
/** @internal */
declare class ScrollTipView extends Base {
    private _container;
    private _element;
    constructor(container: VisualContainer);
    protected _doDispose(): void;
    show(): void;
    hide(): void;
    move(x: number, y: number): void;
    setText(text: string): void;
    width(): number;
    height(): number;
    getRect(): any;
    $_createElement(doc: Document): HTMLDivElement;
}

/**
 * @internal
 * Chromium 계열의 zoom 상태에서 grid.headerView의 아래쪽과 맞추기 위해
 * table row 수를 headerView와 동일하게 생성한다.
 */
declare class GridHeadElement extends SimpleTableElement {
    private static readonly CELL_CSS;
    private _indicatorCell;
    private _stateCell;
    private _checkCell;
    private _cells;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    get allChecked(): boolean;
    set allChecked(value: boolean);
    getHeadModel(td: HTMLTableCellElement): SectionObject;
    getCellType(td: HTMLTableCellElement): GridCellType;
    _getCssSelector(): string;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doRender(dom: HTMLElement): void;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    protected _doPrepareTableRow(lm: GridLayoutManager, index: number, tIndex: number, tr: HTMLTableRowElement): void;
    private $_getCellSelector;
}

/** @internal */
declare class GridFootElement extends SimpleTableElement {
    private static readonly CELL_CSS;
    private _cells;
    private _count;
    constructor(doc: Document);
    protected _doDispose(): void;
    getFootModel(td: HTMLTableCellElement): SectionObject;
    getCellType(td: HTMLTableCellElement): GridCellType;
    _getCssSelector(): string;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doRender(dom: HTMLElement): void;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    private $_getCellSelector;
}

/**
 * @internal
 *
 * 데이터 필드 값에 대한 변환 형식
 */
declare class FormatOptions extends GridBaseOptions implements FormatOptions$1 {
    private _textFormat;
    private _numberFormat;
    private _datetimeFormat;
    private _booleanFormat;
    private _textFormatter;
    private _datetimeWriter;
    private _numberFormatter;
    private _boolFormatter;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * 텍스트 포맷
     *
     * @remarks
     * 세미콜론(;)으로 구분하여 왼쪽에는 String.prototype.replace의 첫 번째 매개변수, 오른쪽에는 두 번째 매개변수와 같은 타입으로 지정
     * 예) `'([A-Za-z]*); Mr\. \$1'`
     *
     */
    get textFormat(): string;
    set textFormat(value: string);
    /**
     * 날짜 포맷
     *
     * @remarks
     * 예) `'yy-M-dd'`
     *
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * 숫자 포맷
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    get numberFormat(): string;
    set numberFormat(value: string);
    /**
     * Boolean 포맷
     *
     * @remarks
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     *
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * textFormmater
     * @internal
     */
    get textFormatter(): TextFormatter;
    /**
     * numberFormatter
     * @internal
     */
    get numberFormatter(): DecimalFormatter;
    /**
     * datetimeWriter
     * @internal
     */
    get datetimeWriter(): DateTimeWriter;
    /**
     * boolFormatter
     * @internal
     */
    get boolFormatter(): BooleanFormatter;
}

/**
 * 컬럼 정렬에 대한 설정 모델
 *
 * @remarks
 * {@link SortingOptions.style | style} 이 "exclusive"일 때 shift 키와 함께 컬럼 헤더를 클릭하면 "inclusive"처럼 동작한다.
 *
 * @internal
 */
declare class SortingOptions extends GridBaseOptions implements SortingOptions$1 {
    private _enabled;
    private _style;
    private _handleVisibility;
    private _commitBeforeSorting;
    private _toast;
    private _keepFocusedRow;
    private _textCase;
    private _showSortOrder;
    private _pageSorting;
    constructor(grid: GridBase$1);
    /**
     * @internal
     */
    _doDispose(): void;
    /**
     * 컬럼 헤더를 클릭으로 컬럼을 정렬 가능 여부
     *
     * @remarks
     * {@link GridBase.orderBy | orderBy()} 는 이 속성 값과 상관없이 실행된다.
     *
     * @defaultValue true
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    /**
     * 그리드에서 여러 컬럼에 대한 정렬 상태를 지정하는 방식
     *
     * @defaultValue {@link SortStyle.EXCLUSIVE}
     */
    get style(): SortStyle;
    set style(value: SortStyle);
    /**
     * 필터 핸들의 표시 방법
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    get handleVisibility(): HandleVisibility;
    set handleVisibility(value: HandleVisibility);
    /**
     * 정렬 전에 commit 할 건지의 여부
     *
     * @defaultValue {@link HandleVisibility.VISIBLE}
     */
    get commitBeforeSorting(): boolean;
    set commitBeforeSorting(value: boolean);
    /**
     * 정렬 시 현재 focus 된 행 유지 여부
     *
     * @defaultValue `false`
     */
    get keepFocusedRow(): boolean;
    set keepFocusedRow(value: boolean);
    /**
     * 대소문자 구분
     *
     * @defaultValue {@link SortCase.SENSITIVE}
     */
    get textCase(): SortCase;
    set textCase(value: SortCase);
    /**
     * 여러 컬럼을 정렬했을 때 정렬 순서 표시 여부
     *
     * @defaultValue `false`
     */
    get showSortOrder(): boolean;
    set showSortOrder(value: boolean);
    /**
     * 현재페이지 기준으로 정렬할 것인지의 여부
     *
     * @defaultValue `false`
     */
    get pageSorting(): boolean;
    set pageSorting(value: boolean);
    /**
     * toast 관련 설정
     *
     * @defaultValue `{visible: false, message: "Sorting..."}`
     */
    get toast(): ToastOptions$1;
}

/** @internal */
declare class AbortError extends Error {
    constructor(message: string);
}
/** @internal */
declare class ValidationError extends AbortError {
    level: ValidationLevel;
    column: GridColumn;
    userMessage: string;
    constructor(level: ValidationLevel, message: string, column?: GridColumn, userMessage?: string);
    toString(): string;
}
/**
 * 컬럼 단위 혹은, 행 단위 데이터 편집 검증 조건과 방식
 * @internal
 */
declare class EditValidation extends Base {
    static readonly CAPITAL_INDEXERS: string[];
    private _active;
    private _mode;
    private _level;
    private _criteria;
    private _message;
    private _description;
    private _name;
    private _exprNode;
    constructor(name?: string);
    /**
     * 이름
     *
     * @remarks
     * 검증 실패시 메시지나 description이 설정되지 않았을 경우 메시지로 사용된다.
     */
    get name(): string;
    /**
     * 검증 진행 여부
     */
    get active(): boolean;
    set active(value: boolean);
    /**
     * 검증 모드
     *
     * @remarks
     * Insert 시, Update 시, 혹은 두 경우 모두 실행한다.
     *
     * @defaultValue {@link ValidationMode.ALWAYS}
     */
    get mode(): ValidationMode;
    set mode(value: ValidationMode);
    /**
     * 검증 결과 수준
     *
     * @defaultValue {@link ValidationLevel.ERROR}
     */
    get level(): ValidationLevel;
    set level(value: ValidationLevel);
    /**
     * 검증식
     */
    get criteria(): string;
    set criteria(value: string);
    /**
     * 에러 메시지
     */
    get message(): string;
    set message(value: string);
    /**
     * 설명
     *
     * @remarks
     * 검증 실패시 메시지가 지정되지 않았을 경우 메시지로 사용된다.
     */
    get description(): string;
    set description(value: string);
    /**
     * @internal
     */
    validate(runtime: ExpressionRuntime): void;
    protected doAssignSimple(source: any): boolean;
}
/** @internal */
declare class EditValidationCollection extends Base implements EditValidationCollection$1 {
    private _items;
    private _isColumn;
    constructor(isColumn: boolean);
    _doDispose(): void;
    /** count */
    get count(): number;
    /** items */
    get items(): any | EditValidation[];
    set items(value: any);
    clear(): void;
    addAll(items: EditValidation[]): void;
    validate(mode: ValidationMode, runtime: ExpressionRuntime, checkLevel: boolean, commitLevel: ValidationLevel): void;
    assignFrom(source: any): void;
}
/** @internal */
declare class DataRowValidationRuntime extends ExpressionRuntime {
    private static readonly ID_ROW;
    private static readonly ID_DATAROW;
    private static readonly ID_CHECKED;
    private static readonly ID_VALUE;
    private static readonly ID_VALUES;
    private static readonly IDENTS;
    private _item;
    private _dataSource;
    private _fieldCount;
    constructor();
    protected _doDispose(): void;
    /** item */
    get item(): GridItem;
    set item(value: GridItem);
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
}
/** @internal */
declare class DataCellValidationRuntime extends ExpressionRuntime {
    private static readonly ID_VALUE;
    private static readonly ID_ROW;
    private static readonly ID_DATAROW;
    private static readonly ID_INDEX;
    private static readonly ID_FIELD;
    private static readonly ID_CHECKED;
    private static readonly ID_TAG;
    private static readonly ID_BASE;
    private static readonly ID_VALUES;
    private static readonly IDENTS;
    private _index;
    private _dataSource;
    private _value;
    constructor();
    protected _doDispose(): void;
    setIndex(value: CellIndex): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
}
/** @internal */
declare class ValidationManager extends Base {
    private _owner;
    private _cellList;
    constructor(owner: GridBase$1);
    /** owner */
    get owner(): GridBase$1;
    /** cellList */
    get cellList(): {};
    validateCell(index: CellIndex, inserting: boolean, paste: boolean): void;
    validateRow(item: GridItem, inserting: boolean, rowOnly: boolean, paste: boolean): void;
    clearInvalidCells(dataId?: number): void;
    clearInvalidCell(index: CellIndex): void;
    getError(index: CellIndex): ValidationError;
    cloneError(dataId: number, targetId: number): void;
    addInvalidateCell(index: CellIndex, err: any): void;
    getInvalidCells(): {};
    validateCells(itemIndices: number[] | number, visibleOnly?: boolean, ignorePaging?: boolean): {};
    clearInvalidateList(): void;
    checkRowIds(): void;
    private $_validateCell;
    private $_addInvalidateCell;
    private $_clearInvalidateCell;
    private $_clearInvalidateList;
}

/** @internal */
declare abstract class LookupSource$1 extends EventAware {
    static readonly CHANGED = "onLookupSourceChanged";
    private _id;
    constructor(id: string);
    /** id */
    get id(): any;
    exists(keys: (any | any[])): boolean;
    abstract clear(): void;
    abstract fill(keys: any[], values: any[]): void;
    abstract fillRows(rows: any[][]): void;
    abstract add(keys: (any | any[]), value: any): void;
    abstract addRow(row: any[]): void;
    abstract lookup(keys: (any | any[]), valueSeparator: string): string;
    abstract getDomain(keys: (any | any[])): any;
    abstract getTextDomain(keys: (any | any[])): any;
    protected _changed(): void;
}
/** @internal */
declare abstract class LookupSourceProvider extends EventAware {
    static readonly CHANGED = "onLookupSourceProviderChanged";
    constructor();
    abstract getSource(id: string): LookupSource$1;
    _changed(): void;
}
/** @internal */
declare class LocalLookupSourceProvider extends LookupSourceProvider {
    static readonly CHANGED = "onLookupSourceProviderChanged";
    _sources: any;
    constructor(config?: ConfigObject);
    dispose(): any;
    load(config: ConfigObject): void;
    add(config: ConfigObject): any;
    remove(id: string): void;
    getSource(id: string): LookupSource$1;
    private $_createSource;
    private $_add;
    private $_remove;
    onLookupSourceChanged(source: any): void;
}

/** @internal */
declare class HeaderSummaryElement extends SummaryElement {
    constructor(doc: Document, model: HeaderSummaryCollection);
    protected _doDispose(): void;
    _getCssSelector(): string;
    protected _getRendererStyle(): string;
    protected _getSummaryRows(lm: GridLayoutManager): number;
    protected _getCollection(): HeaderSummaryCollection;
    protected _getSummaryHeight(heightMeasurer: GridMeasurer): number;
    protected _getSummaryCount(lm: GridLayoutManager): number;
    protected _getSpanOf(layout: CellLayoutItem, index: number): number;
    protected _getUserSpanOf(layout: CellLayoutItem, index: number): UserSpan;
    protected _getSummaryItem(layout: CellLayoutItem, index: number): ColumnSummary;
    protected _getTableRowCount(lm: GridLayoutManager): number;
}

/**
 * @internal
 * Chromium 계열의 zoom 상태에서 grid.headerSummaryView의 아래쪽과 맞추기 위해
 * table row 수를 headerSummaryView와 동일하게 생성한다.
 */
declare class GridSumElement extends SimpleTableElement {
    private static readonly CELL_CSS;
    private _cells;
    private _count;
    constructor(doc: Document);
    protected _doDispose(): void;
    getSumModel(td: HTMLTableCellElement): SectionObject;
    getCellType(td: HTMLTableCellElement): GridCellType;
    _getCssSelector(): string;
    protected _doPrepareTableExtents(lm: GridLayoutManager): void;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doRender(dom: HTMLElement): void;
    protected _getTableRowCount(lm: GridLayoutManager): number;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    private $_getCellSelector;
}

/**
 * @internal
 */
declare class FilterSelector extends EventAware {
    static readonly INDEX_PADDING = 0;
    static readonly INDEX_EXPANDER = 1;
    static readonly INDEX_CHECKBOX = 2;
    static readonly INDEX_TEXT = 3;
    private _opened;
    private _gridContainer;
    private _options;
    private _soptions;
    private _filters;
    private _searched;
    private _applyBatch;
    private _allCheck;
    private _element;
    private _headerDiv;
    private _resetDiv;
    private _searchDiv;
    private _footerDiv;
    private _searchInput;
    private _confirmButton;
    private _cancelButton;
    private _selectAllDiv;
    private _selectAllCheck;
    private _viewportDiv;
    private _listDiv;
    private _autoFiltering;
    private _manager;
    private _targetColumn;
    private _itemHeight;
    private _viewWidth;
    private _visibleCount;
    private _visibleAllCount;
    private _pageCount;
    private _items;
    private _roots;
    private _visibleItems;
    private _visbleItemMap;
    private _itemElements;
    private _dirties;
    private _grid;
    get opened(): boolean;
    get column(): DataColumn;
    private get doc();
    constructor(container: GridContainer, options: FilteringOptions$1, grid: GridBase$1);
    protected _doDispose(): void;
    show(column: DataColumn, cell: HTMLTableCellElement, dataSource: DataSource): void;
    hide(): void;
    private _createItemInfo;
    private _build;
    private _finalize;
    private _buildSelectAllBox;
    private _buildReset;
    private _buildItems;
    private _buildSearchbox;
    private _buildFooter;
    private _buildItem;
    private _removeItem;
    private _buildItemElement;
    private _calculateState;
    private _calcluateStates;
    private _calcVisibleItems;
    private _setCheckState;
    private _calcAllChecked;
    private _redrawCheck;
    private _doRedraw;
    private _changeItemModel;
    private _doScroll;
    private _doSearch;
    private _resetActive;
    private _activateAll;
    private _doCheck;
    private _doFilterApply;
    private _doExpand;
    private _globalMouseDownHandler;
    private _globalKeyDownHandler;
    private _wheelHandler;
    private _scrollHandler;
    private _searchInputHandler;
    private _searchKeyDownHandler;
    private _resetClickHandler;
    private _checkAllClickHandler;
    private _itemClickHandler;
    private _confirmClickHandler;
    private _cancelClickHandler;
}

/**@internal */
declare class TooltipManager extends Base {
    private _container;
    private _tipView;
    private _active;
    private _pos;
    private _timer;
    private _grid;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** visible */
    get visible(): boolean;
    show(options: any, x: number, y: number, itemHeight: number, bHeader: boolean): boolean;
    close(x?: number, y?: number): boolean;
}

/** @internal */
declare abstract class RowBarElement extends VisualObjectElement {
    private _col;
    protected _colChanged: boolean;
    constructor(doc: Document, model: SectionObject, name: string);
    protected _doDispose(): void;
    getCellIndex(cell: HTMLTableCellElement): number;
    abstract measureWidth(grid: GridBase$1): number;
    protected _createDom(): any;
    protected _prepareContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _clearCellContent(elt: HTMLElement): void;
    protected _prepareCellContent(elt: HTMLElement, td: HTMLTableCellElement): void;
    protected _updateCellContent(grid: GridBase$1, model: GridCell, dom: HTMLElement, td: HTMLTableCellElement): void;
    protected _doRender(target: HTMLElement): void;
    private $_setCol;
    protected _layoutCell(grid: GridBase$1, index: CellIndex, td: HTMLTableCellElement): void;
    protected _getTableCell(row: number): HTMLTableCellElement;
    protected $_getCellSelector(td: HTMLTableCellElement, imaged?: boolean): string;
}

/** @internal */
declare class RowIndicatorElement extends RowBarElement {
    constructor(doc: Document, model: RowIndicator$1);
    protected _doDispose(): void;
    refresh(grid: GridBase$1, count: number): void;
    _getCssSelector(): string;
    measureWidth(grid: GridBase$1): number;
    protected _layoutCell(grid: GridBase$1, index: CellIndex, td: HTMLTableCellElement): void;
    protected $_getCellSelector(td: HTMLTableCellElement, imaged?: boolean): string;
}

/** @internal */
declare class StateBarElement extends RowBarElement {
    private _textMark;
    private _error;
    constructor(doc: Document, model: StateBar);
    rowOf(td: HTMLTableCellElement): number;
    _getCssSelector(): string;
    measureWidth(grid: GridBase$1): number;
    protected _layoutCell(grid: GridBase$1, index: CellIndex, td: HTMLTableCellElement): void;
    protected _updateCellContent(grid: GridBase$1, model: GridCell, dom: HTMLElement, td: HTMLTableCellElement): void;
    protected $_getCellSelector(td: HTMLTableDataCellElement, imageMark: boolean): string;
}

/** @internal */
declare class CheckBarElement extends RowBarElement {
    private static readonly FOR_ID;
    private static readonly CELL_CSS;
    private _fixedCount;
    private _prevChecked;
    private _exclusive;
    private _typeChanged;
    private _useImage;
    private _imageChanged;
    constructor(doc: Document, model: CheckBar$1);
    rowOf(td: HTMLTableCellElement): number;
    _getCssSelector(): string;
    protected _doPrepareContent(lm: GridLayoutManager): void;
    protected _clearCellContent(elt: HTMLElement): void;
    protected _prepareCellContent(elt: HTMLElement, td: HTMLTableCellElement): void;
    measureWidth(grid: GridBase$1): number;
    protected _layoutCell(grid: GridBase$1, index: CellIndex, td: HTMLTableCellElement): void;
    protected _updateCellContent(grid: GridBase$1, model: GridCell, dom: HTMLElement, td: HTMLTableCellElement): void;
    getCheckBox(td: HTMLTableCellElement): HTMLInputElement;
    protected $_getCellSelector(td: HTMLTableCellElement, imaged?: boolean): string;
    private $_setPrevChecked;
}

/**
 * @internal
 * rowIndicator + stateBar + checkBar views.
 */
declare class RowBarContainer extends DataTableElement {
    private static readonly ROW_STYLE;
    private static readonly ALTERNATE_ROW_STYLE;
    private _indicatorView;
    private _stateView;
    private _checkView;
    private _bars;
    private _views;
    private _count;
    constructor(grid: GridBase$1);
    protected _doDispose(): void;
    /** rowIndicator */
    get rowIndicator(): RowIndicatorElement;
    /** stateBar */
    get stateBar(): StateBarElement;
    /** checkBar */
    get checkBar(): CheckBarElement;
    /** stateError */
    get stateError(): any;
    set stateError(value: any);
    getCellIndex(cell: HTMLTableCellElement): number;
    refresh(grid: GridBase$1): void;
    rowOf(td: HTMLTableCellElement): number;
    getCheckBox(td: HTMLTableCellElement): HTMLInputElement;
    getCellType(td: HTMLTableCellElement): GridCellType;
    isRowIndicator(td: HTMLTableCellElement): boolean;
    _getCssSelector(): string;
    protected _isFixedHeight(): boolean;
    protected _doPrepareContent(lm: GridLayoutManager): void;
    protected _prepareCellContent(cell: HTMLTableCellElement, index: number): HTMLElement;
    protected _getTableRowHeight(lm: GridLayoutManager, tr: number): number;
    protected _doMeasure(grid: GridBase$1, hintWidth: number, hintHeight: number): Size;
    protected _doLayoutContent(lm: GridLayoutManager): void;
    protected _doUpdateCellContent(grid: GridBase$1, model: GridCell, dom: HTMLElement): void;
    protected _doRender(target: HTMLElement): void;
    protected _getCellCount(lm: GridLayoutManager): number;
    protected _getCellWidth(lm: GridLayoutManager, col: number): number;
    private $_prepareBars;
    protected _layoutFixedBar(options: FixedOptions, index: number): void;
    private getStyleName;
}

/** @internal */
interface EditorLender {
    getEditItem(grid: GridBase$1): GridItem;
    getEditor(index: CellIndex): any;
    getEditBounds(editor: CellEditor, index: CellIndex): Rectangle;
    isEditing(): boolean;
    isItemEditing(): boolean;
    validateCellCommit(index: CellIndex, value: any): void;
    makeCellVisible(index: CellIndex): boolean;
    editCellCommit(index: CellIndex, oldValue: any, newValue: any): boolean;
    editorChange(editor: CellEditor, index: CellIndex, value: any): void;
    editorShow(index: CellIndex): void;
    editorHide(index: CellIndex): void;
    itemUpdateStarted(grid: GridBase$1, item: GridItem): void;
    itemAppendStarted(grid: GridBase$1, item: GridItem): void;
    itemInsertStarted(grid: GridBase$1, item: GridItem): void;
    itemCommited(grid: GridBase$1, item: GridItem): void;
    itemCanceled(grid: GridBase$1): void;
    itemInserted(grid: GridBase$1, item: GridItem): void;
    itemsChanged(grid: GridBase$1): void;
}
/**
 * @internal
 * [Css 제한]
 * 1. table row height를 지정해서는 안된다.
 * 2. 각 영역 object의 background는 반드시 지정하고, 반투명이면 안된다.
 */
declare abstract class GridBase$1 extends ViewLayer {
    static createColumn(source: ConfigObject): GridColumn;
    private _debugging;
    private _scrollBarWidth;
    private _scrollBarHeight;
    protected _filterRunning: boolean;
    private _editorLender;
    private _keepNullFocus;
    private _container;
    private _loading;
    private _dataLoad;
    private _userMode;
    private _userModeError;
    private _eventFrom;
    private _header;
    private _footers;
    private _headerSummaries;
    private _rowIndicator;
    private _stateBar;
    private _checkBar;
    private _body;
    private _gridObjects;
    private _rootElement;
    private _emptyView;
    private _debugView;
    private _topContentPane;
    private _leftContentPane;
    private _sideContentPane;
    private _contentPane;
    private _fixedContentPane;
    private _rightContentPane;
    private _rowBarContainer;
    private _headView;
    private _sumView;
    private _footView;
    private _bodyView;
    private _fixedBodyView;
    private _rightBodyView;
    private _headerView;
    private _fixedHeaderView;
    private _rightHeaderView;
    private _headerSummaryView;
    private _fixedHeaderSummaryView;
    private _rightHeaderSummaryView;
    private _footerView;
    private _fixedFooterView;
    private _rightFooterView;
    protected _tableViews: {
        [key: string]: TableBaseElement;
    };
    private _selectionLayer;
    private _feedbackLayer;
    private _rowHoverView;
    private _hscrollBar;
    private _vscrollBar;
    private _scrollEdge;
    private _fixedOptions;
    private _displayOptions;
    private _formatOptions;
    private _editOptions;
    private _editorOptions;
    private _copyOptions;
    private _pasteOptions;
    private _dataDropOptions;
    private _sortingOptions;
    private _filteringOptions;
    private _mobileOptions;
    private _waiOptions;
    private _columns;
    private _columnMap;
    private _defaultCellLayout;
    private _activeCellLayout;
    private _columnLayouts;
    private _columnLock;
    private _columnsDirty;
    private _items;
    private _columnSummaryRuntime;
    private _columnValidationRuntime;
    private _rowValidationRuntime;
    private _layouted;
    private _resetting;
    private _needMerge;
    private _focusedIndex;
    private _leftPos;
    private _horzScrolled;
    private _topIndex;
    private _prevTop;
    private _prevLast;
    private _topIndexChanged;
    private _layoutManager;
    private _selections;
    private _updateLock;
    private _hoveredCell;
    private _hoveredY;
    private _focusing;
    private _dataChanged;
    private _delegate;
    private _editController;
    private _validations;
    private _validationManager;
    private $_editFocused;
    private $_showFocusCell;
    private _needSyncHeadCheck;
    private _updateRows;
    private _cellUpdateEventLock;
    private _lookupProvider;
    private _clipboardManager;
    private _progressManager;
    private _popupMenuManager;
    private _tooltipManager;
    private _contextMenu;
    private _filterSelector;
    private _toastManager;
    private _currentIndex;
    protected _currentRowId: number;
    private _currentRow;
    private _rowChangeTimer;
    private _setFocusTimer;
    private _scrolledTime;
    protected $_handler: any;
    private _cellLayoutDirty;
    private _editorIndex;
    private _scrollTipView;
    private _accessibility;
    constructor(container: GridContainer, accessibility: boolean, waiOptions: WaiOptions);
    protected _doDispose(): void;
    onCommandStackChanged: (grid: GridBase$1, undoable: boolean, redoable: boolean) => void;
    /** debugging */
    get debugging(): boolean;
    set debugging(value: boolean);
    /** activeTool */
    get activeTool(): GridTool;
    /** scrollBarWidth */
    get scrollBarWidth(): number;
    set scrollBarWidth(value: number);
    /** scrollBarHeight */
    get scrollBarHeight(): number;
    set scrollBarHeight(value: number);
    /** editorLender */
    get editorLender(): EditorLender;
    set editorLender(value: EditorLender);
    /** body */
    get body(): GridBody;
    /** header */
    get header(): GridHeader$1;
    /** footers */
    get footers(): GridFooterCollection;
    /** footer */
    get footer(): GridFooter;
    setFooters(source: any): void;
    /** headerSummaries */
    get headerSummaries(): HeaderSummaryCollection;
    /** headerSummary */
    get headerSummary(): HeaderSummary;
    setHeaderSummaries(source: any): void;
    /** indicator */
    get rowIndicator(): RowIndicator$1;
    /** checkBar */
    get checkBar(): CheckBar$1;
    /** stateBar */
    get stateBar(): StateBar;
    get activeCellLayout(): GridCellLayout;
    /** cellLayout */
    set cellLayout(value: ConfigObject[]);
    protected _cellLayoutChanged(): void;
    get layoutCount(): number;
    get visibleLayoutCount(): number;
    /** columnCount */
    get columnCount(): number;
    /** visibleColumnCount */
    /** dataSource */
    get dataSource(): DataSource;
    set dataSource(value: DataSource);
    /** itemSource */
    get itemSource(): ItemProvider;
    set itemSource(value: ItemProvider);
    /** maxItemCount */
    get maxItemCount(): number;
    set maxItemCount(value: number);
    /** itemCount */
    get itemCount(): number;
    /** rowCount */
    get rowCount(): number;
    /** visibleRowCount */
    get visibleRowCount(): number;
    /** dataCount */
    get dataCount(): number;
    /** columnSummaryRuntime */
    get columnSummaryRuntime(): ColumnSummaryRuntime;
    /** columnValidationRuntime */
    get columnValidationRuntime(): DataCellValidationRuntime;
    /** rowValidationRuntime */
    get rowValidationRuntime(): DataRowValidationRuntime;
    abstract get summarizer(): GridSummarizer;
    /** focusedIndex */
    get focusedIndex(): CellIndex;
    /** focusedLayout */
    get focusedLayout(): CellLayoutItem;
    /** focusedColumn */
    get focusedColumn(): GridColumn;
    /** focusedRow */
    get focusedRow(): number;
    /** focusedItem */
    get focusedItem(): GridItem;
    /** rowBarContainer */
    get rowBarContainer(): RowBarContainer;
    /** topContentPane */
    get topContentPane(): ContentPane;
    /** sideContentPane */
    get sideContentPane(): ContentPane;
    /** leftContentPane */
    get leftContentPane(): ContentPane;
    /** contentPane */
    get contentPane(): ContentPane;
    /** fixedContentPane */
    get fixedContentPane(): ContentPane;
    /** rightContentPane */
    get rightContentPane(): ContentPane;
    /** bodyView */
    get bodyView(): GridBodyElement;
    /** fixedBodyView */
    get fixedBodyView(): GridBodyElement;
    /** rightBodyView */
    get rightBodyView(): GridBodyElement;
    /** headerView */
    get headerView(): HeaderElement;
    /** fixedHeaderView */
    get fixedHeaderView(): HeaderElement;
    /** rightHeaderView */
    get rightHeaderView(): HeaderElement;
    /** headerSummaryView */
    get headerSummaryView(): HeaderSummaryElement;
    /** fixedHeaderSummaryView */
    get fixedHeaderSummaryView(): HeaderSummaryElement;
    /** rightHeaderSummaryView */
    get rightHeaderSummaryView(): HeaderSummaryElement;
    /** footerView */
    get footerView(): FooterElement;
    /** fixedFooterView */
    get fixedFooterView(): FooterElement;
    /** rightFooterView */
    get rightFooterView(): FooterElement;
    /** headView */
    get headView(): GridHeadElement;
    /** sumView */
    get sumView(): GridSumElement;
    /** footView */
    get footView(): GridFootElement;
    /** fixedOptions */
    get fixedOptions(): FixedOptions;
    /** displayOptions */
    get displayOptions(): DisplayOptions$1;
    /** formatOptions */
    get formatOptions(): FormatOptions;
    /** editOptions */
    get editOptions(): EditOptions;
    /** editorOptions */
    get editorOptions(): EditorOptions;
    /** copyOptions */
    get copyOptions(): CopyOptions;
    /** pasteOptions */
    get pasteOptions(): PasteOptions;
    /** dataDropOptions */
    get dataDropOptions(): DataDropOptions$1;
    /** sortingOptions */
    get sortingOptions(): SortingOptions;
    /** filteringOptions */
    get filteringOptions(): FilteringOptions$1;
    /** mobileOptions */
    get mobileOptions(): MobileOptions;
    get WaiOptions(): WaiOptions;
    get accessibility(): boolean;
    /** delegate */
    get delegate(): GridDelegate;
    /** heightMeasurer */
    get heightMeasurer(): GridMeasurer;
    /** layoutManager */
    get layoutManager(): GridLayoutManager;
    /** selections */
    get selections(): SelectionManager;
    /** selectionLayer */
    get selectionLayer(): SelectionLayer;
    /** editController */
    get editController(): EditController;
    /** validations */
    get validations(): any | EditValidationCollection;
    set validations(validations: any);
    /** validationManager */
    get validationManager(): ValidationManager;
    /** popupMenuManager */
    get popupMenuManager(): PopupMenuManager;
    /** popupMenuManager */
    get tooltipManager(): TooltipManager;
    /** toastManager */
    get toastManager(): ToastManager;
    /** topIndex */
    get topIndex(): number;
    set topIndex(value: number);
    /** topItem */
    get topItem(): number;
    /** leftPos */
    get leftPos(): number;
    set leftPos(value: number);
    /** leftCell */
    get leftCell(): number;
    set leftCell(value: number);
    /** leftLayout */
    get leftLayout(): number;
    set leftLayout(value: number);
    /** undoable */
    abstract get undoable(): boolean;
    abstract set undoable(value: boolean);
    /** undoing */
    abstract get undoing(): boolean;
    /** redoing */
    abstract get redoing(): boolean;
    /** LookupProvider */
    get lookupProvider(): LocalLookupSourceProvider;
    /** canHovering */
    get canHovering(): boolean;
    /** hoveredCell */
    get hoveredCell(): BodyTableCell;
    /** empty */
    get empty(): boolean;
    /** sorted */
    get sorted(): boolean;
    /** spanned */
    get spanned(): boolean;
    abstract isTree(): boolean;
    protected abstract _beforeChangeLayout(): any;
    addFeedbackElement(view: VisualElement): boolean;
    removeFeedbackElement(view: VisualElement): boolean;
    setEventFrom(value: EventFrom): void;
    getVisibleLayout(index: number): CellLayoutItem;
    getColumn(index: number): GridColumn;
    setColumns(columns: (GridColumn | ConfigObject)[]): void;
    protected _checkEditing(): void;
    addColumn(column: GridColumn | ConfigObject, index?: number): GridColumn;
    removeColumn(column: GridColumn | string): boolean;
    restoreColumns(restoreSize?: boolean): void;
    linearizeColumns(sortProps: string[]): void;
    registerColumnLayouts(source: ConfigObject[]): void;
    findColumnLayout(name: string): any;
    invalidateColumn(column: GridColumn): void;
    invalidateColumns(): void;
    beginUpdate(): void;
    endUpdate(force: boolean): void;
    invalidate(): void;
    invalidateLayout(): void;
    invalidateCellLayouts(): void;
    refreshView(force?: boolean): void;
    resetGrid(): void;
    getFirstCell(): CellIndex;
    private $_setEditFocused;
    getItem(index: number): GridItem;
    getItemIndexOfRow(dataRow: number): number;
    getItemOfRow(dataRow: number, force: boolean): GridItem;
    getItemIndicesOfRows(dataRows: number[]): number[];
    getRowOfItem(itemIndex: number): number;
    abstract getJsonRows(): object[];
    getItemOfModel(model: any): any;
    /**
     * @param all - true면 -1도 순서대로 포함.
     */
    getRowsOfItems(itemIndices: number[], all?: boolean): number[];
    getIndicatorIndex(item: GridItem): number;
    getAllItems(): GridItem[];
    getImage(imageUrl: string): HTMLImageElement;
    getIndex(itemIndex?: number, column?: GridColumn | CellLayoutItem): CellIndex;
    getDataCellIndex(cell: HTMLTableCellElement, index?: CellIndex): CellIndex;
    get handler(): any;
    getDataColumns(visibleOnly?: boolean): DataColumn[];
    optionsChanged(options: GridBaseOptions): void;
    scrollRow(delta: number): void;
    selectColumnFilters(cell: HeaderTableCell): void;
    closeFilterSelector(): void;
    closePopups(closeList?: boolean): void;
    layoutByDataCell(cell: HTMLTableCellElement): CellLayoutItem;
    columnByHash(hash: number): GridColumn;
    columnByDataCell(cell: HTMLTableCellElement): GridColumn;
    columnByName(name: string): GridColumn;
    columnByField(field: number | string): DataColumn;
    getHorzColumns(start?: number, count?: number): ValueColumn[];
    getGroupLevel(field: number): number;
    isGroupedColumn(column: DataColumn): boolean;
    layoutByColumn(column: GridColumn | string): CellLayoutColumnItem;
    layoutByName(name: string): CellLayoutItem;
    setFocus(target?: HTMLElement): void;
    getFirstLayout(): CellLayoutItem;
    getFirstColumn(): GridColumn;
    collectColumns(columnsOnly: boolean, visibleOnly: boolean, ordered: boolean): GridColumn[];
    collectColumnNames(columnsOnly: boolean, visibleOnly: boolean): string[];
    collectGroupNames(): string[];
    getChildColumnNames(p: string | CellLayoutGroupItem): string[];
    collectDataColumns(c1: CellLayoutItem, c2: CellLayoutItem): DataColumn[];
    isValid(index: CellIndex): boolean;
    getSelection(index?: number): SelectionItem;
    getSelections(): SelectionItem[];
    clearAddSelection(clear?: boolean, add?: boolean): void;
    deleteSelection(force?: boolean): void;
    private $_deleteSelection;
    revertSelection(force?: boolean): void;
    eraseSelection(): boolean;
    getSelectedItems(dataOnly?: boolean): GridItem[];
    getSelectedItemIndices(dataOnly?: boolean): number[];
    /**
     * 선택 영역에 포함된 데이터행들을 리턴한다.
     */
    getSelectedRows(): number[] | null;
    getSelectedLayouts(): CellLayoutItem[];
    setFocusedIndex(value: CellIndex, clearSelect?: boolean, focus?: boolean, focusSelect?: boolean): boolean;
    setFocusedItem(value: number | GridItem): void;
    resetFocusedIndex(): void;
    clearFocusedIndex(remainFocus?: boolean): void;
    getTableCell(dom: HTMLElement): HTMLTableCellElement;
    getTableView(cell: HTMLTableCellElement): TableBaseElement;
    getBodyViewAt(index: CellIndex): GridBodyElement;
    getBodyView(cell: HTMLTableCellElement): GridBodyElement;
    getRowView(bodyView: GridBodyElement, item: GridItem): GridElement;
    getHeaderView(cell: HTMLTableCellElement): HeaderElement;
    getFooterView(cell: HTMLTableCellElement): FooterElement;
    getSummaryView(cell: HTMLTableCellElement): HeaderSummaryElement;
    getCellType(cell: HTMLTableCellElement): GridCellType;
    protected _getCellTypeOf(view: TableBaseElement): GridCellType;
    getBodyCellAt(index: CellIndex, getHead?: boolean): BodyTableCell;
    getBodyCellbyCell(dom: HTMLElement): BodyTableCell;
    cellToIndex(dom: HTMLElement): CellIndex;
    cellToContainer(dom: HTMLTableCellElement, p?: Point): Point;
    pointToIndex(eventTarget: HTMLElement, x: number, y: number, clipped: boolean): CellIndex;
    getEditCellBounds(editor: CellEditor, index: CellIndex): Rectangle;
    getEditBounds(editor: CellEditor, index: CellIndex): Rectangle;
    getCellViewOf(dom: HTMLElement): HTMLTableCellElement;
    getFocusedCellView(index: CellIndex): HTMLTableCellElement;
    isFocusedCell(index: CellIndex): boolean;
    isFocusedRow(itemIndex: number): boolean;
    isFocusedColumn(column: GridColumn): boolean;
    fitSyncHeight(): boolean;
    pasteFromClipboard(data: string, e: Event): void;
    copyToClipboard(event: Event, range: CellRange, force?: boolean): any;
    toClipboard(selection: ConfigObject, copy?: boolean): any;
    showToast(options: any, force: boolean): void;
    hideToast(action: () => void): void;
    isEditing(index?: CellIndex): boolean;
    getEditItem(): GridItem;
    isItemEditing(item?: GridItem): boolean;
    isItemEdited(item?: GridItem): boolean;
    getEditValue(editor: CellEditor, index: CellIndex, editResult: any): void;
    private _doGetEditValue;
    isCellEditing(): boolean;
    editorCommit(index: CellIndex, oldValue: any, newValue: any): boolean;
    scrollOnEditing(): void;
    protected _doCellCommit(index: CellIndex, oldValue: any, newValue: any): boolean;
    editorActivated(editor: CellEditor): void;
    private _doEditorActivated;
    setCellUpdateEventLock(value: boolean): void;
    private $_validateCellValue;
    private $_refreshInvalidList;
    validateCellCommit(index: CellIndex, value: any): void;
    validateCells(itemIndices: number[], visibleOnly: boolean, ignorePaging: boolean): {};
    getInvalidCells(): {};
    clearInvalidCells(): void;
    /**
     * 지정한 셀의 editable 여부를 계산한다.
     */
    getEditableAt(index: CellIndex, style: ColumnStyle): boolean;
    /**
     * 지정한 셀의 readOnly 여부를 계산한다.
     */
    getReadOnlyAt(index: CellIndex, style: ColumnStyle): boolean;
    /**
     * 지정한 셀의 writable을 가져온다.
     *
     */
    getWritableAt(index: CellIndex): boolean;
    /**
     * 지정한 셀의 editable 상태를 가져온다.
     */
    canEditAt(index: CellIndex): boolean;
    /**
     * 지정한 셀의 readOnly 상태를 가져온다.
     */
    canWriteAt(index: CellIndex): boolean;
    canUpdate(item: GridItem, field: number): boolean;
    canAppend(): boolean;
    canInsert(item: GridItem, shift: boolean, ctrl: boolean): boolean;
    _doCanInsert(item: GridItem, shift: boolean, ctrl: boolean): boolean;
    canDelete(item: GridItem): boolean;
    canCommit(item: GridItem): boolean;
    canCancel(item: GridItem): boolean;
    canMergeEditing(cell: BodyTableCell): boolean;
    edit(index?: CellIndex): boolean;
    insertAt(itemIndex: number, shift: boolean): boolean;
    insert(item?: GridItem, shift?: boolean, ctrl?: boolean): boolean;
    append(): boolean;
    _appendDummy(): void;
    _cancelDummy(): void;
    setValueAt(itemIndex: number, field: number, value: any): void;
    setCellValue(index: CellIndex, value: any): void;
    recallHeight(): void;
    /**
     * @internal
     * DefaultEditController._activateEditor 에서 호출한다.
     */
    private $_canShowEditor;
    hideEditor(resetFocus?: boolean): void;
    reprepareEditor(): void;
    requestPrepareEditor(): void;
    fillEditSearchItems(column: GridColumn, searchKey: string, values: string[], labels: string[]): void;
    showEditor(index?: CellIndex, append?: boolean, dropdown?: boolean): boolean;
    showEditList(index: CellIndex): boolean;
    editorButtonClicked(index: CellIndex, event: Event): void;
    get canUndo(): boolean;
    undo(): boolean;
    get canRedo(): boolean;
    redo(): boolean;
    execute(command: EditCommand): void;
    clearCommandStack(all?: boolean): void;
    setLookups(value: ConfigObject[]): void;
    addLookupSource(source: ConfigObject): void;
    removeLookupSource(sourceId: string): void;
    existsLookupData(sourceId: string, keys: string[]): boolean;
    fillLookupData(sourceId: string, data: ConfigObject): void;
    clearLookupData(sourceId: string): void;
    addLookupData(sourceId: string, keys: string[], value?: string): void;
    setOptions(source: ConfigObject): void;
    doContextMenu(e: MouseEvent): boolean;
    setContextMenu(menuItems: ConfigObject[]): PopupMenu;
    addPopupMenu(name: string, menuItems: ConfigObject[], overwrite?: boolean): void;
    removePopupMenu(name: string): void;
    setCursor(target: HTMLElement, cursor: string): void;
    canMoveLayout(layout: CellLayoutItem): boolean;
    canMoveToLayout(layout: CellLayoutItem): boolean;
    getEditCellValue(): any;
    setEditCellValue(value: any, startEdit: boolean, dropDown: boolean): void;
    searchItem(options: SearchOptions$1): number;
    searchCell(options: SearchCellOptions$1): any;
    isCheckable(itemIndex: number): boolean;
    isCheckableOfRow(dataRow: number): boolean;
    setCheckable(itemIndex: number, value: boolean): void;
    setCheckableOfRow(dataRow: number, value: boolean): void;
    isCheckedItem(itemIndex: number): boolean;
    isCheckedRow(dataRow: number): boolean;
    checkAll(checked: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent: boolean): void;
    toggleCheck(itemIndex: number): void;
    toggleChecks(items: GridItem[], chkItem: GridItem): void;
    checkItem(itemIndex: number, checked: boolean, exclusive: boolean, checkEvent: boolean): void;
    checkRow(dataRow: number, checked: boolean, exclusive: boolean, checkEvent: boolean): void;
    checkItems(itemIndicies: number[], checked: boolean, checkEvent: boolean): void;
    checkRows(dataRows: number[], checked: boolean, checkEvent: boolean): void;
    setAllCheck(checked: boolean, itemChecked: boolean): void;
    get allChecked(): boolean;
    resetCheckables(): void;
    applyCheckables(): void;
    registerCustomRenderer(type: string, renderer: any): void;
    unregisterCustomRenderer(type: string): void;
    existsCustomRenderer(type: string): boolean;
    unregisterAllCustomRenderer(): void;
    getValueAt(layout: CellLayoutItem, itemIndex: number): any;
    getCellValue(index: CellIndex): any;
    getDistinctItemValues(field: number, maxCount?: number, sortDir?: SortDirection): any[];
    getDisplayText(index: CellIndex): string;
    /**
     * 1. 컬럼의 모든 데이터셀의 값을 가져와서
     * 2. 컬럼의 format, prefix, suffix을 반영한 텍스트의 길이를 계산해서
     * 3. 가장 큰 길이의 텍스트 너비로 설정한다.
     * 4. lookup이 설정되면 lookup label을 사용한다.
     * 5. layout의 보정 너비를 추가한다.
     * 6. layout의 minWidth, maxWidth 범위에 들어가게 한다.
     * 7. 컬럼 헤더의 너비나, 그룹헤더만 있는 경우 그룹헤더 너비보다 좁지 않게 한다.
     * // Tree관련 추가 작업은 treeView에서 처리한다.
     */
    protected _fitLayoutWidth(layout: CellLayoutColumnItem): number;
    fitLayoutWidth(layout: CellLayoutItem, maxWidth?: number, minWidth?: number): number;
    /**
     * @param checkItems item source의 sorted, grouped 상태를 확인할 것인 지 여부.
     */
    canMoveRow(checkItems: boolean, other?: boolean): boolean;
    protected abstract canMoveRows(items: GridItem[], checkItems: boolean, target: GridItem): boolean;
    protected abstract _doMoveRows(items: GridItem[], before: GridItem): boolean;
    protected abstract _getMoveTarget(eventFrom: EventFrom, items: GridItem[], r: number, delta: number): GridItem;
    moveRows(items: GridItem[], before: GridItem): boolean;
    /**
     * 데이터행과 아이템들의 순서가 filter를 제외하고 동일하다고 전제한다.
     */
    moveSelection(delta: number, eventFrom: EventFrom): void;
    isSelectedItem(itemIndex: number): boolean;
    isSelectedLayout(layout: CellLayoutItem): boolean;
    getFilteredColumns(): any[];
    showProgress(): void;
    setProgress(min: number, max: number, pos: number, msg: string): void;
    closeProgress(): void;
    showLoading(disabled: boolean): void;
    hideLoading(): void;
    beginExportProgress(msg: string): void;
    endExportProgress(): void;
    setExportProgress(max: number, pos: number, msg: string): void;
    setEmptyMessage(value: string): void;
    setWatchTimer(value: boolean): void;
    layoutExpandAll(expand: boolean, recursive: boolean): void;
    _getCssSelector(): string;
    get container(): VisualContainer;
    protected _createDelegate(): GridDelegate;
    protected _createLayoutManager(): GridLayoutManager;
    protected _createEditController(): EditController;
    protected _createSelectionLayer(): SelectionLayer;
    protected _initDom(dom: HTMLElement): void;
    protected _doActivateView(): void;
    protected _dodDeactivateView(): void;
    setRect(r: Rectangle): void;
    protected _doDraw(element: HTMLElement): void;
    abstract getFirstRow(): GridItem;
    abstract getLastRow(): GridItem;
    abstract getPrevRow(item: GridItem): GridItem;
    abstract getNextRow(item: GridItem): GridItem;
    private $_containerResized;
    protected _doCreateOtherElements(): void;
    protected _doContentPanesCreated(): void;
    protected _createSidePane(): ContentPane;
    isSidePaneVisible(): boolean;
    protected _createBodyView(body: GridBody): GridBodyElement;
    protected _createFixedBodyView(body: GridBody): GridBodyElement;
    protected _createRightBodyView(body: GridBody): GridBodyElement;
    protected _initStyles(): void;
    private _columnsReset;
    private _columnVisibleChanged;
    private _resetColumnIndices;
    private _resetColumnSortStates;
    protected _cleanGridObjects(): void;
    protected _visualObjectChanged(object: VisualObject): void;
    protected _addGridObject(obj: GridObject): void;
    protected addElement(view: VisualElement): void;
    private $_prepareRender;
    protected _doPrepareRender(bounds: Rectangle): void;
    private $_layout;
    private $_afterRender;
    private _fireDataLoadComplated;
    protected _doLayout(bounds: Rectangle): void;
    protected $_doLayout(lm: GridLayoutManager, bounds: Rectangle): void;
    protected _columnCheckedChanged(column: GridColumn): void;
    /** 사용유무 확인해서 사용되지 않으면 제거 */
    private $_updateScrollBars;
    private $_layoutScrollBars;
    protected _columnMergeRuleChanged(layout: CellLayoutColumnItem): void;
    protected _canMerge(): boolean;
    protected _populateMerges(): void;
    private $_populateMerges;
    protected _doRowGroupMergeModeChanged(): void;
    protected _addSelectionView(item: SelectionItem): void;
    protected _clearSelectionViews(): void;
    protected _removeSelectionView(item: SelectionItem): void;
    protected _layoutSelectionViews(): void;
    private $_checkCurrentRow;
    private $_doSetFocusedIndex;
    protected _refreshSideViews(): void;
    private $_makeFocusedIndexVisible;
    makeCellVisible(index: CellIndex): boolean;
    makeColumnVisible(column: GridColumn): void;
    makeItemVisible(itemIndex: number): void;
    makeLayoutVisible(layout: CellLayoutItem): void;
    cancelEditor(hideEditor: boolean): void;
    itemEditCancel(): boolean;
    private $_cancelItem;
    cancel(focus?: boolean): boolean;
    commitEditor(hideEditor?: boolean): void;
    private $_commitItem;
    commit(force: boolean, raiseFailError?: boolean, editFocusing?: boolean): boolean;
    editorCancel(editor: CellEditor, index: CellIndex): void;
    _doCellCancel(index: CellIndex): void;
    editorCanceled(): void;
    protected _editorStarted(editor: CellEditor, index: CellIndex): boolean;
    protected _editorChange(editor: CellEditor, index: CellIndex, value: any): void;
    protected _editorSearch(editor: CellEditor, index: CellIndex, text: string): void;
    protected _searchCellButtonClick(editor: CellEditor, index: CellIndex, text: string): any;
    private $_getFieldDefaults;
    private $_getColumnDefaults;
    private $_getItemDefaults;
    private $_readDefaultValues;
    private $_getInsertDefaults;
    sortColumn(column: DataColumn, event: MouseEvent): void;
    sortColumnWithStyle(sortStyle: SortStyle, column: DataColumn): void;
    orderBy(columns: DataColumn[], directions: SortDirection[], textCases: SortCase[]): void;
    unsortColumnWithStyle(sortStyle: SortStyle, column: DataColumn): void;
    $$_addSort(column: DataColumn, sortDirection: SortDirection, sortCase: SortCase, reverse: boolean): void;
    _sortItems(fields: number[], directions: SortDirection[], textCases: SortCase[]): void;
    protected _doPrepareComparer(fields: number[]): any;
    _doSortItems(fields: number[], dirs: SortDirection[], cases: SortCase[]): void;
    getSortFields(): any;
    getSortDirections(): any;
    getSortCases(): any;
    canFiltering(): boolean;
    get filterSelecting(): boolean;
    /** @internal */
    get filterSelector(): FilterSelector;
    applyFilters(filterCollection?: ColumnFilterCollection, filter?: ColumnFilter): boolean;
    private $_doApplyFilters;
    private $_addFilters;
    columnFilterChanged(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    protected abstract _doColumnFiltersChanged(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    canGrouping(): boolean;
    private $_layoutRowHover;
    private $_resetHovering;
    private $_getCellAt;
    private $_setHoveredCell;
    private $_resetRowHover;
    private $_resetFocusRender;
    protected _doHoveredCellChanged(cell: BodyTableCell): void;
    protected _doCellButtonClicked(index: CellIndex): void;
    protected _syncHeadCheck(checkedItems: GridItem[], checked?: boolean): void;
    getRowHeight(itemIndex: number): number;
    setRowHeight(itemIndex: number, newHeight: number, refresh?: boolean): void;
    clearRowHeights(all?: boolean): void;
    setFocusedClass(index: CellIndex, focused: boolean): void;
    setFocusedRowClass(index: CellIndex, focused: boolean): void;
    getSummaryCount(type: SummaryItemType): number;
    topIndexChanging(currentTop: number, delta: number, focusing?: boolean, adjust?: boolean): number;
    private $_rendererChanged;
    private $_clearDropData;
    private $_dropData;
    private $_checkFocusedLayout;
    private $_isBottomCell;
    private $_getLowerOfCell;
    private $_isTopCell;
    private $_getUpperOfCell;
    private _checkFieldIndex;
    abstract updatePastedRow(item: GridItem, values: any[], strict: boolean): void;
    abstract appendPastedRow(values: any[]): void;
    protected _fireViewActivated(active: boolean): void;
    protected _fireCurrentChanging(oldIndex: CellIndex, newIndex: CellIndex): boolean;
    protected _fireCurrentChanged(newIndex: CellIndex): void;
    protected _fireCurrentRowChanged(oldRow: number, newRow: number): void;
    protected _fireValidateCell(index: CellIndex, inserting: boolean, value: any): void;
    protected _fireValidateRow(item: GridItem, inserting: boolean, values: any[] | RowObject): void;
    protected _fireValidationFail(itemIndex: number, column: GridColumn, err: any): void;
    protected _fireCellClicked(clickData: any): void;
    protected _fireCellDblClicked(clickData: any): void;
    protected _fireCellItemClicked(index: CellIndex, clickData: any): boolean;
    protected _fireColumnCheckedChanged(column: GridColumn): void;
    protected _fireMenuItemClicked(menuItem: any, clickData: any): void;
    protected _fireContextMenuPopup(x: number, y: number, clickData: any): any;
    protected _fireContextMenuItemClicked(menuItem: any, clickData: any): void;
    protected _fireCellButtonClicked(index: CellIndex): void;
    protected _fireEditButtonClicked(index: CellIndex): void;
    protected _fireScrollToBottom(): void;
    protected _fireTopIndexChanging(currentTop: number, delta: number, focusing: boolean, adjust: boolean): number;
    protected _fireTopIndexChanged(itemIndex: number): void;
    protected _fireDataCellClicked(index: CellIndex): void;
    protected _fireDataCellDblClicked(index: CellIndex): void;
    protected _fireRowsDeleting(rows: any): boolean;
    protected _fireRowInserting(itemIndex: number, dataRow: number): boolean;
    protected _fireItemCommit(itemIndex: number, dataRow: number): void;
    protected _fireSelectionChanged(item: SelectionItem): void;
    protected _fireSelectionAdded(item: SelectionItem): void;
    protected _fireSelectionRemoved(): void;
    protected _fireSelectionCleared(): void;
    protected _fireSelectionResized(item: SelectionItem): void;
    protected _fireSelectionEnded(item: SelectionItem): void;
    protected _fireUpdateStarted(item: GridItem, appending: boolean): void;
    protected _fireInsertStarted(item: GridItem, appending: boolean): void;
    protected _fireShowEditor(index: CellIndex, editorProps: any, editorAttrs: any): boolean;
    protected _fireHideEditor(index: CellIndex): void;
    protected _fireEditChange(index: CellIndex, value: any): void;
    protected _fireGetEditValue(index: any, editResult: any): void;
    protected _fireEditCommit(index: CellIndex, oldValue: any, newValue: any): boolean;
    _fireEditCanceled(index: any): void;
    _fireItemEditCancel(item: any): boolean;
    _fireItemEditCanceled(item: any): void;
    _fireEditSearch(index: any, text: any): void;
    _fireSearchCellButtonClick(index: any, text: any): any;
    _fireCellEdited(item: any, field: any): void;
    _fireEditRowChanged(item: any, field: any, oldValue: any, newValue: any): void;
    _fireEditItemPasted(item: any, fields: any, oldValues: any, newValues: any): void;
    _fireItemsPasted(items: any): void;
    _fireCellPasting(index: CellIndex, value: any): boolean;
    _fireItemChecked(item: any): void;
    _fireItemsChecked(items: any, checked: any): void;
    _fireItemAllChecked(checked: boolean): void;
    _fireErrorClicked(cell: any, error: any): void;
    _fireSorting(fields: any, directions: any): boolean;
    _fireFiltering(): boolean;
    _fireKeyDown(event: KeyboardEvent): boolean;
    _fireKeyPress(event: KeyboardEvent): void;
    _fireKeyUp(event: KeyboardEvent): void;
    protected _fireShowTooltip(index: CellIndex, value: any): any;
    protected _fireShowHeaderTooltip(column: GridColumn, value: any): any;
    protected _fireColumnPropertyChanged(column: GridColumn, property: string, value: any, oldValue: any): void;
    protected _fireLayoutPropertyChanged(layout: CellLayoutItem, property: string, value: any, oldValue: any): void;
    _fireGridActivated(): void;
    _fireCopy(item: SelectionItem | SelectionItem[], event: Event): boolean;
    protected _firePaste(index: CellIndex, e: Event): boolean;
    protected _firePasted(): void;
    protected _fireCommandStackChanged(undoable: boolean, redoable: boolean): void;
    private onPopupMenuManagerMenuItemClicked;
    onScrollBarScrolled(bar: ScrollBar, eventType: ScrollEventType, delta: number, position: number): void;
    private $_checkFocusedRow;
    onItemProviderReset(rs: ItemProvider): void;
    onItemProviderRefresh(rs: ItemProvider): void;
    onItemProviderRefreshClient(rs: ItemProvider): void;
    onItemProviderItemInserted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemDeleted(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemUpdated(rs: ItemProvider, item: GridItem): void;
    onItemProviderCheckableChanged(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemChecked(rs: ItemProvider, item: GridItem): void;
    onItemProviderItemsChecked(rs: ItemProvider, items: GridItem[], checked: boolean): void;
    onItemProviderItemAllChecked(rs: ItemProvider, checked: boolean): void;
    onItemProviderItemCheckChanged(rs: ItemProvider, items: GridItem[], checked: boolean): void;
    onItemProviderRowStateChanged(rs: ItemProvider, item: any): void;
    onItemProviderRowStatesChanged(rs: ItemProvider, items: any): void;
    onItemProviderRowStatesCleared(rs: ItemProvider): void;
    onItemProviderSort(rs: ItemProvider, fields: any, directions: any): void;
    onItemProviderSorted(rs: ItemProvider): void;
    onItemProviderFilterAdded(rs: ItemProvider): void;
    onItemProviderFilterRemoved(rs: ItemProvider): void;
    onItemProviderFilterCleared(rs: ItemProvider): void;
    onItemProviderFilterAllCleared(rs: ItemProvider): void;
    onItemProviderFiltered(rs: ItemProvider, filterCollection: any, filter: any): void;
    onItemProviderCommandStackChanged(rs: ItemProvider, undoable: boolean, redoable: boolean): void;
    onItemProviderDataLoadComplated(rs: ItemProvider): void;
    $_focusEditItem(item: GridItem): void;
    private $_beforeEditing;
    onItemEditUpdateStarted(rs: ItemProvider, item: GridItem): void;
    onItemEditAppendStarted(rs: ItemProvider, item: GridItem): void;
    onItemEditInsertStarted(rs: ItemProvider, item: GridItem): void;
    onItemEditCellEdited(rs: ItemProvider, item: GridItem, field: number): void;
    onItemEditCellUpdated(rs: ItemProvider, item: GridItem, field: number, oldValue: any, newValue: any): void;
    onItemEditCommitting(rs: ItemProvider, item: GridItem): void;
    onItemEditCommitted(rs: ItemProvider, item: GridItem): void;
    onItemEditCanceled(rs: ItemProvider): void;
    onItemEditCommitRequest(rs: ItemProvider): void;
    onItemEditCancelReuqest(rs: ItemProvider): void;
    onLookupSourceProviderChanged(provider: any): void;
    onSelectionChanged(manager: SelectionManager, item: SelectionItem): void;
    onSelectionAdded(manager: SelectionManager, item: SelectionItem): void;
    onSelectionRemoved(manager: SelectionManager, item: SelectionItem): void;
    onSelectionCleared(manager: SelectionManager): void;
    onSelectionResized(manager: SelectionManager, item: SelectionItem): void;
    onSelectionEnded(manager: SelectionManager, item: SelectionItem): void;
    onMenuItemClick(menuItem: any, index: number): void;
}

/**
 * @internal
 */
declare abstract class PopupMenuBase extends EventAware {
    private _visible;
    protected _enabled: boolean;
    protected _label: string;
    private _tag;
    protected _elementId: string;
    constructor(src: ConfigObject);
    protected _doDispose(): void;
    get visible(): boolean;
    set visible(value: boolean);
    /** enabled */
    get enabled(): boolean;
    set enabled(value: boolean);
    /** label */
    get label(): string;
    set label(value: string);
    /** tag */
    get tag(): any;
    set tag(value: any);
    /** group */
    get group(): string;
    get manager(): PopupMenuManager;
    get type(): string;
    get checked(): boolean;
    click(): void;
    isSeparator(): boolean;
}
/**
 * 메뉴 아이템을 클릭 시 호출되는 콜백
 *
 * @remarks
 * {@link GridBase.onMenuItemClicked} 와 {@link GridBase.onContextMenuItemClicked}, {@link MenuItem | PopupMenuItem.callback} 에서 사용된다.
 *
 * [매개변수 목록]
 *
 * grid - GridBase 컨트롤
 *
 * menuItem - MenuItem 객체
 *
 * clickData - 클릭된 아이템의 정보
 *
 * @example
 * ```js
 * grid.addPopupMenu("menu1", [
 *         {
 *              label: "alpha",
 *              callback: function(grid, menuItem, index) {
 *                  console.log("aa")
 *                  console.log(menuItem);
 *                  console.log(clickData);
 *              }
 *         },
 *         {label: "beta"},
 *         {label: "gamma"}
 * ]);
 * ```
 */
declare type MenuItemClick = (grid: GridBase$1, menuItem: MenuItem, clickData: ClickData) => void;
/**
 * @internal
 */
declare class PopupMenuItem extends PopupMenuBase {
    private _type;
    private _group;
    private _checked;
    private _callback;
    private _parent;
    constructor(parent: PopupMenu, source: ConfigObject);
    protected _doDispose(): void;
    /** visible */
    /** type */
    get type(): MenuItemType;
    set type(value: MenuItemType);
    /** group */
    get group(): string;
    set group(value: string);
    /** checked */
    get checked(): boolean;
    set checked(value: boolean);
    /** callback */
    get callback(): MenuItemClick;
    set callback(value: MenuItemClick);
    /** parent */
    get parent(): PopupMenu;
    set parent(value: PopupMenu);
    isSeparator(): boolean;
    getData(): {
        label: string;
        checked: boolean;
        enabled: boolean;
        tag: any;
    };
    click(): void;
    get manager(): PopupMenuManager;
    private _itemClicked;
}
/**
 * @internal
 */
declare class PopupMenu extends PopupMenuBase {
    static readonly CLICKED: string;
    private _name;
    private _items;
    private _parent;
    constructor(parent: any, src: ConfigObject);
    protected _doDispose(): void;
    /** name */
    get name(): string;
    set name(value: string);
    /** items */
    get items(): PopupMenuBase[];
    /** parent */
    get parent(): any;
    get manager(): PopupMenuManager;
    count(): number;
    itemClicked(menuItem: PopupMenuItem): void;
    private _load;
}
/**
 * @internal
 */
declare class PopupMenuView extends EventAware {
    static $_menuId: number;
    static $_views: {};
    static _borrowView(container: GridContainer): PopupMenuView;
    static _returnView(view: PopupMenuView): void;
    private _container;
    private _containerElement;
    private _parentView;
    private _element;
    private _currDiv;
    private _menu;
    private _childView;
    private _showing;
    private _timer;
    private _viewGridInside;
    private _firstItem;
    private _itemIndex;
    constructor(container: GridContainer);
    protected _doDispose(): void;
    /** parentView */
    get parentView(): PopupMenuView;
    set parentView(value: PopupMenuView);
    /** childView */
    get childView(): PopupMenuView;
    set childView(value: PopupMenuView);
    /** currDiv */
    get currDiv(): HTMLElement;
    get manager(): PopupMenuManager;
    getElementId(): string;
    show(container: GridContainer, parentView: PopupMenuView, menuModel: PopupMenu, x: number, y: number, width?: number, targetHeight?: number, e?: MouseEvent): void;
    boundsByContainer(): Rectangle;
    hide(recursive?: boolean): void;
    hideChild(): void;
    changeItemIndex(delta: number): void;
    getActiveElementId(): string;
    menuItemClicked(elt: HTMLElement): void;
    private $_show;
    private _createElement;
    private _showChild;
    private $_hideChildView;
    private _menuItemActived;
    private _menuItemDeactived;
    private _menuItemClicked;
    private $_refreshItems;
    private $_buildItems;
}
/**
 * @internal
 */
declare class PopupMenuManager extends EventAware {
    static readonly MENU_ITEM_CLICKED: string;
    private _container;
    private _containerDom;
    private _menus;
    private _mainView;
    private _showingView;
    private _clickData;
    private _activeView;
    private _grolbalMouseHandler;
    constructor(visualContainer: GridContainer);
    protected _doDispose(): void;
    /** popupIndex */
    get clickData(): ClickData$1;
    set clickData(value: ClickData$1);
    get grid(): GridBase$1;
    get dropdownCount(): number;
    get showingView(): PopupMenuView;
    set showingView(value: PopupMenuView);
    get activeView(): PopupMenuView;
    set activeView(value: PopupMenuView);
    popupManager(): this;
    isShow(): boolean;
    indexOf(name: string): number;
    getMenu(name: string): PopupMenu;
    addMenu(name: string, menuItems: ConfigObject[], overwrite?: boolean, parent?: any): PopupMenu;
    removeMenu(name: string): void;
    clearMenus(): void;
    show(menu: string | PopupMenu, cell: HTMLElement, index: CellIndex, cx?: number, cy?: number, width?: number, height?: number): void;
    showContext(menu: PopupMenu, e: MouseEvent, x: number, y: number, clickData: ClickData$1): void;
    close(): void;
    keyDown(event: KeyboardEvent, td: HTMLTableCellElement): void;
    doMenuItemClick(menuItem: PopupMenuItem, clickData: ClickData$1): void;
    private _doKeydown;
    private $_buildItems;
}

/** @internal */
declare class DataTag extends Base {
    constructor();
    connect(ds: DataSource): void;
    disconnect(): void;
    clearRows(): void;
    setRows(): void;
    setRowCount(newCount: number): void;
    insertRow(row: number): void;
    insertRows(row: number, count: number): void;
    removeRow(row: number): void;
    removeRows(rows: number[]): void;
    updateRow(row: number): void;
    updateRows(row: number, count: number): void;
    updateRowList(rows: number[]): void;
    setValue(row: number, field: number): void;
    moveRow(row: number, newRow: number): void;
    moveRows(row: number, count: number, newRow: number): void;
    moveRowList(rows: number[], newRow: number): void;
    changeStates(rows: number[]): void;
}
/** @internal */
declare class DataTagCollection extends Base {
    private _owner;
    private _tags;
    constructor(owner: DataSource);
    protected _doDispose(): void;
    add(tag: DataTag): void;
    remove(tag: DataTag): void;
    clearRows(): void;
    setRows(): void;
    setRowCount(newCount: number): void;
    insertRow(row: number): void;
    insertRows(row: number, count: number): void;
    removeRow(row: number): void;
    removeRows(rows: number[]): void;
    updateRow(row: number): void;
    updateRows(row: number, count: number): void;
    updateRowList(rows: number[]): void;
    setValue(row: number, field: number): void;
    moveRow(row: number, newRow: number): void;
    moveRows(row: number, count: number, newRow: number): void;
    moveRowList(rows: number[], newRow: number): void;
}

/**
 * DataFilter 의 컬렉션 모델
 *
 * @remarks
 * 사용자가 필터링을 할 때 쓰일 수 있다.
 *
 * @internal
 */
declare class DataFilterCollection {
    /**
     * @internal
     */
    static readonly FILTER_AND = "and";
    /**
     * @internal
     */
    static readonly FILTER_OR = "or";
    private _filterMode;
    private _or;
    private _filters;
    constructor(source: any | any[], filterMode?: string);
    /**
     * @internal
     */
    dispose(): any;
    /**
     * 필터모드
     *
     * @remarks
     * `'and'` 또는 `'or'`여야 한다.
     */
    get filterMode(): string;
    set filterMode(value: string);
    /**
     * @internal
     */
    load(source: any | any[]): void;
    /**
     * @internal
     */
    prepare(runtime: DataFilterRuntime, ds: DataSource): void;
    /**
     * @internal
     */
    select(runtime: DataFilterRuntime, row: number, values: any[]): boolean;
}
/** @internal */
declare class DataFilterRuntime extends ExpressionRuntime {
    private static readonly ID_ROW;
    private static readonly ID_VALUE;
    private static readonly ID_VALUES;
    private static readonly IDENTS;
    private _ds;
    private _fieldCount;
    private _row;
    private _values;
    constructor();
    _doDispose(): void;
    prepare(ds: DataSource): void;
    setRow(row: number, values: any[]): void;
    isIdentifier(token: string): number;
    evaluateIdentifier(idKey: number): any;
    evaluateIndexerI(idKey: number, index: number): any;
    evaluateIndexerS(idKey: number, index: string, capitalized: boolean): any;
    private getField;
}

/** @internal */
declare class FieldSummary {
    field: number;
    constructor(field: number);
    count: number;
    sum: number;
    max: number;
    min: number;
    avg: number;
    vars: number;
    varsp: number;
    dataCount: number;
    dataAvg: number;
    clear(): void;
}

/** @internal */
interface DataCommandListener {
    getCommandStates(row: number): any;
    setCommandStates(row: number, states: any): void;
}
/** @internal */
declare abstract class DataProvider extends DataSource implements EditCommandStackOwner {
    private _tags;
    private _filters;
    private _filterRuntime;
    private _commandListeners;
    constructor();
    protected _doDispose(): void;
    editCommandStackChanged(stack: EditCommandStack, undoable: boolean, redoable: boolean): void;
    /** filters */
    get filters(): DataFilterCollection;
    /** filterRuntime */
    get filterRuntime(): DataFilterRuntime;
    /** deletedCount */
    get deletedCount(): number;
    /** tags */
    get tags(): DataTagCollection;
    addTag(tag: DataTag): void;
    removeTag(tag: DataTag): void;
    setFilterMode(value: string): void;
    setFilters(filters: any, filterMode?: string): void;
    abstract setRowCount(count: number, fillDefaults: boolean, defaultValues: any[], rowState: RowState): void;
    abstract clearRows(): void;
    abstract setRows(rows: RowValues[] | RowObject[], start: number, count: number): void;
    abstract setXmlRows(rows: number[], start: number, count: number): void;
    abstract insertRows(row: number, rows: RowValues[] | RowObject[], start: number, count: number, rowEvents?: boolean): void;
    abstract appendRows(rows: RowValues[] | RowObject[], start: number, count: number, rowEvents?: boolean): void;
    abstract insertXmlRows(row: number, rows: number[], start: number, count: number, rowEvents?: boolean): void;
    abstract updateRows(row: number, rows: RowValues[] | RowObject[], start: number, count: number, strict: boolean, rowEvents?: boolean): void;
    abstract updateRows2(rows: {
        [dataRow: number]: DataValues;
    }, strict: boolean, rowEvents: boolean): void;
    abstract updateXmlRows(row: number, rows: number[], start: number, count: number, rowEvents?: boolean): void;
    abstract appendXmlRows(rows: number[], start: number, count: number, rowEvents?: boolean): void;
    abstract getRows(startRow: number, endRow: number): RowValues[];
    abstract getRowObjects(startRow: number, endRow: number): RowObject[];
    abstract getOutputObject(options: DataOutputOptions$1, row: number): RowObject;
    abstract getOutputObjects(options: DataOutputOptions$1, startRow: number, endRow: number): RowObject[];
    abstract updateRow(row: number, values: RowValues, strict: boolean): boolean;
    abstract getFieldValues(field: number, startRow: number, endRow: number): any[];
    abstract hasData(row: number): boolean;
    abstract insertRow(row: number, values: DataValues): boolean;
    abstract appendRow(values: DataValues): number;
    abstract removeRow(row: number): void;
    abstract removeRows(row: number[], rowEvents?: boolean): void;
    abstract moveRow(row: number, newRow: number): void;
    abstract moveRows(row: number, count: number, newRow: number): void;
    abstract moveRowList(rows: number[], newRow: number): boolean;
    getRowObject(row: number): RowObject;
    compareValues(field: number, row1: number, row2: number): number;
    compareTexts(field: number, row1: number, row2: number, ignoreCase?: boolean): number;
    compareNumbers(field: number, row1: number, row2: number): number;
    compareBools(field: number, row1: number, row2: number): number;
    compareObjects(field: number, row1: number, row2: number): number;
    summarize(field: FieldSummary | number, calcVars: boolean): boolean;
    summarizeRange(field: FieldSummary | number, rows: number[], calcVars: boolean): boolean;
    copyRows(sourceRow: number, count: number, targetRow: number, noStates: boolean): void;
    get hiddenCount(): number;
    isHiddenRow(dataRow: number): boolean;
    abstract hideRows(rows: number[] | number): void;
    abstract showRows(rows: number[] | number): void;
    abstract getHiddenRows(): number[];
    abstract clearHiddenRows(): void;
    registerCommandListener(listener: DataCommandListener): void;
    unregisterCommandListener(listener: DataCommandListener): void;
    findRow(fields: number[], values: any[], from?: number): number;
    _doFieldsReset(): void;
    _refreshClients(): void;
    protected abstract _keepRow(row: number): any;
    protected abstract _yieldRow(row: number, save: any): void;
    protected abstract _keepStates(row: number): any;
    protected abstract _yieldStates(row: number, save: any): void;
    protected _keepCommandStates(row: number): any;
    protected _yieldCommandStates(row: number, save: any): void;
    fireDisposed(): void;
    _fireReset(): void;
    _fireRefresh(): void;
    fireRefreshClients(): void;
    _fireRowCountChanged(): void;
    fireDataLoadComplated(): void;
    fireRowInserting(row: number, values: RowValues | RowObject): boolean;
    fireRowInserted(row: number): void;
    fireRowsInserted(row: number, count: number): void;
    fireRowRemoving(row: number): boolean;
    fireRowRemoved(row: number): void;
    fireRowsRemoving(rows: number[]): boolean;
    fireRowsRemoved(rows: number[]): void;
    fireRowUpdating(row: number, values: RowValues | RowObject): boolean;
    fireRowUpdated(row: number): void;
    fireRowsUpdated(row: number, count: number): void;
    fireRowListUpdated(rows: number[]): void;
    fireRowMoving(row: number, newRow: number): boolean;
    fireRowMoved(row: number, newRow: number): void;
    fireRowsMoving(row: number, count: number, newRow: number): boolean;
    fireRowsMoved(row: number, count: number, newRow: number): void;
    fireRowListMoving(rows: number[], newRow: number): boolean;
    fireRowListMoved(rows: number[], newRow: number): void;
    fireValueChanging(row: number, field: number, value: number): boolean;
    fireValueChanged(row: number, field: number): void;
    fireRowStateChanged(row: number): void;
    fireRowStatesChanged(rows: number[]): void;
    fireRowStatesCleared(): void;
    fireRestoreRows(rows: number[]): void;
    fireRowHided(rows: number[], hide: boolean): void;
}

/**
 * @internal
 */
declare class LocalDataProvider$1 extends DataProvider {
    private _commands;
    private _points;
    private _nextPoint;
    private _values;
    private _rowIds;
    private _rowStates;
    private _orgValues;
    private _needRestore;
    private _deletedCount;
    private _nextRowId;
    private _hiddenIds;
    constructor(undoable: boolean, handler: any);
    protected _doDispose(): void;
    /** handler */
    get handler(): any;
    /** undoable */
    get undoable(): boolean;
    set undoable(value: boolean);
    getDataRow(rowId: number): number;
    get rowCount(): number;
    get isSummarized(): boolean;
    get deletedCount(): number;
    get canUndo(): boolean;
    get canRedo(): boolean;
    get undoing(): boolean;
    get redoing(): boolean;
    getRowId(row: number): number;
    protected $_internalInsertField(index: number, field: DataField): number;
    protected $_internalClearFields(): void;
    setRowCount(newCount: number, fillDefaults?: boolean, defaultValues?: RowValues | RowObject, rowState?: RowState): void;
    protected $_setRowCount(newCount: number, fillDefaults?: boolean, defaultValues?: RowValues | RowObject, rowState?: RowState, save?: any): void;
    private $_clearRows;
    clearRows(): void;
    setRows(rows: RowValues[] | RowObject[], start?: number, count?: number): void;
    setXmlRows(rows: any[], start?: number, count?: number): void;
    insertRows(row: number, values: (RowValues | RowObject)[], start?: number, count?: number, rowEvents?: boolean): void;
    private $_insertRows;
    appendRows(rows: RowValues[] | RowObject[], start?: number, count?: number, rowEvents?: boolean): void;
    insertRowsFrom(ds: DataSource, fieldMap: {}, rows: number[], row: number): void;
    appendRowsFrom(ds: DataSource, fieldMap: {}, rows: number[]): void;
    insertXmlRows(row: number, rows: any[], start?: number, count?: number, rowEvents?: boolean): void;
    appendXmlRows(rows: number[], start: number, count: number, rowEvents?: boolean): void;
    fillValue(rows: number[], fields: number[], value: any): void;
    updateRows(row: number, values: (RowValues | RowObject)[], start: number, count: number, strict: boolean, rowEvents?: boolean): void;
    updateRows2(rows: {
        [dataRow: number]: DataValues;
    }, strict: boolean, rowEvents: boolean): void;
    updateXmlRows(row: number, rows: any[], start: number, count: number, rowEvents?: boolean): void;
    getValue(row: number, field: number): any;
    setValue(row: number, field: number, value: any): boolean;
    $_setValue(row: number, field: number, value: any): boolean;
    updateRow(row: number, values: RowValues | RowObject, strict: boolean): boolean;
    getRow(row: number): RowValues;
    getRows(startRow?: number, endRow?: number): RowValues[];
    getRowObject(row: number, rowState?: boolean): RowObject;
    getRowObjects(startRow?: number, endRow?: number, rowState?: boolean): RowObject[];
    getOutputObject(options: DataOutputOptions$1, row: number): RowObject;
    getOutputObjects(options: DataOutputOptions$1, startRow?: number, endRow?: number): RowObject[];
    getFieldValues(field: number, startRow?: number, endRow?: number): any[];
    hasData(row: number): boolean;
    insertRow(row: number, values: RowValues | RowObject): boolean;
    private $_insertRow;
    appendRow(values: RowValues | RowObject): number;
    removeRow(row: number): boolean;
    private $_removeRow;
    removeRows(rows: number[], rowEvents?: boolean): void;
    private $_removeRows;
    moveRow(row: number, newRow: number): void;
    private $_moveRow;
    moveRows(row: number, count: number, newRow: number): void;
    private $_moveRows;
    moveRowList(rows: number[], newRow: number): boolean;
    private $_moveRowList;
    getRowState(row: number): RowState;
    private $_checkDeleted;
    setRowState(row: number, state: RowState, force: boolean): void;
    private $_setRowState;
    setRowStates(rows: number[], state: RowState, force: boolean, rowEvents?: boolean): void;
    clearRowStates(deleteRows: boolean, rowEvents?: boolean): void;
    private $_clearRowStates;
    private $_restoreStates;
    getStateRows(state: RowState): number[];
    getAllStateRows(): {
        [key: string]: number[];
    };
    getRowStateCount(states: RowState[]): number;
    private $_restoreState;
    restoreUpdatedStates(rows: number[]): void;
    private $_restoreUpdatedRow;
    private $_restoreRow;
    restoreUpdatedRows(rows: number[]): void;
    getUpdatedCells(rows: number[]): any[];
    protected _doRestoreModeChanged(): void;
    findRow(fields: any[], values: any[], from?: number): any;
    savePoint(saveStates?: boolean): number;
    rollback(savePoint: number): void;
    private $_removeSavePoints;
    clearSavePoints(): void;
    getSavePoints(): number[];
    canUpdateRow(row: number): boolean;
    canAppendRow(): boolean;
    canInsertRow(row: number): boolean;
    canDeleteRow(row: number): boolean;
    getDistinctValues(field: number, maxCount?: number, sortDir?: SortDirection): any[];
    compareValues(field: number, row1: number, row2: number, ignoreCase?: boolean): number;
    compareTexts(field: number, row1: number, row2: number): number;
    compareNumbers(field: number, row1: number, row2: number): number;
    compareDates(field: number, row1: number, row2: number): number;
    compareBools(field: number, row1: number, row2: number): number;
    compareObjects(field: number, row1: number, row2: number): number;
    summarize(field: FieldSummary, calcVars: boolean): boolean;
    summarizeRange(field: FieldSummary, rows: number[], calcVars: boolean): boolean;
    protected _keepRow(row: number): any;
    protected _yieldRow(row: number, save: any, applyExtends?: boolean): void;
    protected _keepStates(row: number): any;
    protected _yieldStates(row: number, save: any): void;
    protected _keepState(row: number): RowState;
    protected _yieldState(row: number, save: RowState): void;
    protected _keepOrgValues(): RowValues[];
    protected _yieldOrgValues(save: RowValues[]): void;
    private $_checkRowIndex;
    private $_resetOrgValues;
    private arrayToRow;
    private $_internalSetRow;
    private $_internalInsertRow;
    private $_updateRow;
    private $_updateRows;
    $_updateRows2(rows: {
        [key: number]: DataValues;
    }, strict: boolean, rowEvents: boolean, save?: any): void;
    private $_fillValue;
    private $_internalUpdateRow;
    private $_changeRowState;
    private restoreState;
    private prepareOrgValues;
    private $_changeRowStateEx;
    private $_getRowObject;
    private $_deleteRow;
    private $_internalRemoveRow;
    private $_internalMoveRow;
    private $_internalMoveRows;
    private $_internalMoveRowList;
    private $_searchDataRow;
    searchDataRow(opts: SearchOptions$1 | ConfigObject): number;
    private $_searchData;
    searchData(opts: SearchCellOptions$1 | ConfigObject): any;
    isDataChanged(row: number, fieldIndex: number): boolean;
    $_hideRows(dataRows: number[] | number, hide: boolean): void;
    hideRows(dataRows: number[] | number): void;
    showRows(dataRows: number[] | number): void;
    clearHiddenRows(): void;
    getHiddenRows(): number[];
    isHiddenRow(dataRow: number): boolean;
    get hiddenCount(): number;
    undo(): void;
    redo(): void;
    clearCommandStack(): void;
}

/** @internal */
declare abstract class TreeDataRow extends Base {
    static getRowIds(rows: TreeDataRow[]): number[];
    private _rowId;
    private _children;
    private _descendantCount;
    constructor(ds: TreeDataProvider);
    protected _doDispose(): void;
    /** rowId */
    get rowId(): number;
    /** provider */
    get provider(): TreeDataProvider;
    /** parent */
    get parent(): TreeDataRow;
    /** index */
    get index(): number;
    /** level */
    get level(): number;
    /** iconIndex */
    get iconIndex(): number;
    set iconIndex(value: number);
    /** hasChildren */
    get hasChildren(): boolean;
    /** count */
    get count(): number;
    /** descendantCount */
    get descendantCount(): number;
    /** children */
    get children(): TreeDataRow[];
    /** descendants */
    get descendants(): TreeDataRow[];
    /** ancestors */
    get ancestors(): TreeDataRow[];
    /** rowState */
    get rowState(): RowState;
    /** values */
    get values(): any[];
    getChild(index: number): TreeDataRow;
    abstract getObject(): object;
    abstract copy(): TreeDataRow;
    getChildObjects(recursive: boolean, childrenProp: string, iconProp: string, addRowId: boolean, rowState?: boolean, level?: number): object[];
    private $_createTreeOutputRows;
    getOutput(options: DataOutputOptions$1, iconProp: string): object;
    getChildOutputObjects(options: DataOutputOptions$1, recursive: boolean, childrenProp: string, iconProp: string): object[];
    findById(rowId: number): TreeDataRow;
    indexOf(child: TreeDataRow): number;
    insertChild(index: number, child: TreeDataRow, noState: boolean): boolean;
    addChild(child: TreeDataRow, noState: boolean): boolean;
    insertChildren(index: number, children: TreeDataRow[], noState: boolean): boolean;
    removeChild(child: TreeDataRow): boolean;
    clearChildren(): void;
    findChild(fields: (number | string)[], values: any[]): TreeDataRow;
    isAncestorOf(row: TreeDataRow): boolean;
    protected abstract _changeRowState(newState: RowState, fireEvent: boolean, refresh: boolean): boolean;
    clearRowStates(deleteRows: boolean, rowEvents: boolean): void;
    toTreeString(): string;
    abstract getValue(field: number): any;
    abstract setValue(field: number, value: any, noState: boolean): boolean;
    abstract update(values: any[], strict: boolean): boolean;
    protected abstract _attach(child: TreeDataRow): void;
    protected abstract _detach(child: TreeDataRow): void;
    protected abstract _keepRow(ds: TreeDataProvider): any;
    protected abstract _yieldRow(ds: TreeDataProvider, save: any): void;
    protected abstract _keepStates(ds: TreeDataProvider): any;
    protected abstract _yieldStates(ds: TreeDataProvider, save: any): void;
    protected _checkFieldIndex(field: number): void;
    protected _descendantCountChanged(count: number): void;
    protected _moveChild(index: number, newIndex: number): void;
    /**
     * @param childs - 정렬되어 있고, 모두 형제들이라고 가정한다.
     */
    protected _moveChildren(childs: number[], newIndex: number): void;
    protected _changeParent(parent: TreeDataRow, index: number): void;
    protected _insertChild(index: number, child: TreeDataRow, force: boolean, noState: boolean): boolean;
    protected _insertChildren(index: number, rows: TreeDataRow[], force: boolean, noState: boolean): boolean;
    protected _addChild(child: TreeDataRow, force: boolean, noState: boolean): boolean;
    private $_removeChild;
    protected _removeChild(child: TreeDataRow, force: boolean): boolean;
    protected _removeChildren(): void;
    protected _setChildren(children: TreeDataRow[]): void;
    private $_findChild;
    protected _collectStateRows(rows: TreeDataRow[], deletes: TreeDataRow[]): void;
    protected _clearOrgValues(): void;
    protected _restoreState(recursive: boolean, restoredRows: TreeDataRow[]): boolean;
    protected $_restoreRow(recursive: boolean, restoredRows: TreeDataRow[]): boolean;
    protected _doChildAdding(index: number, child: TreeDataRow): boolean;
    protected _doChildAdded(index: number, child: TreeDataRow): void;
    protected _doRowsAdding(index: number, rows: TreeDataRow[]): boolean;
    protected _doRowsAdded(index: number, rows: TreeDataRow[]): void;
    protected _doChildRemoving(child: TreeDataRow): boolean;
    protected _doChildRemoved(child: TreeDataRow): void;
    protected _doCleared(): void;
}
/** @internal */
interface TreeDataCommandListener {
    getCommandStates(row: TreeDataRow): any;
    setCommandStates(row: TreeDataRow, states: any): void;
}
/** @internal */
declare abstract class TreeDataProvider extends DataSource implements EditCommandStackOwner {
    protected _nextRowId: number;
    private _commandListeners;
    constructor();
    protected _doDispose(): void;
    editCommandStackChanged(stack: EditCommandStack, undoable: boolean, redoable: boolean): void;
    abstract get rootRow(): TreeDataRow;
    abstract get hiddenCount(): number;
    abstract createRow(values: any, iconIndex: number, hasChildren: boolean, refreshFieldFormats?: boolean): TreeDataRow;
    abstract isHiddenRow(rowId: number): boolean;
    abstract changeRowStates(rows: TreeDataRow[], newState: RowState): void;
    abstract addTag(tag: TreeDataTag): void;
    abstract removeTag(tag: TreeDataTag): void;
    abstract summarizeRange(summary: any, rows: TreeDataRow[], calcVars: boolean): boolean;
    abstract summarize(summary: any, calcVars: boolean): boolean;
    abstract deleteRows(rows: TreeDataRow[]): void;
    abstract removeRows(rows: number[]): boolean;
    abstract setHasChildren(row: TreeDataRow, value: boolean): boolean;
    abstract changeRowIndex(row: TreeDataRow, offset: number): boolean;
    abstract changeRowParent(row: TreeDataRow, parent: TreeDataRow, childIndex: number): boolean;
    abstract rowById(rowId: number): TreeDataRow;
    abstract rowsByIds(rowIds: number[], all: boolean): TreeDataRow[];
    abstract moveRows(rows: TreeDataRow[], before: TreeDataRow): boolean;
    registerCommandListener(listener: TreeDataCommandListener): void;
    unregisterCommandListener(listener: TreeDataCommandListener): void;
    abstract fillValue(rowIds: number[], fields: number[], value: any): void;
    abstract updateRows(rowIds: number[], values: (RowValues | RowObject)[], strict: boolean): void;
    abstract findRow(fields: number[], values: any[]): TreeDataRow;
    protected abstract _hasChildrenChanged(row: TreeDataRow): void;
    protected abstract _iconIndexChanged(row: TreeDataRow): void;
    protected abstract _stateChanged(row: TreeDataRow, refresh: boolean): void;
    protected abstract _statesChanged(rows: TreeDataRow[]): void;
    protected abstract _valueChanged(row: TreeDataRow, field: number): void;
    protected abstract _rowAdding(parent: TreeDataRow, index: number, row: TreeDataRow): boolean;
    protected abstract _rowAdded(row: TreeDataRow): void;
    protected abstract _rowsAdded(parent: TreeDataRow, rows: TreeDataRow[]): void;
    protected abstract _rowRemoving(row: TreeDataRow): boolean;
    protected abstract _rowRemoved(row: TreeDataRow): void;
    protected abstract _rowsRemoving(rows: TreeDataRow[]): boolean;
    protected abstract _rowsRemoved(rows: TreeDataRow[]): void;
    protected abstract _rowCleared(row: TreeDataRow): void;
    protected abstract _rowUpdating(row: TreeDataRow): boolean;
    protected abstract _rowUpdated(row: TreeDataRow): void;
    protected abstract _rowsUpdating(rows: TreeDataRow[]): boolean;
    protected abstract _rowsUpdated(rows: TreeDataRow[]): void;
    protected _keepCommandStates(row: TreeDataRow): any;
    protected _yieldCommandStates(row: TreeDataRow, save: any): void;
}

/** @internal */
interface TreeDataTag {
    connect(ds: TreeDataProvider): void;
    disconnect(): void;
    clearRows(): void;
    setRows(): void;
    addRow(row: TreeDataRow): void;
    addRows(rows: TreeDataRow[]): void;
    removeRow(row: TreeDataRow): void;
    removeRows(rows: TreeDataRow[]): void;
    updateRow(row: TreeDataRow): void;
    updateRows(rows: TreeDataRow[]): void;
}

/**
 * @internal
 */
declare type TreeDataParentCallback = (parent: string, child: string) => boolean;
/**
 * @internal
 */
declare class LocalTreeDataProvider$1 extends TreeDataProvider {
    private _parentCallback;
    private _commands;
    private _countDirty;
    private _tagLock;
    private _points;
    private _nextPoint;
    private _rootRow;
    private _rowMap;
    private _tags;
    private _needOrgValues;
    private _needRestore;
    private _checkParentProc;
    private _hiddenRows;
    constructor(undoable: boolean, handler: any);
    protected _doDispose(): void;
    get rootRow(): TreeDataRow;
    /** parentCallback */
    get parentCallback(): TreeDataParentCallback;
    set parentCallback(value: TreeDataParentCallback);
    /** needOrgValues */
    get needOrgValues(): boolean;
    /** needRestore */
    get needRestore(): boolean;
    /** undoable */
    get undoable(): boolean;
    set undoable(value: boolean);
    get handler(): any;
    addTag(tag: TreeDataTag): void;
    removeTag(tag: TreeDataTag): void;
    setRows(rows: any[], treeField: string, needSorting: boolean, childrenField: string, iconField: string): number;
    setCsvRows(rows: string, treeField: string, needSorting: boolean, childrenField: string, iconField: string): number;
    setXmlRows(rows: any, rowElement: string, childrenField: string, iconField: string): number;
    setJsonRows(rows: any, rowsProp: string, childrenProp: string, iconProp: string): number;
    setJsonRows2(rows: any, rowsProp: string, childRowsProp: string, childrenProp: string, iconProp: string): number;
    appendDataRows(parent: TreeDataRow, rows: any[], treeField: string, needSorting: boolean, childrenField: string, iconField: string): number;
    appendCsvRows(parent: TreeDataRow, rows: string, treeField: string, needSorting: boolean, childrenField: string, iconField: string): number;
    appendXmlRows(parent: TreeDataRow, rows: any, rowElement: string, childrenField: string, iconField: string): number;
    appendJsonRows(parent: TreeDataRow, rows: any, rowsProp: string, childrenField: string, iconField: string): number;
    setIconIndex(row: TreeDataRow, value: number): boolean;
    setHasChildren(row: TreeDataRow, value: boolean): boolean;
    getChildCount(parent: TreeDataRow): number;
    getRows(parent: TreeDataRow): TreeDataRow[];
    getDescendantCount(parent: TreeDataRow): number;
    getDescendants(parent: TreeDataRow, maxLevel: number): TreeDataRow[];
    getChild(parent: TreeDataRow, index: number): TreeDataRow;
    hasData(rowId: number): boolean;
    rowById(rowId: number): TreeDataRow;
    getDataRow(rowId: number): number;
    rowsByIds(rowIds: number[], all: boolean): TreeDataRow[];
    createRow(values: any, iconIndex: number, hasChildren: boolean, refreshFieldFormats?: boolean): TreeDataRow;
    clearRows(): void;
    removeRows(dataRows: number[]): boolean;
    changeRowIndex(row: TreeDataRow, delta: number): boolean;
    changeRowsIndex(rows: TreeDataRow[], delta: number): boolean;
    changeRowParent(row: TreeDataRow, parent: TreeDataRow, childIndex: number): boolean;
    /**
     * rows가 순서대로 정렬되어 있고, 모두 형제들이라고 가정한다.
     */
    moveRows(rows: TreeDataRow[], before: TreeDataRow): boolean;
    toTreeString(): string;
    beginUpdate(): void;
    endUpdate(refresh?: boolean): void;
    private $_extractTreeRowIds;
    private $_searchDataRow;
    searchDataRow(opts: SearchOptions$1 | ConfigObject, parentId?: number): number;
    private $_searchData;
    searchData(opts: SearchCellOptions$1 | ConfigObject, parentId?: number): any;
    private $_hideDataRows;
    hideRows(rowIds: number[] | number): void;
    showRows(rowIds: number[] | number): void;
    clearHiddenRows(): void;
    getHiddenRows(): number[];
    isHiddenRow(rowId: number): boolean;
    get hiddenCount(): number;
    summarize(summary: FieldSummary, calcVars: boolean): boolean;
    summarizeRange(summary: FieldSummary, rows: TreeDataRow[], calcVars: boolean): boolean;
    get rowCount(): number;
    get immediateUpdate(): boolean;
    get isSummarized(): boolean;
    get canUndo(): boolean;
    get canRedo(): boolean;
    get undoing(): boolean;
    get redoing(): boolean;
    getRow(rowId: number): RowValues;
    deleteRows(rows: TreeDataRow[]): void;
    equalValues(field: number, row1: TreeDataRow, row2: TreeDataRow): boolean;
    sameValues(field: number, row1: TreeDataRow, row2: TreeDataRow, ignoreCase?: boolean): boolean;
    equalTexts(field: number, row1: TreeDataRow, row2: TreeDataRow): boolean;
    compareValues(field: number, row1: TreeDataRow, row2: TreeDataRow, ignoreCase?: boolean): number;
    compareTexts(field: number, row1: TreeDataRow, row2: TreeDataRow): number;
    compareNumbers(field: number, row1: TreeDataRow, row2: TreeDataRow): number;
    compareBools(field: number, row1: TreeDataRow, row2: TreeDataRow): number;
    compareDates(field: number, row1: TreeDataRow, row2: TreeDataRow): number;
    compareObjects(field: number, row1: TreeDataRow, row2: TreeDataRow): number;
    getDistinctValues(field: number, maxCount?: number, sortDir?: SortDirection): any[];
    protected _doFieldsReset(): void;
    refreshClients(): void;
    savePoint(saveStates?: boolean): number;
    rollback(savePoint?: number): void;
    private $_removeSavePoints;
    clearSavePoints(): void;
    getSavePoints(): any[];
    protected _doCheckStatesChanged(): void;
    protected _doRestoreModeChanged(): void;
    protected _hasChildrenChanged(row: TreeDataRow): void;
    protected _iconIndexChanged(row: TreeDataRow): void;
    protected _stateChanged(row: TreeDataRow, refresh: boolean): void;
    protected _statesChanged(rows: TreeDataRow[]): void;
    protected _valueChanged(row: TreeDataRow, field: number): void;
    protected _rowAdding(parent: TreeDataRow, index: number, child: TreeDataRow): boolean;
    protected _rowAdded(row: TreeDataRow): void;
    protected _rowsAdding(parent: TreeDataRow, index: number, rows: TreeDataRow[]): boolean;
    protected _rowsAdded(parent: TreeDataRow, rows: TreeDataRow[]): void;
    protected _rowRemoving(row: TreeDataRow): boolean;
    protected _rowRemoved(row: TreeDataRow): void;
    protected _rowsRemoving(rows: TreeDataRow[]): boolean;
    protected _rowsRemoved(rows: TreeDataRow[]): void;
    protected _rowCleared(row: TreeDataRow): void;
    protected _rowUpdating(row: TreeDataRow): boolean;
    protected _rowUpdated(row: TreeDataRow): void;
    protected _rowsUpdating(rows: TreeDataRow[]): boolean;
    protected _rowsUpdated(rows: TreeDataRow[]): void;
    getRowId(row: number): number;
    getValue(row: number, fieldIndex: number): any;
    setValue(row: number, fieldIndex: number, value: any): boolean;
    getRowObject(rowId: number): RowObject;
    getRowState(rowId: number): RowState;
    setRowState(rowId: number, newState: RowState, force: boolean): void;
    changeRowStates(rows: TreeDataRow[], newState: RowState): void;
    clearRowStates(deleteRows: boolean, fireStateEvents: boolean): void;
    $_collectStateRows(row: TreeDataRow, state: RowState, rows: number[]): void;
    getStateRows(state: RowState): number[];
    $_collectAllStateRows(row: TreeDataRow, rows: {
        [key: string]: number[];
    }): void;
    getAllStateRows(): {
        [key: string]: number[];
    };
    setRowStates(rows: number[], state: RowState, force: boolean, rowEvents: boolean): void;
    private $_getRowStateCount;
    getRowStateCount(states: RowState[]): number;
    restoreUpdatedStates(rows: number[]): void;
    restoreUpdatedRows(rows: number[]): void;
    getUpdatedCells(rows: number[]): any[];
    canUpdateRow(row: number): boolean;
    canInsertRow(row: number): boolean;
    canDeleteRow(row: number): boolean;
    isDataChanged(rowId: number, fieldIndex: number): boolean;
    private $_createFrom;
    private $_insertRowsFrom;
    insertChildNode(row: TreeDataRow, index: number, data: RowObject, childrenProp: string, iconField: string, noState: boolean): number;
    insertRowsFrom(ds: DataSource, fieldMap: {}, rowIds: number[], row: number): void;
    appendRowsFrom(ds: DataSource, fieldMap: {}, rowIds: number[]): void;
    fillValue(rowIds: number[], fields: number[], value: any): void;
    updateRows(rowIds: number[], values: (RowObject | RowValues)[], strict: boolean): void;
    protected _findRowById(rowId: number): TreeDataRow;
    protected _checkSum(count: number): void;
    protected _clearRows(): void;
    private $_prepareMap;
    private $_removeMap;
    private $_fillValue;
    private $_updateRows;
    findRow(fields: number[], values: any[]): TreeDataRow;
    private $_resetOrgValues;
    private $_summarizeChildren;
    private $_summarizeVars;
    protected _summarizeChildren(parent: TreeDataRow, field: any): void;
    protected _summarizeVars(parent: TreeDataRow, field: any): any;
    _summarize(field: any, calcVars: boolean): boolean;
    protected _fireDisposed(): void;
    protected _fireReset(): void;
    protected _fireRefresh(): void;
    protected _fireRefreshClient(): void;
    protected _fireCleared(): void;
    protected _fireRowCountChanged(): void;
    protected _fireRowAdding(row: TreeDataRow, index: number, child: TreeDataRow): boolean;
    protected _fireRowAdded(row: TreeDataRow): void;
    protected _fireRowsAdding(row: TreeDataRow, index: number, rows: TreeDataRow[]): boolean;
    protected _fireRowsAdded(parent: TreeDataRow, rows: TreeDataRow[]): void;
    protected _fireRowRemoving(row: TreeDataRow): boolean;
    protected _fireRowRemoved(row: TreeDataRow): void;
    protected _fireRowsRemoving(rows: TreeDataRow[]): boolean;
    protected _fireRowsRemoved(rows: TreeDataRow[]): void;
    protected _fireRowUpdating(row: TreeDataRow): boolean;
    protected _fireRowUpdated(row: TreeDataRow): void;
    protected _fireRowsUpdating(rows: TreeDataRow[]): boolean;
    protected _fireRowsUpdated(rows: TreeDataRow[]): void;
    protected _fireValueChanging(row: TreeDataRow, field: number, newValue: any): boolean;
    protected _fireValueChanged(row: TreeDataRow, field: number): void;
    protected _fireIconIndexChanged(row: TreeDataRow): void;
    protected _fireHasChildrenChanged(row: TreeDataRow): void;
    protected _fireRowStateChanged(row: TreeDataRow, refresh: boolean): void;
    protected _fireRowStatesChanged(rows: TreeDataRow[]): void;
    protected _fireRowSiblingMoving(row: TreeDataRow, delta: number): boolean;
    protected _fireRowSiblingMoved(row: TreeDataRow, delta: number): void;
    protected _fireRowsSiblingMoving(rows: TreeDataRow[], delta: number): boolean;
    protected _fireRowsSiblingMoved(rows: TreeDataRow[], delta: number): void;
    protected _fireRowParentChanging(row: TreeDataRow, parent: TreeDataRow, childIndex: number): boolean;
    protected _fireRowParentChanged(row: TreeDataRow, parent: TreeDataRow, childIndex: number): void;
    protected _fireRowsParentChanging(rows: TreeDataRow[], parent: TreeDataRow, childIndex: number): boolean;
    protected _fireRowsParentChanged(rows: TreeDataRow[], parent: TreeDataRow, childIndex: number): void;
    protected _fireRowsHiddenChanged(rowIds: number[], hidden: boolean): void;
    fireDataLoadComplated(): void;
    undo(): void;
    redo(): void;
    clearCommandStack(): void;
}

/**
 * 데이터 채우기 방법
 *
 * @remarks
 * {@link DataFillOptions.fillMode} 에서 사용한다.
 */
declare enum DataFillMode {
    /**
     * 기존 데이터를 무시하고 0행부터 데이터 행 개수만큼 채움
     */
    SET = "set",
    /**
     * 마지막 행 뒤에 데이터 추가
     */
    APPEND = "append",
    /**
     * 삽입
     */
    INSERT = "insert",
    /**
     * 기존 데이터를 대체 (추가할 데이터는 남아있는데 이미 마지막행일 경우는 `APPEND`와 동일하게)
     */
    UPDATE = "update"
}

/**
 * {@link DataProviderBase} 의 전체설정 정보들
 *
 * @remarks
 * {@link DataProviderBase.getOptions}, {@link DataProviderBase.setOptions | setOptions} 에서 사용한다.
 *
 * @example
 * ```js
 * let options = ds.getOptions();
 * options.undoable = true;
 * ds.setOptions(options);
 * ```
 */
interface DataOptions {
    subTypeEnabled?: boolean;
    undoable?: boolean;
    insertable?: boolean;
    updatable?: boolean;
    deletable?: boolean;
    softDeleting?: boolean;
    deleteCreated?: boolean;
    checkStates?: boolean;
    restoreMode?: string;
    strictRestore?: boolean;
    booleanFormat?: string;
    datetimeFormat?: string;
    baseYear?: number;
    amText?: string;
    pmText?: string;
    commitBeforeDataEdit?: boolean;
}
/**
 * 출력할 때 데이터를 반환하는 방식에 대한 설정 모델
 *
 * @remarks
 * datetime, boolean, number 필드에 대해 변환 형식을 지정한다.
 *
 * {@link LocalDataProvider.getOutputRow}, {@link LocalDataProvider.getOutputRows} 에서 사용한다.
 *
 * {@link LocalTreeDataProvider.getOutputRow}, {@link LocalTreeDataProvider.getOutputRows} 에서 사용한다.
 *
 * @example
 * ```js
 * let opt = {
 *      nullText: '빈 값'
 * }
 * let row = dataProvider.getOutputRow(opt, 4);
 * ```
 */
interface DataOutputOptions {
    /**
     * 날짜 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 datetime 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 데이터필드에 설정된 값을 사용한다.
     *
     * 예) `'yyyy-M-dd'`
     */
    datetimeFormat?: string;
    /**
     * Boolean 형식의 값일 때 서식
     *
     * @remarks
     * 이 값이 지정되면 boolean 필드의 값을 출력할 때 변환 형식으로 사용된다.
     *
     * 지정되지 않은 경우 {@link DataField | DataField}에 설정된 값을 사용한다.
     *
     * 콜론(:) 또는 세미콜론(;)으로 구분하여 왼쪽은 `false`일 때, 오른쪽은 `true`일 때
     *
     * 예) `'Nub: Yub'`
     */
    booleanFormat?: string;
    /**
     * 숫자 형식의 값일 때 서식
     *
     * @remarks
     * 예) `'#,##0.###'`
     *
     */
    numberFormat?: string;
    /**
     * DateTime 필드의 값이 null 일때 표현되는 값
     */
    nullDateText?: string;
    /**
     * text 필드의 값이 `null` 일때 표현되는 값
     */
    nullText?: string;
    /**
     * number 필드의 값이 `null` 일때 표현되는 값
     */
    nanText?: string;
    /**
     * `true`이면 반환값에 행 상태값을 추가한다.
     */
    rowState?: boolean;
    /**
     * datetime 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link DatetimeOutputCallback} 의 형식이다.
     * @eventProperty
     */
    datetimeCallback: DatetimeOutputCallback;
    /**
     * boolean 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link BooleanOutputCallback} 의 형식이다.
     * @eventProperty
     */
    booleanCallback: BooleanOutputCallback;
    /**
     * number 필드 변환시 수행 될 콜백
     *
     * @remarks
     * {@link NumberOutputCallback} 의 형식이다.
     * @eventProperty
     */
    numberCallback: NumberOutputCallback;
}
/**
 * 데이터 불러오기에 관한 설정 모델
 *
 * @remarks
 * {@link LocalDataProvider.fillJsonData}, {@link LocalTreeDataProvider.fillJsonData} 등의 fill 관련 method 에서 사용된다.
 *
 * 원하는 정보만 입력하여 설정하면 된다.
 */
interface DataFillOptions {
    /**
     * 데이터 채움 방법
     *
     * @defaultValue {@link DataFillMode.SET}
     */
    fillMode?: DataFillMode.SET;
    /**
     * `fillMode`가 'insert' 거나 'update' 때 시작되는 행
     *
     * @defaultValue `0`
     */
    fillPos?: number;
    /**
     * 가져올 데이터 행
     *
     * @remarks
     * `-1`인 경우 전체를 가져온다.
     * @defaultValue `-1`
     */
    count?: number;
    /**
     * 데이터 소스의 최상위가 Array 인지의 여부
     *
     * @remarks
     * json인 경우에만 사용
     *
     * @defaultValue `true`
     */
    rootArray?: boolean;
    /**
     * 행의 데이터 형식
     *
     * 데이터 중에서 row element나 array 요소의 이름. json, xml안 경우에만 사용가능 하다.
     *
     * @defaultValue 'row'
     */
    rows?: string;
    /**
     * 데이터에서 해더등을 제외한 실제 데이터 시작 행
     *
     * @remarks
     *
     * @defaultValue `0`
     */
    start?: number;
    /**
     * 구분자
     *
     * @remarks
     * CSV 경우인 경우에만 사용
     *
     * @defaultValue `','`
     */
    delimiter?: string;
    /**
     * 각 셀 데이터가 double-quotation mark("") 로 감싸져 있는지 여부
     *
     * @remarks
     * CSV 경우인 경우에만 사용
     *
     * @defaultValue `false`
     */
    quoted?: boolean;
    /**
     * 부모 행의 고유번호
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `parent` 라는 속성으로 지정할 수도 있다.
     * @defaultValue `0`
     */
    parentId?: number;
    /**
     * TreeProvider만 사용가능, children field
     */
    childrenField?: string;
    /**
     * 트리 필드 명
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `tree` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `null`
     */
    treeField?: string;
    /**
     * 아이콘 필드 명
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `icon` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `null`
     */
    iconField?: string;
    /**
     * 정렬 여부
     *
     * @remarks
     * TreeProvider만 사용가능하다.
     *
     * `sorting` 라는 속성으로 지정할 수도 있다.
     *
     * @defaultValue `false`
     */
    needSorting?: boolean;
    /**
     * 생성 된 데이터 행들에 상태를 설정하지 않을 것인지의 여부
     *
     * @defaultValue `false`
     */
    noStates?: boolean;
}

/**
 * @internal
 */
declare class DataExportOptions extends ExportBaseOptions$1 {
    constructor(source: ConfigObject);
    get type(): ExportType;
    exportFields: string[];
    hideFields: string[];
    includeFieldNames: boolean;
}

/**
 * @public
 * 데이터 필드에 관한 입력 형식
 *
 * @remarks
 * {@link DataProviderBase.setFields |setFields} 등에서 사용한다.
 *
 * @example
 * ```js
 * // string
 * ds.setFields('fieldnName');
 *
 * // model
 * let fields = ds.getFields();
 * ds.setFields(fields);
 *
 * // config
 * ds.setFields({
 *      fieldName: 'OrderID',
 *      dataType: 'text',
 * });
 * ```
 */
declare type DataFieldInput = string | DataField$1 | DataFieldObject;
/**
 * @public
 * 비교함수 형식
 *
 * @remarks
 * Array.prototype.sort() 에서 쓰는 CompareFunction 과 같은 형식이다.
 *
 * {@link DataProviderBase.setDataComparer} 에서 사용한다.
 */
declare type CompareFunction = (field: number, row1: any, row2: any) => number;
/**
 * @internal
 */
declare abstract class EventListenerBase {
}
/**
 * @public
 * {@link LocalDataProvider} 와 {@link LocalTreeDataProvider} 의 기반 클래스
 *
 * @remarks
 * DataProviderBase 의 모든 속성과 method 는 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [하위 클래스]
 *
 * {@link LocalDataProvider}
 *
 * {@link LocalTreeDataProvider}
 *
 * @param undoable - 데이터를 되돌릴 수 있는지 여부
 *
 * @warning DataProviderBase 로 직접 설정하거나 호출할 수 없다.
 *
 */
declare abstract class DataProviderBase {
    /**
     * @internal
     */
    protected _dp: LocalDataProvider$1 | LocalTreeDataProvider$1;
    private _listener;
    /**
     * @param undoable - 데이터를 되돌릴 수 있는지 여부
     */
    constructor(undoable: boolean);
    /**
     * @internal
     */
    dispose(): void;
    /**
     * {@link DataField} 의 subType 속성의 활성화 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.subTypeEndabled = false;
     * ```
     */
    get subTypeEnabled(): boolean;
    set subTypeEnabled(value: boolean);
    /**
     * undo/redo 사용 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.undoable = true;
     * ```
     */
    get undoable(): boolean;
    set undoable(value: boolean);
    /**
     * 행 삽입 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.insertable = false;
     * ```
     */
    get insertable(): boolean;
    set insertable(value: boolean);
    /**
     * 행 수정 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.updatable = false;
     * ```
     */
    get updatable(): boolean;
    set updatable(value: boolean);
    /**
     * 행 삭제 가능 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.deletable = false;
     * ```
     */
    get deletable(): boolean;
    set deletable(value: boolean);
    /**
     * 행 삭제 시 실제로 삭제하지 않고 RowState 만 변경할지의 여부
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.softDeleting = false;
     * ```
     */
    get softDeleting(): boolean;
    set softDeleting(value: boolean);
    /**
     * 추가된 행을 삭제 시 실제로 삭제할지의 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.deleteCreated = false;
     * ```
     */
    get deleteCreated(): boolean;
    set deleteCreated(value: boolean);
    /**
     * 행 상태 관리 활성화 여부
     *
     * @defaultValue `true`
     *
     * @example
     * ```js
     * ds.checkStates = false;
     * ```
     */
    get checkStates(): boolean;
    set checkStates(value: boolean);
    /**
     * 복원 모드
     * @defaultValue {@link RestoreMode.NONE}
     *
     * @example
     * ```js
     * ds.restoreMode = 'explicit';
     * ```
     */
    get restoreMode(): RestoreMode;
    set restoreMode(value: RestoreMode);
    /**
     * 복원시 `undefined`, `null`, 빈 문자열을 다른 값으로 인식할지의 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.strictRestore = true;
     * ```
     */
    get strictRestore(): boolean;
    set strictRestore(value: boolean);
    /**
     * 데이터에서 Boolean으로 Parsing 하기 위한 포맷
     *
     * @defaultValue `null` (기본 포맷 이용)
     *
     * @example
     * ```js
     * ds.booleanFormat = 'No: Yeah';
     * ```
     */
    get booleanFormat(): string;
    set booleanFormat(value: string);
    /**
     * text형식의 날짜 데이터를 datetime 값으로 Parsing하기위한 포맷
     *
     * @defaultValue `null` (기본 포맷 이용)
     *
     * @example
     * ```js
     * ds.datetimeFormat = 'yyyy-MM-dd';
     * ```
     */
    get datetimeFormat(): string;
    set datetimeFormat(value: string);
    /**
     * 데이터의 년도가 2자리일때 기준으로 하는 년도
     *
     * @defaultValue `2000`
     *
     * @example
     * ```js
     * ds.baseYear = 1000;
     * ```
     */
    get baseYear(): number;
    set baseYear(value: number);
    /**
     * 데이터에서 오전에 해당하는 문자열
     *
     * @defaultValue `'AM'`
     *
     * @example
     * ```js
     * ds.amText = "오전";
     * ```
     */
    get amText(): string;
    set amText(value: string);
    /**
     * 데이터에서 오후에 해당하는 문자열
     * @defaultValue `'PM'`
     *
     * @example
     * ```js
     * ds.pmText = "오후";
     * ```
     */
    get pmText(): string;
    set pmText(value: string);
    /**
     * 편집 상태일 때 다른 행에 대한 변경 함수(`setValue()` 등) 호출 시 이전 편집 자동 커밋 여부
     *
     * @defaultValue `false`
     *
     * @example
     * ```js
     * ds.commitBeforeDataEdit = true;
     * ```
     */
    get commitBeforeDataEdit(): boolean;
    set commitBeforeDataEdit(value: boolean);
    /**
     * json 형태의 data를 dataProvider에 입력할때 각 행별로 호출되는 콜백
     *
     * @remarks
     *
     * @defaultValue `undefined`
     */
    get valuesCallback(): ObjectToValuesCallback;
    set valuesCallback(value: ObjectToValuesCallback);
    /**
     * 설정 정보를 반환한다.
     *
     * @remarks
     * 설정정보를 {@link DataOptions} 형태로 반환한다.
     *
     * @example
     * ```js
     * let options = ds.getOptions();
     * options.undoable = true;
     * ds.setOptions(options);
     * ```
     */
    getOptions(): DataOptions;
    /**
     * 설정정보를 변경한다.
     *
     * @remarks
     * options 에 기입하지 않은 설정은 원래의 값을 유지한다.
     *
     * @param options - {@link DataOptions} 설정정보 객체
     *
     * @example
     * ```js
     * let options =  {
     *     insertable: true,
     *     updatable: true,
     *     softDeleting: false
     * };
     * ds.setOptions(options);
     * ```
     */
    setOptions(options: DataOptions): void;
    /**
     * 일괄 갱신의 시작점을 지정한다.
     *
     * @remarks
     * DataProvider에서 변경 작업이 발생하면 이를 View에 이벤트를 전달하여 처리하는데 일괄처리를 할때는 이벤트가 빈번히 발생하여 성능이 저하 될 수 있다.
     * beginUpdate()를 호출하면 {@link DataProviderBase.endUpdate | endUpdate()} 가 호출 되기전까지 이벤트가 발생하지 않고 endUpdate()가 호출될 때 일괄 발생한다.
     * beginUpdate ~ endUpdate는 중첩될 수 있는데 반드시 쌍으로 호출되어야 하고 마지막 쌍의 endUpdate가 호출될때 이벤트가 View에 전달된다.
     *
     * @example
     * ```js
     * dataProvider.beginUpdate();
     * try {
     *     for (var i = 0; i < 10; i++) {
     *         var values = gridView.getValues(i);
     *         dataProvider.addRow(values);
     *     }
     * } finally {
     *     dataProvider.endUpdate();
     * }
     * ```
     */
    beginUpdate(): void;
    /**
     * 일괄 갱신의 완료점을 지정한다.
     *
     * @remarks
     * DataProvider에서 변경 작업이 발생하면 이를 View에 이벤트를 전달하여 처리하는데 일괄처리를 할때는 이벤트가 빈번히 발생하여 성능이 저하 될 수 있다.
     * {@link DataProviderBase.beginUpdate | beginUpdate()} 를 호출하면 endUpdate()가 호출될 되기전까지 이벤트를 발생하지 않고 endUpdate()가 호출될대 일괄 발생한다.
     * beginUpdate ~ endUpdate는 중첩될 수 있는데 반드시 쌍으로 호출되어야 하고 마지막 쌍의 endUpdate가 호출될때 이벤트가 View에 전달된다.

     * @example
     * ```js
     * dataProvider.beginUpdate();
     * try {
     *     for (var i = 0; i < 10; i++) {
     *         var values = gridView.getValues(i);
     *         dataProvider.addRow(values);
     *     }
     * } finally {
     *     dataProvider.endUpdate();
     * }
     * ```
     */
    endUpdate(refresh?: boolean): void;
    /**
     * {@link DataField} 객체들을 반환한다.
     *
     * @remarks
     * 현재 DataProvider에 설정된 DataField 객체를 배열로 반환한다.
     *
     * @example
     * ```js
     * let fields = ds.getFields();
     * ds2.setFields(fields);
     * ```
     */
    getFields(): DataField$1[];
    /**
     * 필드셋을 설정한다
     *
     * @remarks
     * 기존 필드 정보와 binding된 데이터를 삭제하고 전달받은 필드 정보 배열로 부터 새로운 필드셋을 구성한다.
     * fields의 갯수만큼 {@link DataField} 객체를 생성, 요소가 문자열일경우 fieldName으로, DataField 인 경우 복제, {@link DataFieldObject} 인 경우 속성값 기준으로 생성한다.
     *
     * @param fields - 생성할 DataField의 정보 배열
     *
     * @example
     * ```js
     * // string
     * ds.setFields('fieldnName');
     *
     * // model
     * let fields = ds.getFields();
     * ds.setFields(fields);
     *
     * // config
     * ds.setFields({
     *      fieldName: 'OrderID',
     *      dataType: 'text',
     * });
     * ```
     */
    setFields(fields: DataFieldInput[]): void;
    /**
     * 필드를 추가로 생성한다.
     *
     * @remarks
     * {@link DataField} 객체를 생성하여 기존 필드셋에 추가한다.
     *
     * @param field - 생성할 데이터 필드의 정보값, 문자열일 경우 fieldName으로 설정
     * @param resetFields - 기존 데이터 필드에 binding된 데이터를 초기화 할지의 여부
     * @param calculateData - calculated 필드를 다시 계산할지의 여부
     *
     * @example
     * ```js
     * // string
     * ds.addField('fieldnName');
     *
     * // model
     * let fields = ds.getFields();
     * ds2.addField(fields);
     *
     * // config
     * ds.addField({
     *      fieldName: 'OrderID',
     *      dataType: 'text',
     * });
     * ```
     */
    addField(field: DataFieldInput, resetFields?: boolean, calculateData?: boolean): DataField$1;
    /**
     * 현재 구성된 필드셋의 갯수를 반환한다.
     *
     * @example
     * ```js
     * let fCount = ds.getFieldCount();
     * ```
     */
    getFieldCount(): number;
    /**
     * 이름에 해당하는 필드를 반환한다.
     *
     * @returns fieldName속성을 기준으로 해당하는 {@link DataField} 객체를 반환한다. fieldName이 모두 일치하지 않을 경우 `null`을 반환한다.
     *
     * @param name - 필드의 fieldName에 해당하는 값
     *
     * @example
     * ```js
     * let field = ds.fieldByName('Fruits');
     * ```
     */
    fieldByName(name: string): DataField$1;
    /**
     * 필드들의 이름을 반환한다.
     *
     * @remarks
     * 필드셋에서 필드의 fieldName 속성들을 배열로 반환한다.
     *
     * fieldName은 내부적으로 대문자로 저장되므로 대문자 문자열로 출력된다.
     *
     * 설정시의 fieldName으로 가져오려면 {@link DataProviderBase.getOrgFieldNames | getOrgFieldNames()} 를 사용한다.
     *
     * @example
     * ```js
     * let fieldNames = ds.getFieldNames();
     * ```
     */
    getFieldNames(): string[];
    /**
     * 필드들의 원래의 이름을 반환한다.
     *
     * @returns 필드셋에서 필드 설정당시의 fieldName 속성들을 반환한다.
     *
     * @example
     * ```js
     * let orgFieldNames = ds.getOrgFieldNames();
     * ```
     */
    getOrgFieldNames(): string[];
    /**
     * 특정 인덱스의 필드의 이름을 반환한다.
     *
     * @remarks
     * 필드셋에서 fieldIndex에 위치된 필드의 fieldName속성을 반환한다.
     *
     * fieldName은 내부적으로 대문자로 저장되므로 대문자 문자열로 출력된다.
     *
     * 설정시의 fieldName으로 가져오려면 {@link DataProviderBase.getOrgFieldName | getOrgFieldName()} 을 사용한다.
     *
     * @param fieldIndex - 필드 인덱스
     *
     * @example
     * ```js
     * let fieldName = ds.getFieldName(3);
     * ```
     */
    getFieldName(fieldIndex: number): string;
    /**
     * 특정 인덱스의 필드의 원래 이름을 반환한다.
     *
     * @param fieldIndex - 필드의 인덱스
     * @returns 필드셋에서 fieldIndex에 위치된 필드의 설정 당시의 fieldName속성을 반환한다.
     *
     * @example
     * ```js
     * let fieldName = ds.getOrgFieldName(3);
     * ```
     */
    getOrgFieldName(fieldIndex: number): string;
    /**
     * 필드명에 해당하는 인덱스를 반환한다.
     *
     * @param fieldName - 필드명, 대소문자를 구분하지 않는다.
     * @returns 필드셋에서 fieldName에 해당하는 필드의 인덱스를 반환한다.
     *
     * @example
     * ```js
     * let index = ds.getFieldIndex('fieldName');
     * ```
     */
    getFieldIndex(fieldName: string): number;
    /**
     * 행에 값이 채워져씼는지 여부를 반환한다.
     *
     * @remarks
     * 지정한 데이터행이 값이 채워져있는지 빈 행인지 여부를 반환한다.
     *
     * @param row - 데이터셋의 행 고유번호
     *
     * @returns 값이 있으면 `true`, 데이터없이 추가된 빈 행이면 `false`
     *
     * @example
     * ```js
     * let has = ds.hasData(5);
     * ```
     */
    hasData(row: number): boolean;
    /**
     * 행의 값들을 반환한다.
     *
     * @remarks
     * 해당 데이터 행의 값들을 배열로 반환한다.
     *
     * @param row - 데이터 셋의 행 고유번호
     * @returns 필드 순서대로 배열화한다.
     *
     * @example
     * ```js
     * let val = ds.getValeus(5);
     * ```
     */
    getValues(row: number): RowValues;
    /**
     * 행 상태 기록 여부를 지정한다.
     *
     * @remarks
     * 행 추가/수정/삭제 상태가 변경될 때 상태를 기록할지를 결정한다.
     * 기록 되지 않으면 {@link DataProviderBase.softDeleting | softDeleting} 이 `true`여도 무시하고 삭제 된다.
     * @param value - 행 상태 기록 여부
     *
     * @example
     * ```js
     * let checkState = ds.checkRowStates(true);
     * ```
     */
    checkRowStates(value: boolean): void;
    /**
     * 지정한 행의 상태를 반환한다.
     *
     * @param row - 데이터 셋의 행 고유 번호
     * @returns 아무 상태도 없으면 {@link RowState.NONE} 을 반환한다.
     *
     * @example
     * ```js
     * let rowState = ds.getRowState(4);
     * ```
     */
    getRowState(row: number): RowState;
    /**
     * 특정 상태를 갖는 데이터 행 인덱스들을 반환한다.
     *
     * @remarks
     * 지정된 rowState 값을 상태로 갖는 행들의 인덱스를 배열로 반환한다.
     *
     * @param rowState - 행 상태, {@link RowState} 모델
     *
     * @example
     * ```js
     * let rows = ds.getStateRows('c');
     * ```
     */
    getStateRows(rowState?: RowState): number[];
    /**
     * 상태값을 갖는 모든 행의 인덱스를 반환한다.
     *
     * @remarks
     * {@link RowState.NONE } 이 아닌 행들의 번호를 상태별로 배열로 만들어 Object 형태로 반환한다.
     *
     * @returns {@link RowStateList} 모델이다.
     *
     * @example
     * ```js
     * let rows = ds.getAllStateRows();
     * ```
     */
    getAllStateRows(): RowStateList;
    /**
     * 모든 행의 상태를 제거한다.
     *
     * @remarks
     * 모든 데이터 행의 상태를 {@link RowState.NONE } 으로 초기화한다.
     *
     * @param deleteRows - 행 상태가 삭제인 행을 실제로 삭제할지의 여부, `true`이면 데이터 셋에서 제거되고 `false`이면 행 상태를 리셋하고 데이터를 보존한다.
     * @param rowEvents - 상태가 제거된 행에 대해 {@link LocalDataProvider.onRowStateChanged | onRowStateChanged} 등의 상태변경 콜백을 발생시킬지의 여부
     *
     * @example
     * ```js
     * ds.clearRowState(true);
     * ```
     */
    clearRowStates(deleteRows: boolean, rowEvents?: boolean): void;
    /**
     * 특정 행의 상태를 변경한다.
     *
     * @param row - 상태를 변경할 데이터 행 인덱스
     * @param state - 변경할 상태, 기본값: {@link RowState.NONE}
     * @param force - DataProvider의 상태 관리에 관계없이 적용 여부, 기본값: `false`
     *
     * @example
     * ```js
     * ds.setRowState(5, 'u');
     * ```
     */
    setRowState(row: number, state?: RowState, force?: boolean): void;
    /**
     * 복수의 행의 상태를 일괄 변경한다.
     *
     * @remarks
     * 배열로 전달된 데이터 행들의 상태를 일괄적으로 변경한다.
     *
     * @param rows - 상태를 변경할 데이터 행 인덱스의 배열
     * @param state - 변경할 상태
     * @param force -  DataProvider의 상태 관리에 관계없이 적용 여부
     * @param rowEvents - `true`이면 각각의 데이터 행의 상태 변경 이벤트 발생, `false`면 하나의 이벤트로 묶어서 발생
     *
     * @example
     * ```js
     * ds.setRowStates([1,3,5]);
     * ```
     */
    setRowStates(rows: number[], state?: RowState, force?: boolean, rowEvents?: boolean): void;
    /**
     * 상태별 데이터 행 개수를 반환한다.
     *
     * @remarks
     * 지정한 상태 배열 또는 문자열에 따라 포함된 상태별 행 건수를 반환한다.
     *
     * `'*'`, `'all'` 입력 시 모두 반환한다.
     *
     * @param states - 행의 상태, 복수일때는 상태의 배열, 모든 상태를 알고싶은 경우 'all' 또는 '*' 문자열을 사용한다.
     * @returns 상태에 해당하는 데이터 행의 건수, {@link RowState.NONE} 인 경우는 제외한다.
     * @example
     * ```js
     * var allStateCount = dataProvider.getRowStateCount('all');
     * var updateCount = dataProvider.getRowStateCount(RealGrid.RowState.UPDATED);
     * ```
     */
    getRowStateCount(states: string | RowState | RowState[]): number;
    /**
     * 지정한 행들의 상태를 복원한다.
     *
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT}일 때 값이 변경되었다가 원복된 행의 상태를 복원한다.
     * 예를들어 상태가 {@link RowState.NONE} 인 행을 편집하여 {@link RowState.UPDATED} 상태가 되었을때 행의 값이 원래대로 돌아간후 호출하면 상태가 {@link RowState.NONE}으로 원복된다.
     * restoreMode가 AUTO일 땐 행 값에 따라 자동으로 복원된다.
     * @param rows - 상태를 원복하려는 데이터행 인덱스의 배열
     *
     * @example
     * ```js
     * ds.restoreUpdatedStates([2, 4]);
     * ```
     */
    restoreUpdatedStates(rows: number[]): void;
    /**
     * 지정한 행들의 값과 상태를 복원한다.
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT} 또는 AUTO일 때, 지정된 행들의 변경내용과 상태를 원래대로 복원한다.
     * @param rows - 복원하려는 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * ds.restoreUpdatedRows([2, 4]);
     * ```
     */
    restoreUpdatedRows(rows: number | number[]): void;
    /**
     * 지정한 행들의 변경된 셀정보를 반환한다
     *
     * @remarks
     * restoreMode속성이 {@link RestoreMode.EXPLICIT} 또는 AUTO일 때, 지정된 행들 각각의 값이 변경된 셀의 정보를 반환한다.
     *
     * @param rows - 변경된 셀의 정보를 가져올 행의 배열, `null`일 경우 상태가 {@link RowState.UPDATED}인 전체 행의 정보를 반환한다.
     * @example
     * ```js
     *
     * let cells = ds.getUpdatedCells([1]);
     *
     * // 변환 데이터 예)
     * [
     *   {
     *     __rowId: 1,
     *     updatedCells: [
     *       {
     *         fieldName: 'OrderID',
     *         oldValue: '1002',
     *         newValue: '1003',
     *       },
     *       {
     *         fieldName: 'OrderCount',
     *         oldValue: 20,
     *         newValue: 30
     *       }
     *     ]
     *   }
     * ]
     * ```
     */
    getUpdatedCells(rows: number[]): UpdatedRow[];
    /**
     * 필드의 중복되지 않은 값들을 반환한다.
     *
     * @remarks
     * 데이터 셋에서 지정된 필드에 해당하는 값들을 중복을 배제하여 정렬상태로 반환한다,
     *
     * @param field - 필드 명 또는 필드 인덱스
     * @param maxCount - 최대 건수, 정렬한 상태에서 위에부터 건수만큼 잘라서 반환한다. 기본값: `-1`
     * @param sortDir - 정렬 방법, 기본값: {@link SortDirection.ASCENDING}
     *
     * @example
     * ```js
     * ds.getDistinctValues('field1');
     * ```
     */
    getDistinctValues(field: string | number, maxCount?: number, sortDir?: SortDirection): any[];
    /**
     * 데이터 셋의 복구 시점을 기록한다.
     *
     * @remarks
     * 데이터 셋의 데이터및 상태를 복제하여 저장하고 포인트의 인덱스를 반환한다.
     * 이 후 {@link DataProviderBase.rollback | rollback()} 함수를 통해 특정 포인트로 돌아갈 수 있다.
     * @param saveStates - 상태 기록 여부
     *
     * @example
     * ```js
     * ds.savePoint([2, 4]);
     * ```
     */
    savePoint(saveStates?: boolean): number;
    /**
     * 데이터 셋을 복원한다
     *
     * @remarks
     * 데이터 셋의 데이터및 상태를 해당 포인트 시점으로 되돌린다.
     *
     * @param savePoint - 복구 포인트의 인덱스, 기본값: 0
     *
     * @example
     * ```js
     * ds.rollback();
     * ```
     */
    rollback(savePoint?: number): void;
    /**
     * 모든 복구시점을 제거한다.
     *
     * @remarks
     * 모든 복구 시점과 관련 저장한 데이터및 상태를 삭제한다.
     *
     * @example
     * ```js
     * ds.clearSavePoints();
     * ```
     */
    clearSavePoints(): void;
    /**
     * 모든 복구시점들을 반환한다.
     *
     * @remarks
     * 저장된 모든 복구시점들의 인덱스를 배열로 반환한다.
     *
     * @example
     * ```js
     * ds.getSavePoints([0, 1, 2]);
     * ```
     */
    getSavePoints(): number[];
    /**
     * 특정 필드의 정렬 함수를 설정한다.
     *
     * @remarks
     * 해당 필드의 정렬이 발생시 기본적으로 사용는 정렬 함수가 아닌 사용자 정의 정렬 함수를 설정한다.
     * 정렬 함수는 자바스크립트 Array.prototype.sort()의 compareFunction과 동일하다.
     * @param field - 정렬방식을 지정할 필드의 이름 또는 인덱스
     * @param comparer - 사용자 정의 정렬 함수
     * @example
     * ```js
     * dataProvider.setDataCompare('OrderID', function(field, row1, row2) {
     *   var val1 = dataProvider.getValue(row1, field);
     *   var val2 = dataProvider.getValue(row2, field);
     *   return val1 == val2 ? 0 : val1 > val2 ? 1 : -1;
     * }
     * ```
     */
    setDataComparer(field: string | number, comparer: CompareFunction): void;
    /**
     * 데이터 셋을 CSV파일로 내보낸다.
     *
     * @remarks
     * options의 설정에 따라 데이터 셋에 저장된 데이터를 CSV파일로 내보낸다.
     *
     * 이는 데이터 수준에서의 내보내기이므로 View 에서 설정하는 상태와는 무관하게 진행된다.
     *
     * @param options - 내보내기 설정
     *
     * @example
     * ```js
     * ds.exportToCsv();
     * ```
     */
    exportToCsv(options: DataExportOptions): void;
    /**
     * DataProvider 객체를 메모리에서 해제한다.
     *
     * @remarks
     * DataProvider내부에서 사용된 객체와 데이터등을 제거하고 가비지 콜렉팅이 되도록 한다.
     *
     * @example
     * ```js
     * ds.destroy();
     * ```
     */
    destroy(): void;
    /**
     * 이전에 수정한 내용을 되돌린다.
     *
     * @example
     * ```js
     * ds.undo();
     * ```
     */
    undo(): void;
    /**
     * 되돌린 내용을 취소한다.
     *
     * @example
     * ```js
     * ds.redo();
     * ```
     */
    redo(): void;
    /**
     * Command Stack 을 초기화한다.
     *
     * @example
     * ```js
     * ds.clearCommandStack();
     * ```
     */
    clearCommandStack(): void;
    /**
     * @internal
     */
    protected abstract _createProvider(undoable: boolean): LocalDataProvider$1 | LocalTreeDataProvider$1;
    /**
     * @internal
     */
    protected abstract _createListener(provider: LocalDataProvider$1 | LocalTreeDataProvider$1): GridProviderListener | TreeProviderListener;
    /**
     * @internal
     */
    getProvider(): DataSource;
}
/**
 * @public
 * LocalDataProvider 클래스. {@link DataProviderBase} 를 상속한다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link DataProviderBase}
 */
declare class LocalDataProvider extends DataProviderBase {
    /**
     * @internal
     */
    protected _dp: LocalDataProvider$1;
    /**
     * 데이터 행의 건수가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 행 추가 및 삭제 등으로 데이터 행의 개수가 변경됐을 때 호출된다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `newCount` - 변경 후 전체 데이터 행의 건수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowCountChanged = function (provider, newCount) {
     *     console.log("DataProvider rowCount changed as: " + newCount);
     * };
     * ```
     */
    onRowCountChanged: (provider: LocalDataProvider, newCount: number) => void;
    /**
     * 데이터 행의 수정을 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 수정되기 직전에 호출하여 행의 수정 여부를 확인한다. 행의 수정이 완료된 후 {@link LocalDataProvider.onRowUpdated | onRowUpdated}가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`면 행의 수정을 완료하고 `false`면 행의 수정을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowUpdating = function (provider, row) {
     *      if(row % 2 === 0) {
     *          console.log("DataProvider row updated: " + row);
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowUpdating: (provider: LocalDataProvider, row: number) => boolean;
    /**
     * 데이터 행이 수정되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowUpdating | onRowUpdating} 에서 `true`가 반환되었을 때 수정이 완료된 후에 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowUpdated = function (provider, row) {
     *      console.log("DataProvider row updated: " + row);
     * };
     * ```
     */
    onRowUpdated: (provider: LocalDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행이 일괄 수정되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.updateRows | updateRows } 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     * @eventProperty
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 시작 데이터 행의 인덱스
     *
     * `count` - 변경된 행의 건수
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdated = function (provider, row, count) {
     *      console.log("DataProvider rows updated from " + row + 'to' + (count + row));
     * };
     * ```
     */
    onRowsUpdated: (provider: LocalDataProvider, row: number, count: number) => void;
    /**
     * 다수의 데이터 행이 변경되었음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListUpdated = function (provider, rows) {
     *      console.log("DataProvider rows updated: " + rows.join(', '));
     * };
     * ```
     */
    onRowListUpdated: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 행 추가를 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 추가되기 직전에 호출하여 행의 추가 여부를 확인한다. 행의 수정이 완료된 후 {@link LocalDataProvider.onRowInserted | onRowInserted }가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가될 데이터 행의 인덱스
     *
     * `values` - 추가될 데이터 값, {@link DataValues} 형식
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 추가를 완료하고 `false`이면 행의 추가를 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowInserting = function (provider, row, values) {
     *      if (row > 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowInserting: (provider: LocalDataProvider, row: number, values: DataValues) => boolean;
    /**
     * 데이터 행이 추가되었을을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowInserting | onRowInserting} 콜백에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowInserted = function (provider, row) {
     *      console.log("DataProvider row inserted!");
     * };
     * ```
     */
    onRowInserted: (provider: LocalDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행이 일괄 추가되었을 때 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.insertRows} 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 변경된 시작 데이터 행의 인덱스
     *
     * `count` - 변경된 행의 건수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsInserted = function (provider, row, count) {
     *      console.log("DataProvider " + count + " rows inserted!");
     * };
     * ```
     */
    onRowsInserted: (provider: LocalDataProvider, row: number, count: number) => void;
    /**
     * 데이터 행의 삭제를 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 삭제되기 직전에 호출하여 행의 삭제 여부를 확인한다. 행의 삭제가 완료된 후 {@link LocalDataProvider.onRowDeleted | onRowDeleted} 가 발생한다.
     *
     * 이벤트에 함수가 바인딩되지 않은 경우 기본으로 `true`를 반환한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 추가될 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 삭제를 완료하고 `false`이면 행의 삭제를 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowDeleting = function (provider, row) {
     *      if (row < 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowDeleting: (provider: LocalDataProvider, row: number) => boolean;
    /**
     * 데이터 행이 삭제되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowDeleting | onRowDeleting} 콜백 함수에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 삭제된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowDeleted = function (provider, row) {
     *      console.log('dataProvider row deleted: ' + row);
     * };
     * ```
     */
    onRowDeleted: (provider: LocalDataProvider, row: number) => void;
    /**
     * 데이터 행이 삭제되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowDeleting | onRowDeleting} 콜백 함수에서 `true`가 반환되어 행이 추가된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 삭제된 데이터 행의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsDeleted = function (provider, rows) {
     *      console.log('DataProvider rows deleted: ' + rows.join(', '));
     * };
     * ```
     */
    onRowsDeleted: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다. 행의 이동이 완료된 후 {@link LocalDataProvider.onRowMoved | onRowMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 데이터 행의 원래의 인덱스
     *
     * `newRow` - 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행의 이동을 완료하고 `false`이면 행의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowMoving = function (provider, row, newRow) {
     *      if (row < newRow) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowMoving: (provider: LocalDataProvider, row: number, newRow: number) => boolean;
    /**
     * 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowMoving | onRowMoving } 콜백 함수에서 `true`가 반환되어 행이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 데이터 행의 원래의 인덱스
     *
     * `newRow` - 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowMoved = function (provider, row, newRow) {
     *      console.log('DataProvider row moved from ' + row + ' to ' + newRow);
     * };
     * ```
     */
    onRowMoved: (provider: LocalDataProvider, row: number, newRow: number) => void;
    /**
     * 복수의 데이터 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 복수의 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다.행들의 이동이 완료된 후 {@link LocalDataProvider.onRowsMoved | onRowsMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 첫 데이터 행의 원래의 인덱스
     *
     * `count` - 이동할 데이터 행의 건수
     *
     * `newRow` - 첫 데이터 행의 이동 후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행들의 이동을 완료하고 `false`이면 행들의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsMoving = function (provider, row, count, newRow) {
     *      if (row < newRow || count > 20) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsMoving: (provider: LocalDataProvider, row: number, count: number, newRow: number) => boolean;
    /**
     * 복수의 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowsMoving | onRowsMoving} 콜백 함수에서 `true`가 반환되어 행들이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 첫 데이터 행의 원래의 인덱스
     *
     * `count` - 이동할 데이터 행의 건수
     *
     * `newRow` - 첫 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowsMoved = function (provider, row, count, newRow) {
     *      console.log('DataProvider ' + count + ' rows moved!');
     * };
     * ```
     */
    onRowsMoved: (provider: LocalDataProvider, row: number, count: number, newRow: number) => void;
    /**
     * 마우스를 이용한 행의 이동을 결정하는 콜백
     *
     * @remarks
     * 복수의 데이터 행이 이동 되기 직전에 호출하여 행의 이동 여부를 결정한다.행들의 이동이 완료된 후 {@link LocalDataProvider.onRowListMoved | onRowListMoved} 가 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 이동되는 행 인덱스의 배열
     *
     * `newRow` - 첫 데이터 행의 이동 후의 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `true`이면 행들의 이동을 완료하고 `false`이면 행들의 이동을 취소한다.
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListMoving = function (provider, rows, newRow) {
     *      return rows.length === 1)
     * };
     * ```
     */
    onRowListMoving: (provider: LocalDataProvider, rows: number[], newRow: number) => boolean;
    /**
     * 복수의 데이터 행이 이동되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.onRowListMoving | onRowListMoving} 콜백 함수에서 `true`가 반환되어 행들이 이동된 후 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 이동된 행 인덱스의 배열
     *
     * `newRow` - 첫 데이터 행의 이동후의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowListMoved = function (provider, rows, newRow) {
     *      console.log('DataProvider ' + rows.length + ' rows moved!');
     * };
     * ```
     */
    onRowListMoved: (provider: LocalDataProvider, rows: number[], newRow: number) => void;
    /**
     * 데이터 셀의 값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.setValue | setValue()} 를 이용하여 데이터를 변경할 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 값이 변경된 행의 인덱스
     *
     * `field` - 값이 변경된 필드의 인덱스
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onValueChanged = function (provider, row, field) {
     *      console.log('DataProvider row Value changed at ' + row + ' on ' + field);
     * };
     * ```
     */
    onValueChanged: (provider: LocalDataProvider, row: number, field: number) => void;
    /**
     * 데이터 셋의 값이 변경되었었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.setValue | setValue()} 함수나 View에서의 입력으로 값이 바뀔 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * @eventProperty
     * @example
     * ```js
     * dataProvider.onDataChanged = function (provider) {
     *      console.log('dataChanged!');
     * };
     * ```
     */
    onDataChanged: (provider: LocalDataProvider) => void;
    /**
     * 데이터 행의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 데이터행의 상태가 변경되는 경우 발생, 단 행 추가시에는 상태가 변경되었다 할 수 없으므로 예외로 한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `row` - 상태가 변경된 데이터 행의 인덱스
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStateChanged = function (provider, row) {
     *      console.log('dataProvider row state changed: ' + row);
     * };
     * ```
     */
    onRowStateChanged: (provider: LocalDataProvider, row: number) => void;
    /**
     * 복수의 데이터 행의 상태가 일괄 변경되었음을 알리는 콜백
     *
     * @remarks
     * 복수의 데이터행의 상태가 일괄 변경되는 경우 발생, 단 행 추가시에는 상태가 변경되었다 할 수 없으므로 예외로 한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 상태가 변경된 데이터 행들의 인덱스 배열
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStatesChanged = function (provider, rows) {
     *      console.log('dataProvider row state changed: ' + rows.join(','));
     * };
     * ```
     */
    onRowStatesChanged: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 모든 행의 상태가 초기회 되었음을 알리는 콜백
     *
     * @remarks
     * {@link DataProviderBase.clearRowStates} 를 통해 행의 상태가 모두 초기화 한 후에 발생
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRowStatesCleared = function (provider) {
     *      console.log('dataProvider row state cleared!');
     * };
     * ```
     */
    onRowStatesCleared: (provider: LocalDataProvider) => void;
    /**
     * 복수의 데이터 행의 상태가 복원되었음을 알리는 콜백
     *
     * @remarks
     * {@link DataProviderBase.restoreUpdatedRows | restoreUpdatedRows() } 함수를 통해 수정된 행들이 복원 되었을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 복원된 데이터 행들의 인덱스 배열
     *
     * @eventProperty
     *
     * @example
     * ```js
     * dataProvider.onRestoreRows = function (provider, rows) {
     *      console.log('dataProvider row restored: ' + rows.join(', '));
     * };
     * ```
     */
    onRestoreRows: (provider: LocalDataProvider, rows: number[]) => void;
    /**
     * 데이터 셋의 데이터 건수를 반환한다.
     *
     * @example
     * ```js
     * let rowCount = ds.getRowCount();
     * ```
     */
    getRowCount(): number;
    /**
     * 데이터 셋의 데이터 건수를 설정하다.
     *
     * @remarks
     * 데이터 셋의 데이터 건수를 강제로 설정한다. 기존의 건수가 새로운 건수보다 많을 경우 잘려서 버려지고 새로운 건수가 많을 경우 새로운 행이 추가된다.
     *
     * @param newCount - 새로운 데이터 건수
     * @param fillFieldDefaults - 새로운 행이 추가될때 필드의 기본값을 사용하여 값을 넣을지의 여부, 기본값: `false`
     * @param defaultValues - 새로운 행이 추가될때 각각의 필드에 해당하는 값들, 기본값: `null`, 필드순서대로 사용한다.
     * @param rowState - 새로운 행의 상태, 기본값: {@link RowState.NONE}
     *
     * @example
     * ```js
     * ds.setRowCount(100);
     * ```
     */
    setRowCount(newCount: number, fillFieldDefaults?: boolean, defaultValues?: DataValues, rowState?: RowState): void;
    /**
     * 필터간의 연산조건을 설정한다.
     *
     * @remarks
     * 필터들의 연산 조건을 AND 또는 OR로 설정한다
     * {@link LocalDataProvider.setFilters | setFilters }에서 filterMode 지정하는것과 동일한 기능이다
     *
     * @param filterMode - 필터들의 연산 조건. `'and'`또는 `'or'`
     */
    setFilterMode(filterMode?: string): void;
    /**
     * 데이터 셋에서 데이터를 필터링한다.
     *
     * @remarks
     * DataProvider에 필터를 적용한다. 필터에 부합하지 않은 행은 DataProvider에 존재하지 않게 된다.
     *
     * @param filters - 필터 설정 값
     * @param filterMode - 필터들의 연산 조건. `'and'`또는 `'or'` 다.
     * @example
     * ```js
     * // nonArray
     * dataProvider.setFilters({criteria: "value['field1']='가수'"});
     *
     * // string
     * dataProvider.setFilters([
     *   "value['field1']='가수'",
     *   "value['field2']='여자'"
     * ], "and");
     *
     * // object
     * dataProvider.setFilters([
     *   {criteria: "value['field1']='가수'"},
     *   {criteria: "value['field2']='여자'"}
     * ], "and");
     * ```
     */
    setFilters(filters: DataFilters, filterMode?: string): void;
    /**
     * JSON 데이터 원본에서 데이터를 가져와 데이터 셋을 생성한다.
     *
     * @param data - 데이터 원본, JSON 문자열 또는 오브젝트의 배열
     * @param options - 데이터 추출및 채우는 방식 설정, {@link DataFillOptions} 또는 DataFillOptions 객체, `null`이면 기본값으로 동작
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillJsonData([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }], options);
     * ```
     */
    fillJsonData(data: any, options: DataFillOptions): void;
    /**
     * XML 데이터 원본에서 문자열을 파싱하여 데이터 셋을 생성한다.
     *
     * @param data - XML 문자열
     * @param options - 데이터 추출및 채우는 방식 설정,  {@link DataFillOptions} 객체 또는 DataFillOptions와 동일 구조의 object
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillXmlData(data, options);
     * ```
     */
    fillXmlData(data: any, options: DataFillOptions): void;
    /**
     * CSV 데이터 원본에서 문자열을 파싱하여 데이터 셋을 생성한다.
     *
     * @param data - CSV 문자열
     * @param options - 데이터 추출및 채우는 방식 설정,  {@link DataFillOptions} 객체 또는 DataFillOptions와 동일 구조의 object
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillCsvData(data, options);
     * ```
     */
    fillCsvData(data: any, options: DataFillOptions): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋을 채운다.
     *
     * @param rows - 데이터 원본, 2차원 배열 또는 오브젝트의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 채운다. 기본값: `-1`
     * @example
     * ```js
     * dataProvider.setRows([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }]);
     * ```
     */
    setRows(rows: DataValues[], start?: number, count?: number): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋에 추가한다.
     *
     * @param rows - 데이터 원본, 2차원 배열 또는 오브젝트의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값 `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 추가된다, 기본값: `-1`
     * @param rowEvents - 이벤트를 일괄 발생할지의 여부, 기본값: `false`
     * @example
     * ```js
     * dataProvider.addRows([
     *  {
     *    FieldA: 'GHI',
     *    FieldB: 15
     *  }, {
     *    FieldA: 'KLM',
     *    FieldB: 31
     *  }]);
     * ```
     */
    addRows(rows: DataValues[], start?: number, count?: number, rowEvents?: boolean): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋의 특정 위치에 삽입한다.
     *
     * @param row - 삽입할 데이터 행의 인덱스
     * @param rows - 데이터 원본, 2차원 배열 또는 Object의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, -1이면 데이터 원본의 건수만큼 삽입된다. 기본값: `-1`
     * @param rowEvents - 이벤트를 일괄 발생할지의 여부, 기본값: `false`
     * @example
     * ```js
     * dataProvider.insertRows(10, [
     *  {
     *    FieldA: 'OPQ',
     *    FieldB: 34
     *  }, {
     *    FieldA: 'RST',
     *    FieldB: 27
     *  }]);
     * ```
     */
    insertRows(row: number, rows: DataValues[], start?: number, count?: number, rowEvents?: boolean): void;
    /**
     * 데이터 원본에서 가져와 데이터 셋의 특정 위치에 변경한다.
     *
     * @param row - 변경할 데이터 행의 인덱스
     * @param rows - 데이터 원본, 2차원 배열 또는 Object의 배열
     * @param start - 데이터 셋에 채울 데이터의 시작 행, 기본값: `0`
     * @param count - 데이터 셋에 채울 데이터 건수, `-1`이면 데이터 원본의 건수만큼 변경된다, 기본값: `-1`
     * @param strict - textField의 값이 `null`, `undefined` `""`인경우 변경여부 `false`이면 동일한 값으로 판단하여 변경하지 않는다.
     * @param rowEvents - `true`이면 행별로 {@link LocalDataProvider.onRowUpdated | onRowUpdated}를 호출한다. `false`이면 {@link LocalDataProvider.onRowsUpdated | onRowsUpdated}를 호출한다.
     * @example
     * ```js
     * dataProvider.updateRows(10, [
     *  {
     *    FieldA: 'OPQ',
     *    FieldB: 34
     *  }, {
     *    FieldA: 'RST',
     *    FieldB: 27
     *  }]);
     * ```
     */
    updateRows(row: number, rows: DataValues[], start?: number, count?: number, strict?: boolean, rowEvents?: boolean): void;
    /**
     * 연속적이지 않은 행을 일괄 수정한다.
     * @param rows - 데이터 원본 &#123;1:&#123;"field1":value, "field2":value2&#125;, ...&#125;
     * @param strict - textField의 값이 `null`, `undefined` `""`인경우 변경여부 `false`이면 동일한 값으로 판단하여 변경하지 않는다.
     * @param rowEvents - `true`이면 행별로 {@link LocalDataProvider.onRowUpdated | onRowUpdated}를 호출한다. `false`이면 {@link LocalDataProvider.onRowListUpdated | onRowListUpdated}를 호출한다.
     *
     * @example
     * ```js
     * var data = {
     *      1:{"field1":value1, "field2":value2},
     *      3:{"field1":value1, "field2":value2}
     * }
     * dataProvider.updateRowsByDataRow(data);
     * ```
     */
    updateRowsByDataRow(rows: {
        [key: number]: DataValues;
    }, strict?: boolean, rowEvents?: boolean): void;
    /**
     * 데이터 셋을 초기화한다
     *
     * @example
     * ```js
     * dataProvider.clearRows();
     * ```
     */
    clearRows(): void;
    /**
     * 데이터 셋의 특정 데이터 행의 값을 변경한다.
     *
     * @param row - 변경할 데이터 행의 인덱스
     * @param values - 행의 변경할 데이터, 필드 인덱스 순서대로 배열에서 가져온다
     * @param strict - 값이 `undefined` 이거나 명시되지 않은 필드는 기존의 값을 유지한다
     *
     * @example
     * ```js
     * dataProvider.updateRow(3, ['value1', 'value2', 'value3', 'value4'], true);
     * ```
     */
    updateRow(row: number, values: DataValues, strict: boolean): void;
    /**
     * 특정 행들을 View에게 감출 때 사용한다.
     * @remarks
     * 숨겨진 상태에서 데이터 셋의 추가, 삭제가 발생하는 경우 인덱스가 변경되므로 주의를 요한다.
     * @param dataRows - 감출 데이터 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * // single
     * dataProvider.hideRows(3);
     *
     * //multiple
     * dataProvider.hideRows([3,2,1]);
     * ```
     */
    hideRows(dataRows: number[] | number): void;
    /**
     * 감춰진 데이터행을 다시 표시한다.
     *
     * @param dataRows - 다시 표시할 데이터 행의 인덱스 또는 인덱스 배열
     *
     * @example
     * ```js
     * // single
     * dataProvider.showHiddenRows(3);
     *
     * //multiple
     * dataProvider.showHiddenRows([3,2,1]);
     * ```
     */
    showHiddenRows(dataRows: number[] | number): void;
    /**
     * 감춰진 데이터행들의 인덱스을 반환한다.
     *
     * @example
     * ```js
     * let hiddens = dataProvider.getHiddenRows();
     * ```
     */
    getHiddenRows(): number[];
    /**
     * 특정 행이 감춰줘있는지의 여부를 반환한다.
     *
     * @param dataRow - 확인할 데이터 행의 인덱스
     *
     * @example
     * ```js
     * let isHidden = dataProvider.isHiddenRow(3);
     * ```
     */
    isHiddenRow(dataRow: number): boolean;
    /**
     * 모든 행의 감춰진 상태를 초기환한다.
     *
     * @example
     * ```js
     * dataProvider.resetHiddenRows();
     * ```
     */
    resetHiddenRows(): void;
    /** @deprecated */
    /**
     * 데이터 행을 추가한다
     *
     * @param values - 추가할 행의 값, 배열 또는 Object
     * @returns 추가된 행의 dataRow 실패한경우 -1이 return된다.
     *
     * @example
     * ```js
     * dataProvider.addRow({
     *    FieldA: 'GHI',
     *    FieldB: 15
     * });
     * ```
     */
    addRow(values: DataValues): number;
    /**
     * 특정 위치에 데이터 행을 삽입한다
     *
     * @param row - 삽입할 데이터 행의 인덱스
     * @param values - 삽입할 행의 값, 배열 또는 오브젝트
     *
     * @example
     * ```js
     * dataProvider.insertRow(4, {
     *    FieldA: 'DNA',
     *    FieldB: 15
     * });
     * ```
     */
    insertRow(row: number, values: DataValues): boolean;
    /**
     * 특정 위치의 데이터 행을 제거한다
     *
     * @param row - 제거할 데이터 행의 인덱스
     *
     * @example
     * ```js
     * dataProvider.removeRow(2);
     * ```
     */
    removeRow(row: number): void;
    /**
     * 특정 위치의 복수의 데이터 행들을 제거한다.
     *
     * @param rows - 제거할 데이터 행 인덱스의 배열
     * @param rowEvents - 개별 이벤트 발생 여부, 기본값: `false`
     *
     * @example
     * ```js
     * dataProvider.removeRows([2,3,4]);
     * ```
     */
    removeRows(rows: number[], rowEvents?: boolean): void;
    /**
     * 특정 데이터 행을 이동한다
     *
     * @param rows - 이동할 데이터 행 인덱스
     * @param newRow - 새로운 인덱스
     *
     * @example
     * ```js
     * dataProvider.moveRow(2, 5);
     * ```
     */
    moveRow(row: number, newRow: number): void;
    /**
     * 복수의 데이터 행들을 이동한다.
     *
     * @param row - 이동할 데이터 행들 중 첫 행의 인덱스
     * @param count - 이동할 데이터 행의 건수
     * @param newRow - 이동될 행의 인덱스
     * @example
     * ```js
     * dataProvider.moveRows(2, 2, 5);
     * ```
     */
    moveRows(row: number, count: number, newRow: number): void;
    /**
     * 특정 데이터 행의 특정 필드의 값을 반환한다.
     *
     * @param row - 값을 가져올 데이터 행의 인덱스
     * @param field - 값을 가져올 필드의 인덱스 또는 필드명
     *
     * @example
     * ```js
     * let val = dataProvider.getValue(2, 10);
     * ```
     */
    getValue(row: number, field: number | string): any;
    /**
     * 특정 데이터 행의 특정 필드의 값을 변경한다.
     *
     * @param row - 값을 변경할 데이터 행의 인덱스
     * @param field - 값을 변경할 필드의 인덱스 또는 필드명
     * @param newValue - 변경할 새로운 값
     *
     * @example
     * ```js
     * dataProvider.setValue(2, 5, 'newValue');
     * ```
     */
    setValue(row: number, field: number | string, newValue: any): void;
    /**
     * 데이터 셋의 특정 구간의 데이터를 2차원 배열로 반환한다.
     *
     * @param startRow - 시작 데이터 행의 인덱스 0이면 시작, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, `-1`이면 데이터 셋의 끝까지, 기본값: `-1`
     *
     * @example
     * ```js
     * let rows = dataProvider.getRows();
     * ```
     */
    getRows(startRow?: number, endRow?: number): RowValues[][];
    /**
     * @public
     * 지정한 데이터 행의 값을 Object 형태로 변환한다.
     *
     * @param row - 행 고유번호
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     *
     * @returns 행의 값을 json 형태로 반환한다.
     *
     * @example
     * ```js
     * let jsonRow = ds.getJsonRow(5);
     * ```
     */
    getJsonRow(row: number, rowState: boolean): RowObject;
    /**
     * 데이터 셋의 특정 구간의 데이터를 Object 배열로 반환한다.
     *
     * @param startRow - 시작 데이터 행의 인덱스, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, -1이면 데이터 셋의 끝까지
     * @param rowState - `true`이면 결과 값에 행의 상태값을 추가한다.
     *
     * @example
     * ```js
     * let rows = dataProvider.getJsonRows();
     * ```
     */
    getJsonRows(startRow: number, endRow: number, rowState: boolean): object[];
    /**
     * 데이터 셋의 특정 데이터 행을 설정에 따라 Object로 반환한다.
     *
     * @param options - 데이터를 반환내는 방식 설정, {@link DataOutputOptions} 과 동일
     * @param row - 데이터 행의 인덱스
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRow(opt, 4);
     * ```
     */
    getOutputRow(options: DataOutputOptions, row: number): object;
    /**
     * 데이터 셋의 특정 구간의 데이터를 설정에 따라 Object 배열로 반환한다.
     *
     * @param options - 데이터를 반환내는 방식 설정,  {@link DataOutputOptions} 과 동일
     * @param startRow - 시작 데이터 행의 인덱스, 기본값: `0`
     * @param endRow - 끝 데이터 행의 인덱스, -1이면 데이터 셋의 끝까지, 기본값: `-1`
     *
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let rows = dataProvider.getOutputRows(opt, 4, 10);
     * ```
     */
    getOutputRows(options: DataOutputOptions, startRow?: number, endRow?: number): object[];
    /**
     * 데이터 셋의 특정 필드에 해당하는 특정 구간의 데이터를 반환한다.
     *
     * @param filed - 필드의 인덱스 또는 필드명
     * @param startRow - 시작 행의 인덱스, 기본값: `0`
     * @param endRow - 마지막 행의 인덱스, -1이면 데이터 셋의 끝까지, 기본값: `-1`
     */
    getFieldValues(field: number | string, startRow?: number, endRow?: number): any[];
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 행을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchOptions} 모델로 지정한다.
     * @returns 찾은 행의 인덱스
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value']});
     * ```
     */
    searchDataRow(options: SearchOptions): number;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 셀을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchCellOptions} 모델로 지정한다.
     * @returns 찾은 셀의 정보, {@link SearchCellResult} 모델이다.
     *
     * @example
     * ```js
     * ds.searchData({fields:['fieldName'], value: 'value'});
     * ```
     */
    searchData(options: SearchCellOptions): SearchCellResult;
    /**
     * @internal
     */
    protected _createProvider(undoable: boolean): LocalDataProvider$1;
    /**
     * @internal
     */
    protected _createListener(provider: LocalDataProvider$1): GridProviderListener;
}
/**
 * @public
 * LocalTreeDataProvider 클래스. {@link DataProviderBase} 를 상속한다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link DataProviderBase}
 */
declare class LocalTreeDataProvider extends DataProviderBase {
    /**
     * @internal
     */
    protected _dp: LocalTreeDataProvider$1;
    constructor(undoable?: boolean);
    /**
     * @internal
     */
    dispose(): void;
    /**
     * 행의 갯수가 변경되었음을 알리는 콜백
     *
     * @remarks
     * 행 추가 및 삭제 등으로 행의 개수가 변경됐을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `newCount` - 변경된 행의 갯수
     *
     * @example
     * ```js
     * dataProvider.onRowCountChanged = function (provider, count) {
     *     console.log("DataProvider rowCount changed as: " + newCount);
     * };
     * ```
     */
    onRowCountChanged: (provider: LocalTreeDataProvider, newCount: number) => void;
    /**
     * 행이 추가됨을 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가되기 직전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * `index` - 부모 행의 자식들 중 삽입된 행의 위치(순서)
     *
     * `child` - 추가 된 행의 자식 데이터
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, 명시적으로 `false`를 리턴하면 행이 삽입되지 않는다.
     *
     * @example
     * ```js
     * dataProvider.onRowAdding = function (provider, row, index, child) {
     *      if (row > 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowAdding: (provider: LocalTreeDataProvider, row: number, index: number, child: any) => boolean;
    /**
     * 행이 추가되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowAdded = function (provider, row) {
     *      console.log("DataProvider row added at "+ row);
     * };
     * ```
     */
    onRowAdded: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 행들이 추가되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 추가된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `parent` - 부모의 id
     *
     * `rows` - 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsAdded = function (provider, parent, rows) {
     *      console.log("DataProvider row added at " + parent + " as " + rows.join(", "));
     * };
     * ```
     */
    onRowsAdded: (provider: LocalTreeDataProvider, parent: number, rows: number[]) => void;
    /**
     * 행 삭제를 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 삭제되기 전 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * [반환값] - - 기본값: `true`, 삭제하려면 `true`, 삭제를 취소하려면 `false` 를 반환한다.
     *
     * @example
     * ```js
     * dataProvider.onRowDeleting = function (provider, row) {
     *      if (row < 100) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowDeleting: (provider: LocalTreeDataProvider, row: number) => boolean;
    /**
     * 행 삭제가 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 삭제된 후 호출한다.
     *
     * softDeleting = true 일 경우 Row의 State가 Deleted로 변경된 것 만으로는 호출되지 않는다.
     *
     * 완전히 TreeDataProvider에서 삭제되었을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowDeleted = function (provider, row) {
     *      console.log('dataProvider row deleted ' + row);
     * };
     * ```
     */
    onRowDeleted: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 행들이 삭제가 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터 행들이 삭제된 후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsDeleted = function (provider, rows) {
     *      console.log('DataProvider rows deleted: ' + rows.join(', '));
     * };
     * ```
     */
    onRowsDeleted: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 행 수정을 결정하는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 수정되기 전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false` 를 반환하면 수정이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowUpdating = function (provider, row) {
     *      if(row % 2 === 0) {
     *          console.log("DataProvider row updated: " + row);
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowUpdating: (provider: LocalTreeDataProvider, row: number) => boolean;
    /**
     * 행 수정이 되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에 데이터가 수정되기 전에 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowUpdated = function (provider, row) {
     *      console.log("DataProvider row updated: " + row);
     * };
     * ```
     */
    onRowUpdated: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 다수의 데이터 행 변경을 결정하는 콜백
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경될 데이터 행들의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdating = function (provider, rows) {
     *      if (rows.length > 10) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsUpdating: (provider: LocalTreeDataProvider, rows: number[]) => boolean;
    /**
     * 다수의 데이터 행이 변경되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalDataProvider.updateRows | updateRows } 등의 함수에서 이벤트 일괄 반영되도록 했을 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - DataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 트리 id들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsUpdated = function (provider, rows) {
     *      console.log("DataProvider rows updated: " + rows.join(', '));
     * };
     * ```
     */
    onRowsUpdated: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 데이터의 값이 변경 되었음을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.setValue} 를 이용하여 데이터를 변경한후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 값이 변경된 데이터 행의 트리 id.
     *
     * `field` - 필드의 인덱스.
     *
     * @defaultValue `null`
     * @example
     * ```js
     * dataProvider.onValueChanged = function (provider, row, field) {
     *      console.log('DataProvider row Value changed at ' + row + ' on ' + field);
     * };
     * ```
     */
    onValueChanged: (provider: LocalTreeDataProvider, row: number, field: number) => void;
    /**
     * 데이터가 변경 되었음을 알리는 콜백
     *
     * @remarks
     * key 입력이나  {@link LocalTreeDataProvider.setValue} 를 이용하여 데이터를 변경한후 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onDataChanged = function (provider) {
     *      console.log('dataChanged!');
     * };
     * ```
     */
    onDataChanged: (provider: LocalTreeDataProvider) => void;
    /**
     * 행 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider의 데이터행의 rowState가 변경된 뒤 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 변경된 데이터 행의 트리 id
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowStateChanged = function (provider, row) {
     *      console.log('dataProvider row state changed: ' + row);
     * };
     * ```
     */
    onRowStateChanged: (provider: LocalTreeDataProvider, row: number) => void;
    /**
     * 여러 행들의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     * TreeDataProvider에서 여러 건의 데이터행의 rowState가 변경된 뒤 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 변경된 데이터 행들의 트리 id 들
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowStatesChanged = function (provider, rows) {
     *      console.log('dataProvider row state changed: ' + rows.join(','));
     * };
     * ```
     */
    onRowStatesChanged: (provider: LocalTreeDataProvider, rows: number[]) => void;
    /**
     * 행 들의 형제 간 이동을 결정하는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.moveRowSibling} 함수를 사용하여 형제 간 위치를 바꾸려고 할때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동하려는 데이터 행의 트리 id
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowSiblingMoving = function (provider, row, offset) {
     *      if (row % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowSiblingMoving: (provider: LocalTreeDataProvider, row: number, offset: number) => boolean;
    /**
     * 행 들의 형제 간 이동했음을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.moveRowSibling} 함수를 사용하여 형제 간 위치가 바뀌었을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동한 데이터 행의 트리 id
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowSiblingMoved = function (provider, row, offset) {
     *      console.log('sibling row moved on: ' + row);
     * };
     * ```
     */
    onRowSiblingMoved: (provider: LocalTreeDataProvider, row: number, offset: number) => void;
    /**
     * DragAndDrop을 이용한 형제 간 이동을 결정하는 콜백
     *
     * @remarks
     * 마우스 dragAndDrop을 사용하여 형제 간 위치를 바꾸려고 할때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 이동하려는 데이터 행의 트리 id 배열
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     * [반환값] - 기본값: `true`, `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowsSiblingMoving = function (provider, rows, offset) {
     *      if (rows.length > 1) {
     *          return false;
     *      }
     *      return true;
     * };
     * ```
     */
    onRowsSiblingMoving: (provider: LocalTreeDataProvider, rows: number[], offset: number) => boolean;
    /**
     * dragAndDrop을 이용해서 형제 간 이동했음을 알리는 콜백
     *
     * @remarks
     * 마우스 dragAndDrop을 사용하여 형제 간 위치가 바뀌었을 때 호출한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `rows` - 이동한 데이터 행의 트리 id 배열
     *
     * `offset` - 상하 위치 단계 값
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowsSiblingMoved = function (provider, rows, offset) {
     *      console.log('sibling rows moved on: ' + rows);
     * };
     * ```
     */
    onRowsSiblingMoved: (provider: LocalTreeDataProvider, rows: number[], offset: number) => void;
    /**
     * 행의 부모를 바꾸는 것을 결정하는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.changeRowParent} 함수를 사용하여 부모를 바꾸려고 할때 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동하려는 데이터 행의 트리 id
     *
     * `parent` - 이동하려는 곳의 부모 아이템
     *
     * `index` - 이동하려는 부모의 위치 인덱스
     *
     * @defaultValue `null`
     * [반환값] - `false`를 반환하면 이동이 취소된다.
     *
     * @example
     * ```js
     * dataProvider.onRowParentChanging = function (provider, row, parent, index) {
     *      if (row % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onRowParentChanging: (provider: LocalTreeDataProvider, row: number, parent: number, index: number) => boolean;
    /**
     * 행의 부모가 바뀐 것을 알리는 콜백
     *
     * @remarks
     * {@link LocalTreeDataProvider.changeRowParent} 함수를 사용하여 부모가 바뀐 후에 발생한다.
     *
     * [매개변수 목록]
     *
     * `provider` - TreeDataProvider 컨트롤
     *
     * `row` - 이동한 데이터 행의 트리 id
     *
     * `parent` - 이동한 곳의 부모 아이템
     *
     * `index` - 이동한 부모의 위치 index
     *
     * @defaultValue `null`
     *
     * @example
     * ```js
     * dataProvider.onRowParentChanged = function (provider, row, parent, index) {
     *      console.log('parent row changed to ' + parent);
     * };
     * ```
     */
    onRowParentChanged: (provider: LocalTreeDataProvider, row: number, parent: number, index: number) => void;
    /**
     * 저장 된 데이터행의 갯수를 반환한다.
     *
     * @remarks
     * 루트의 하위에 저장되어있는 모든 아이템의 갯수를 반환한다.
     *
     * @example
     * ```js
     * let rowCount = ds.getRowCount();
     * ```
     */
    getRowCount(): number;
    /**
     * 트리의 데이터를 새로운 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 배열의 배열을 데이터 행들로 추가한다.
     *
     * @param rows - 설정할 데이터
     * @param treeField - 필드 명
     * @param needSortnig - 정렬 여부
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드, 자식의 필드 명
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * dataProvider.setRows([{
     *          'uno', 1, 'one', 'ichi', 'ee', 'I'
     *      }, {
     *          'dos', 2, 'two', 'ni', 'er', 'II'
     *      }
     * ], 'number', false, '', 'icon');
     * ```
     */
    setRows(rows: DataValues[], treeField: string, needSorting: boolean, childrenField: string, iconField: string): void;
    /**
     * 트리의 데이터를 새로운 CSV 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 CSV를 데이터 행들로 추가한다.
     *
     * @param rows - 설정할 데이터
     * @param treeField - 필드 명
     * @param needSortnig - 정렬 여부
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드, 자식의 필드 명.
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * let rows = `Username; Identifier;First name;Last name
     * booker12;9012;Rachel;Booker
     * grey07;2070;Laura;Grey
     * johnson81;4081;Craig;Johnson
     * jenkins46;9346;Mary;Jenkins
     * smith79;5079;Jamie;Smith
     * `
     * dataProvider.setCsvRows(rows, 'number', false, '', 'icon');
     * ```
     */
    setCsvRows(rows: string, treeField: string, needSorting: boolean, childrenField: string, iconField: string): void;
    /**
     * 트리의 데이터를 새로운 XML 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 XML을 데이터 행들로 추가한다.
     * rowElement에 "row"를 입력하면 루트의 row element가 사용될 것이고,
     * rowElement에 "row[0].row"를 입력하면 루트의 첫번째 행이 사용될 것이다.
     * "row.row"는 "row[0].row"와 같다.
     *
     * @param xml - 설정할 데이터
     * @param rowElement - XML 중 트리의 데이터 행들로 사용될 element의 이름
     * @param childrenField - 자식 행이 있는 지를 지시하는 필드, 자식의 필드 명
     * @param iconField - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 필드 이름
     *
     * @example
     * ```js
     * dataProvider.setXmlRows(rows, 'number', false, '', 'icon');
     * ```
     */
    setXmlRows(xml: any, rowElement: string, childrenField: string, iconField: string): void;
    /**
     * 트리의 데이터를 새로운 JSON 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 JSON 객체를 데이터 행들로 추가한다.
     *
     * @param json - 설정할 데이터. Json 배열이거나 Json 배열을 속성으로 갖는 object. Json 배열이 아닌 경우 rowsProp에 지정된 속성을 배열로 지정해야 한다.
     * @param rowsProp - Json 중 트리의 데이터 행들로 사용될 배열을 값으로 하는 속성명
     * @param childrenProp - 자식 행이 있는 지를 지시하는 속성 이름. 해당 속성의 값이 자식의 필드 이름과 같아야한다.
     * @param iconProp - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 속성명
     *
     * @example
     * ```js
     * dataProvider.setObjectRows(rows, 'rowsProp', 'childField', 'iconField');
     * ```
     */
    setObjectRows(json: any, rowsProp: string, childrenProp: string, iconProp: string): void;
    /**
     * 트리의 데이터를 새로운 JSON 데이터로 설정한다.
     *
     * @remarks
     * 트리의 기존 데이터행들을 모두 삭제하고 매개변수로 전달되는 JSON 객체를 데이터 행들로 추가한다.
     * {@link LocalTreeDataProvider.setObjectRows}와 다른점은 childrenProp와 iconProp가 field에 등록되어있지 않아도 된다.
     *
     * @param json - 설정할 데이터. Json 배열이거나 Json 배열을 속성으로 갖는 object. Json 배열이 아닌 경우 rowsProp에 지정된 속성을 배열로 지정해야 한다.
     * @param rowsProp - Json 중 트리의 데이터 행들로 사용될 배열의 속성명
     * @param childRowsProp - 1 레벨의 배열명과 하위 레벨의 배열명이 다른경우 하위 레벨의 배열 속성명
     * @param childrenProp - 자식 행이 있는 지를 지시하는 속성명.
     * @param iconProp - 트리 노드에 표시할 아이콘 경로를 값으로 가지고 있는 속성명
     *
     * @example
     * ```js
     * dataProvider.setNestedRows(rows, 'rowsProp', 'childRowsProp', 'childrenProp", 'iconProp');
     * ```
     */
    setNestedRows(json: any, rowsProp: string, childRowsProp: string, childrenProp: string, iconProp: string): void;
    /**
     * 지정한 설정에 따라 Json 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - json 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillJsonData([
     *  {
     *    FieldA: 'ABC',
     *    FieldB: 10
     *  }, {
     *    FieldA: 'DEF',
     *    FieldB: 30
     *  }], options);
     * ```
     */
    fillJsonData(data: any, options: DataFillOptions): void;
    /**
     * 지정한 설정에 따라 xml 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - xml 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillXmlData(data, options);
     * ```
     */
    fillXmlData(data: any, options: DataFillOptions): void;
    /**
     * 지정한 설정에 따라 csv 데이터를 로드하여 TreeDataProvider 로컬 저장소에 저장한다.
     *
     * @param data - csv 형태의 데이터
     * @param options - {@link DataFillOptions} 와 같은 모델의 설정 정보
     *
     * @example
     * ```js
     * let options = {
     *      start: 1,
     *      count: 3
     * }
     *
     * dataProvider.fillCsvData(data, options);
     * ```
     */
    fillCsvData(data: any, options: DataFillOptions): void;
    /**
     * 트리 행에 표시된 아이콘 인덱스를 반환한다.
     *
     * @param row - 데이터 행의 트리 id
     *
     * @example
     * ```js
     * let iconIndex = treeProvider.getIconIndex(4);
     * ```
     */
    getIconIndex(row: number): number;
    /**
     * 지정한 행의 아이콘을 변경한다.
     *
     * @param row - 아이콘을 변경할 행의 트리 id
     * @param iconIndex - 새로 변경할 아이콘 인덱스
     *
     * @example
     * ```js
     * treeProvider.setIconIndex(42, 4);
     * ```
     */
    setIconIndex(row: number, iconIndex: number): void;
    /**
     * 지정한 행의 부모의 row id를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @returns 행 또는 부모 행이 존재하지 않을 경우 -1을 반환한다
     *
     * @example
     * ```js
     * let p = treeProvider.getParent(4);
     * ```
     */
    getParent(row: number): number;
    /**
     * 지정한 행의 level을 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     *
     * @example
     * ```js
     * let level = treeProvider.getLevel(4);
     * ```
     */
    getLevel(row: number): number;
    /**
     * 지정한 행의 자식 행들의 개수를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. -1일 경우 루트 행의 자식 행들의 개수를 반환한다.
     * @returns 지정한 행 또는 자식 행이 존재하지 않을 경우 0을 반환한다
     * @example
     * ```js
     * let childCount = treeProvider.getChildCount(4);
     * ```
     */
    getChildCount(row: number): number;
    /**
     * 지정한 행의 모든 자식 행들의 고유 번호를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자식 행들의 고유 번호를 반환한다.
     * @returns 지정한 행이 존재하지 않을 경우 null을 반환한다.
     *
     * @example
     * ```js
     * let children = treeProvider.getChildren(4);
     * ```
     */
    getChildren(row: number): number[];
    /**
     * 지정한 행의 자손 행들의 개수를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자손 행들의 개수를 반환한다.
     *
     * @example
     * ```js
     * let descenCount = treeProvider.getDescendantCount(4);
     * ```
     */
    getDescendantCount(row: number): number;
    /**
     * 지정한 행의 자손 행들의 id를 반환한다.
     *
     * @param data - 지정한 데이터 행의 트리 id, -1일 경우 루트 행의 자손 행들의 row id를 반환한다.
     * @param maxLevel - 반환할 수 있는 최대 레벨 깊이. 설정 된 값 이하의 레벨을 가진 행들만 반환한다.
     * @example
     * ```js
     * let descendants = treeProvider.getDescendants(4, 2);
     * ```
     */
    getDescendants(row: number, maxLevel?: number): number[];
    /**
     * 지정한 행의 조상 행들의 id를 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @returns 지정한 행 또는 행의 조상 행들이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let ances = treeProvider.getAncestors(4);
     * ```
     */
    getAncestors(row: number): number[];
    /**
     * 지정한 데이터 행을 JSON 객체로 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     * @param recursive - `true`이면 자식노드를 포함한다.
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @param level - 자식노드를 포함하는 경우 포함될 parentNode의 level을 `0`으로 계산한 level을 지정한다. 기본값: '-1'
     *
     * @returns 지정한 행이 존재하지 않을 경우 `null`을 반환한다.
     *
     * @example
     * ```js
     * let jsonRow = treeProvider.getJsonRow(4);
     * ```
     */
    getJsonRow(row: number, rowState: boolean, recursive: boolean, childRowsProp?: string, iconProp?: string, level?: number): any;
    /**
     * 지정한 데이터 행과 자손들을 JSON 객체로 반환한다.
     *
     * @param row - 지정한 데이터 행의 트리 id, 지정하지 않거나 rowId를 null로 지정하면 루트 행의 데이터를 가져옵니다.
     * @param recursive - 자손을 포함할 것인지 여부. 기본값: false
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @param rowState - `true`이면 행의 상태값을 추가한다.
     *
     * @returns 지정한 행이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let jsonRow = treeProvider.getJsonRows(4, true);
     * ```
     */
    getJsonRows(row: number, recursive: boolean, childRowsProp: string, iconProp: string, rowState: boolean): object[];
    /**
     * 지정한 데이터 행을 형식을 적용하여 JSON 객체로 가져온다.
     *
     * @param options - {@link DataOutputOptions} 와 같은 모델의 설정 정보
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행의 결과를 반환한다.
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @returns 지정한 데이터 행이 존재하지 않으면 `null`을 반환한다.
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRow(opt, 4);
     * ```
     */
    getOutputRow(options: DataOutputOptions, row: number, iconProp?: string): object;
    /**
     * 지정한 데이터 행과 자손들을 형식을 적용하여 JSON 객체로 가져온다.
     *
     * @param options - {@link DataOutputOptions} 와 같은 모델의 설정 정보
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행의 결과를 반환한다.
     * @param recursive - 자손을 포함할 것인지 여부. 기본값: `false`
     * @param childRowsProp - 자식 속성의 속성명을 지정한다. 기본값: 'rows'
     * @param iconProp - 아이콘 필드의 속성명을 지정한다. 기본값: 'iconIndex'
     * @returns 지정한 데이터 행이 존재하지 않으면 `null`을 반환한다.
     *
     * @example
     * ```js
     * let opt = {
     *      nullText: '빈 값'
     * }
     * let row = dataProvider.getOutputRows(opt, 4);
     * ```
     */
    getOutputRows(options: DataOutputOptions, row: number, recursive?: boolean, childRowsProp?: string, iconProp?: string): object[];
    /**
     * 지정한 트리 행의 자식 행을 추가한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param values - 추가할 행의 필드 값 배열 또는 Object
     * @param iconIndex - 트리 행에 표시할 아이콘 인덱스. 기본값: -1
     * @param hasChildren - 자식의 있는지 표시 여부. 기본값: `false`. true면 자식이 있는 것으로 표시
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     * @example
     * ```js
     * treeProvider.addChildRow(4, ['value1', 'value2', 'value3', 'value4'], -1, true);
     * ```
     */
    addChildRow(row: number, values: DataValues, iconIndex?: number, hasChildren?: boolean): number;
    /**
     * 지정한 트리 행의 자식행들 중 원하는 위치에 자식행을 추가한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param index - 지정한 부모 행의 자식들 중 삽입하려는 행이 들어갈 위치
     * @param values - 필드값의 배열이나 필드들을 속성으로 하는 json 객체
     * @param iconIndex - 트리 행에 표시할 아이콘 인덱스. 기본값: -1
     * @param hasChildren - 자식의 있는지 표시 여부. 기본값: `false`. `true`면 자식이 있는 것으로 표시
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     * @example
     * ```js
     * treeProvider.insertChildRow(4, 3, ['value1', 'value2', 'value3', 'value4'], -1, true);
     * ```
     */
    insertChildRow(row: number, index: number, values: DataValues, iconIndex?: number, hasChildren?: boolean): number;
    /**
     * 지정한 트리 행에 자식노드를 원하는 위치에 추가한다.
     *
     * @remarks
     * 트리형태의 자료를 추가할때 사용한다.
     *
     * @param row - 지정한 데이터 행의 트리 id. 지정하지 않을경우 루트 행을 지정한다.
     * @param index - 지정한 부모 행의 자식들 중 삽입하려는 행이 들어갈 위치
     * @param data - json형태의 data
     * @param childrenProp - 하위 노드가 있는 경우 속성명
     * @param iconField - 트리 행에 표시할 아이콘 인덱스를 가지고 있는 필드
     * @param noState - 행의 상태값을 추가여부 기본값: false
     * @returns 성공적으로 추가하면 추가된 행 고유번호를, 실패하면 -1을 반환한다.
     */
    insertChildNode(row: number, index: number, data: RowObject, childrenProp?: string, iconField?: string, noState?: boolean): number;
    /**
     * 지정한 데이터행의 필드 값들을 수정한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @param values - 변경 값. 필드값의 배열이거나, array또는 json객체다.
     * @param strict - 값이 undefined거나 명시되지 않은 필드는 기존 값을 유지한다.
     * @returns 지정한 데이터 행이 존재할 경우 성공여부를, 하지 않을 경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.updateRow(4, ['value1', 'value2', 'value3', 'value4'], true);
     * ```
     */
    updateRow(row: number, values: any[], strict?: boolean): boolean;
    /**
     * 지정한 데이터행들의 필드 값들을 수정한다.
     *
     * @param row - 지정한 데이터 행의 트리 id
     * @param values - 변경 값. 필드값의 배열이거나, array또는 json객체다.
     * @param strict - 값이 undefined거나 명시되지 않은 필드는 기존 값을 유지한다.
     * @returns 지정한 데이터 행이 존재할 경우 성공여부를, 하지 않을 경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.updateRow([4,3], [{'value1', 'value2', 'value3', 'value4'}, {'val1', 'val2', 'val3', 'val4'}], true);
     * ```
     */
    updateRows(rows: number[], values: any[], strict: boolean): void;
    /**
     * 지정한 데이터행을 삭제한다.
     *
     * @remarks
     * 지정한 데이터행이 조상행인 경우 모든 자손행들도 같이 삭제된다.
     * DataProvider의 softDeleting이 `true`인 경우 실제로 삭제되지않고 rowState만 변경된다.
     *
     * @param row - 삭제할 데이터 행의 트리 id
     * @returns - 지정한 행 또는 행의 부모가 존재할 경우 성공여부를, 하지 않을경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.removeRow(4);
     * ```
     */
    removeRow(row: number): boolean;
    /**
     * 지정한 데이터 행들을 삭제한다.
     *
     * @remarks
     * 지정한 데이터행이 조상행인 경우 모든 자손행들도 같이 삭제된다.
     * DataProvider의 softDeleting이 `true`인 경우 실제로 삭제되지않고 rowState만 변경된다.
     *
     * @param rows - 삭제할 데이터 행들의 트리 id들. 지정하지 않거나 빈 배열을 입력할 경우, false를 반환한다.
     * @returns - 삭제의 성공여부를 반환한다.
     *
     * @example
     * ```js
     * treeProvider.removeRows([1,3,4]);
     * ```
     */
    removeRows(rows: number[]): boolean;
    /**
     * DataProvider의 모든 행을 삭제한다.
     *
     *
     * @example
     * ```js
     * treeProvider.clearRows();
     * ```
     */
    clearRows(): void;
    /**
     * 지정한 행 또는 행들을 화면에서 감춘다.
     *
     * @remarks
     * 숨겨진 상태에서 remove, insert가 발생하는 경우 dataRow가 변경될 수 있으므로 사용시 주의한다.
     *
     * @param dataRows - 숨기고 싶은 행 번호 또는 번호들
     *
     * @example
     * ```js
     * // single
     * treeProvider.hideRows(4);
     *
     * // array
     * treeProvider.hideRows([3,4]);
     * ```
     */
    hideRows(dataRows: number[] | number): void;
    /**
     * 화면에서 감춘 행또는 행들을 보여준다.
     *
     * @remarks
     * filterMode, sortMode:"explicit"인 경우 `showHiddenRows()`를 사용하면 필터나 정렬이 재적용된다.
     * 접힌(collapse) 상태로 표시된다.
     *
     * @param dataRows - 보이고 싶은 행 번호 또는 번호들
     *
     * @example
     * ```js
     * // single
     * treeProvider.showHiddenRows(4);
     *
     * // array
     * treeProvider.showHiddenRows([3,4]);
     * ```
     */
    showHiddenRows(dataRows: number[] | number): void;
    /**
     * 숨겨진 행들의 번호를 반환한다.
     * @example
     * ```js
     * let rows = treeProvider.getHiddenRows();
     * ```
     */
    getHiddenRows(): number[];
    /**
     * 지정된 행이 숨겨진 행인지의 여부를 반환한다.
     *
     * @param dataRow - 지정한 데이터 행의 고유번호
     *
     * @example
     * ```js
     * let isHidden = treeProvider.isHiddenRow(4);
     * ```
     */
    isHiddenRow(dataRow: number): boolean;
    /**
     * 숨겨진 모든 행을 다시 표시한다.
     *
     * @example
     * ```js
     * treeProvider.resetHiddenRows();
     * ```
     */
    resetHiddenRows(): void;
    /**
     * 지정한 데이터 셀의 값을 반환한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param field - 필드명 또는 인덱스
     * @returns 해당 데이터 행이 존재하지 않을 경우 `null`을 반환한다.
     * @example
     * ```js
     * let val = dataProvider.getValue(2, 10);
     * ```
     */
    getValue(row: number, field: string | number): any;
    /**
     * 지정한 데이터 셀의 값을 변경한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param field - 필드명 또는 인덱스
     * @returns 해당 데이터 행이 존재하지 않을 경우 `null`을 반환한다.
     *
     * @example
     * ```js
     * dataProvider.setValue(2, 5, 'newValue');
     * ```
     */
    setValue(row: number, field: string | number, value: any): void;
    /**
     * 같은 부모의 형제 사이에서 특정 데이터행의 위치를 지정한 단계만큼 이동한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param offset - 지정 단계 값
     * @returns 해당 데이터 행이 존재하지 않을 경우 `false`를 반환한다
     *
     * @example
     * ```js
     * dataProvider.moveRowSibling(4, 1);
     * ```
     */
    moveRowSibling(row: number, offset: number): boolean;
    /**
     * 특정 데이터행의 위치를 지정한 행의 하위로 이동한다.
     *
     * @param row - 데이터 행의 트리 id
     * @param parent - 지정한 부모 행의 id. 이 행의 하위로 이동한다.
     * @param index - 형제들 사이에서의 위치
     * @returns 해당 데이터 행 또는 그 부모행이 존재하지 않을 경우 `false`를 반환한다.
     *
     * @example
     * ```js
     * dataProvider.changeRowParent(4, 1, 2);
     * ```
     */
    changeRowParent(row: number, parent: number, index: number): boolean;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 행을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchOptions} 모델로 지정한다.
     * @returns 찾은 행의 인덱스
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value'], parentId: 3});
     * ```
     *
     * @example
     * ```js
     * ds.searchDataRow({fields:['fieldName'], values: ['value']});
     * ```
     */
    searchDataRow(options: SearchOptions): number;
    /**
     * 검색 설정 방식에 따라 특정 값이 있는 셀을 찾는다.
     *
     * @param options - 검색 방식, {@link SearchCellOptions} 모델로 지정한다.
     * @returns 찾은 셀의 정보, {@link SearchCellResult} 모델이다.
     *
     * @example
     * ```js
     * ds.searchData({fields:['fieldName'], value: 'value', parentId: 3});
     * ```
     */
    searchData(options: SearchCellOptions): SearchCellResult;
    /**
     * @internal
     */
    protected _createProvider(undoable: boolean): LocalTreeDataProvider$1;
    /**
     * @internal
     */
    protected _createListener(provider: LocalTreeDataProvider$1): TreeProviderListener;
}
/**
 * @internal
 */
declare class GridProviderListener extends EventListenerBase {
    private _del;
    private _provider;
    constructor(_del: LocalDataProvider, _provider: LocalDataProvider$1);
    dispose(): void;
    onDataProviderRowCountChanged(provider: LocalDataProvider$1): void;
    onDataProviderRowUpdating(provider: LocalDataProvider$1, row: number, values: DataValues): boolean;
    onDataProviderRowUpdated(provider: LocalDataProvider$1, row: number): void;
    onDataProviderRowsUpdated(provider: LocalDataProvider$1, row: number, count: number): void;
    onDataProviderRowListUpdated(provider: LocalDataProvider$1, rows: number[]): void;
    onDataProviderRowInserting(provider: LocalDataProvider$1, row: number, values: DataValues): boolean;
    onDataProviderRowInserted(provider: LocalDataProvider$1, row: number): void;
    onDataProviderRowsInserted(provider: LocalDataProvider$1, row: number, count: number): void;
    onDataProviderRowRemoving(provider: LocalDataProvider$1, row: number): boolean;
    onDataProviderRowRemoved(provider: LocalDataProvider$1, row: number): void;
    onDataProviderRowsRemoving(provider: LocalDataProvider$1, rows: number[]): boolean;
    onDataProviderRowsRemoved(provider: LocalDataProvider$1, rows: number[]): void;
    onDataProviderRowMoving(provider: LocalDataProvider$1, row: number, newRow: number): boolean;
    onDataProviderRowMoved(provider: LocalDataProvider$1, row: number, newRow: number): void;
    onDataProviderRowsMoving(provider: LocalDataProvider$1, row: number, count: number, newRow: number): boolean;
    onDataProviderRowsMoved(provider: LocalDataProvider$1, row: number, count: number, newRow: number): void;
    onDataProviderRowListMoving(provider: LocalDataProvider$1, rows: number[], newRow: number): boolean;
    onDataProviderRowListMoved(provider: LocalDataProvider$1, rows: number[], newRow: number): void;
    onDataProviderValueChanged(provider: LocalDataProvider$1, row: number, field: number): void;
    onDataProviderDataChanged(provider: LocalDataProvider$1): void;
    onDataProviderStateChanged(provider: LocalDataProvider$1, row: number): void;
    onDataProviderStatesChanged(provider: LocalDataProvider$1, rows: number[]): void;
    onDataProviderStatesCleared(provider: LocalDataProvider$1): void;
    onDataProviderRestoreRows(provider: LocalDataProvider$1, rows: number[]): void;
}
/**
 * @internal
 */
declare class TreeProviderListener extends EventListenerBase {
    private _del;
    private _provider;
    constructor(_del: LocalTreeDataProvider, _provider: LocalTreeDataProvider$1);
    dispose(): void;
    onTreeDataProviderRowCountChanged(provider: LocalTreeDataProvider$1): void;
    onTreeDataProviderRowAdding(provider: LocalTreeDataProvider$1, row: TreeDataRow, index: number, child: any): boolean;
    onTreeDataProviderRowAdded(provider: LocalTreeDataProvider$1, row: TreeDataRow): void;
    onTreeDataProviderRowsAdded(provider: LocalTreeDataProvider$1, parent: TreeDataRow, rows: TreeDataRow[]): void;
    onTreeDataProviderRowRemoving(provider: LocalTreeDataProvider$1, row: TreeDataRow): boolean;
    onTreeDataProviderRowRemoved(provider: LocalTreeDataProvider$1, row: TreeDataRow): void;
    onTreeDataProviderRowsRemoved(provider: LocalTreeDataProvider$1, rows: TreeDataRow[]): void;
    onTreeDataProviderRowUpdating(provider: LocalTreeDataProvider$1, row: TreeDataRow): boolean;
    onTreeDataProviderRowUpdated(provider: LocalTreeDataProvider$1, row: TreeDataRow): void;
    onTreeDataProviderRowsUpdating(provider: LocalTreeDataProvider$1, rows: TreeDataRow[]): boolean;
    onTreeDataProviderRowsUpdated(provider: LocalTreeDataProvider$1, rows: TreeDataRow[]): void;
    onTreeDataProviderValueChanged(provider: LocalTreeDataProvider$1, row: TreeDataRow, field: number): void;
    onTreeDataProviderRowStateChanged(provider: LocalTreeDataProvider$1, row: TreeDataRow): void;
    onTreeDataProviderRowStatesChanged(provider: LocalTreeDataProvider$1, rows: TreeDataRow[]): void;
    onTreeDataProviderRowSiblingMoving(provider: LocalTreeDataProvider$1, row: TreeDataRow, offset: number): boolean;
    onTreeDataProviderRowSiblingMoved(provider: LocalTreeDataProvider$1, row: TreeDataRow, offset: number): void;
    onTreeDataProviderRowsSiblingMoving(provider: LocalTreeDataProvider$1, rows: TreeDataRow[], offset: number): boolean;
    onTreeDataProviderRowsSiblingMoved(provider: LocalTreeDataProvider$1, rows: TreeDataRow[], offset: number): void;
    onTreeDataProviderRowParentChanging(provider: LocalTreeDataProvider$1, row: TreeDataRow, parent: TreeDataRow, index: number): boolean;
    onTreeDataProviderRowParentChanged(provider: LocalTreeDataProvider$1, row: TreeDataRow, parent: TreeDataRow, index: number): void;
}

/** @internal */
declare class TreeItem extends GroupItem {
    private static $_tempItem;
    static getTemp(row: TreeDataRow, parent?: TreeItem): TreeItem;
    private _iconHeight;
    private _dataRow;
    private _footer;
    private _editable;
    private _readOnly;
    constructor(dataRow: TreeDataRow);
    dispose(): void;
    /** iconHeight */
    get iconHeight(): number;
    set iconHeight(value: number);
    /** row */
    get row(): TreeDataRow;
    /** rowId */
    get rowId(): number;
    /** iconIndex */
    get iconIndex(): number;
    /** hasChildren */
    get hasChildren(): boolean;
    /** rootItem */
    get rootItem(): TreeItem;
    /** summaryMode */
    get summaryMode(): SummaryMode;
    get editable(): boolean;
    get readOnly(): boolean;
    setEditable(editable: boolean, readOnly: boolean): void;
    protected _getExtents(): number;
    protected _setExtents(value: number): void;
    get isData(): boolean;
    get isDataRow(): boolean;
    get footer(): GridItem;
    get footerCount(): number;
    get dataRow(): number;
    getShadowRow(): number;
    get dataId(): number;
    get descendantCount(): number;
    get rowState(): RowState;
    get isLeaf(): boolean;
    get resizable(): boolean;
    get type(): ItemType;
    getFooter(number: number): GridItem;
    isFooter(item: GridItem): boolean;
    canEdit(): boolean;
    protected createFooter(): void;
    setExpanded(value: boolean, recursive: boolean, force: boolean): void;
    getData(field: number): any;
    setData(field: number, value: any): void;
    setItem(item: GridItem, newItem: GridItem): void;
    exchange(index1: number, index2: number): void;
    moveChild(index: number, delta: number): void;
    moveChildren(index: number, count: number, delta: number): void;
    changeParent(parent: TreeItem, index: number): void;
    getRowData(): RowValues;
}
/** @internal */
declare class TreeItemProvider extends ItemProvider implements TreeDataCommandListener {
    static readonly ITEM_CHANGED = "onTreeItemProviderItemChanged";
    static readonly EXPANDING = "onTreeItemProviderExpanding";
    static readonly EXPANDED = "onTreeItemProviderExpanded";
    static readonly COLLAPSING = "onTreeItemProviderCollapsing";
    static readonly COLLAPSED = "onTreeItemProviderCollapsed";
    static readonly PARENT_CHANGING = "onTreeItemProviderParentChanging";
    static readonly PARENT_CHANGED = "onTreeItemProviderParentChanged";
    private _sortMode;
    private _expandWhenGrouping;
    private _footerWhenExpanded;
    private _footerWhenCollapsed;
    private _labelComparer;
    private _summaryMode;
    private _groupSummaryMode;
    private _checkableExpression;
    private _checkableCallback;
    private _ds;
    private _extents;
    private _filters;
    private _filterRuntime;
    private _filtered;
    private _sorter;
    private _sortFields;
    private _sortDirections;
    private _sortCases;
    private _visibleItems;
    private _itemMap;
    private _itemCount;
    private _summaryMap;
    private _checkableTag;
    private _filterLock;
    private _includeParentItem;
    private _checkFieldIndex;
    constructor();
    protected _doDispose(): void;
    getCommandStates(row: TreeDataRow): any;
    setCommandStates(row: TreeDataRow, states: any): void;
    /** expandWhenGrouping */
    get expandWhenGrouping(): boolean;
    set expandWhenGrouping(value: boolean);
    /** footerWhenExpanded */
    get footerWhenExpanded(): boolean;
    set footerWhenExpanded(value: boolean);
    /** footerWhenCollapsed */
    get footerWhenCollapsed(): boolean;
    set footerWhenCollapsed(value: boolean);
    /** labelComparer */
    get labelComparer(): any;
    set labelComparer(value: any);
    /** summaryMode */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /** groupSummaryMode */
    get groupSummaryMode(): SummaryMode;
    set groupSummaryMode(value: SummaryMode);
    /** hideDeleted */
    get hideDeleted(): boolean;
    set hideDeleted(value: boolean);
    /** checkableExpression */
    get checkableExpression(): string;
    set checkableExpression(value: string);
    /** checkableCallback */
    get checkableCallback(): CheckableCallback;
    set checkableCallback(value: CheckableCallback);
    /** sortMode */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    /** includeParentItem */
    get includeParentItem(): boolean;
    set includeParentItem(value: boolean);
    private $_needSort;
    insertItem(parent: TreeItem, item: TreeItem, index: number, after: boolean): void;
    appendItem(parent: TreeItem, item: TreeItem): void;
    removeItem(item: TreeItem): void;
    $_calcLevel(item: any, level: any, visibleOnly: any): any;
    getLevels(visibleOnly: any): any;
    $_setExpanded(item: TreeItem, recursive: boolean, level: number): void;
    protected _expandItem(item: TreeItem, force: boolean, recursive: boolean, level: number, fireEvents: boolean): void;
    expand(item: TreeItem, recursive: boolean, force: boolean, level?: number): void;
    expandAll(level: number): void;
    private $_setCollapsed;
    protected _collapseItem(item: TreeItem, force: boolean, recursive: boolean, fireEvents: boolean): void;
    collapse(item: TreeItem, recursive: boolean, force?: boolean): void;
    collapseAll(): void;
    private $_saveExpanded;
    orderBy(fields: number[], directions: SortDirection[], textCases: SortCase[], fireEvent?: boolean): void;
    getSortFields(): number[];
    getSortDirections(): SortDirection[];
    getSortCases(): SortCase[];
    beginFiltering(): void;
    private $_prepareFiltering;
    endFiltering(apply: boolean, filterCollection: any, filter: any): void;
    hasFilter(field: number): boolean;
    addFilter(field: number, refFilter: ColumnFilter): ColumnFilterRun;
    removeFilter(field: number, filter: ColumnFilter): void;
    clearFilters(field: number): void;
    clearAllFilters(): void;
    hasFilters(): boolean;
    private $_prepareFilters;
    applyFilters(filterCollection: any, filter: ColumnFilter, prepareMap?: ConfigObject): void;
    getItemByRow(row: TreeDataRow): any;
    getCheckedRows(): TreeDataRow[];
    getCheckedRowIds(): number[];
    resetCheckables(): void;
    applyCheckables(): void;
    $_checkChildren(parent: TreeItem, checked: boolean, checkableOnly: boolean): void;
    _clearChecked(): void;
    checkAll(checked: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent: boolean): void;
    setCheckFieldIndex(field: number): void;
    setItemChecked(item: TreeItem, checked: boolean): boolean;
    getItemChecked(item: TreeItem, checked: boolean): boolean;
    get dataSource(): DataSource;
    set dataSource(value: DataSource);
    get itemCount(): number;
    get rowCount(): number;
    get sorted(): boolean;
    get movable(): boolean;
    protected _createRootItem(): GroupItem;
    getItem(index: number): GridItem;
    getItems(index: number, count: number): GridItem[];
    getItemOfRow(dataRow: number, force?: boolean): GridItem;
    $_collectItems(item: TreeItem, list: TreeItem[]): void;
    getAllItems(): GridItem[];
    getJsonRows(): object[];
    getSum(field: number): number;
    getMax(field: number): number;
    getMin(field: number): number;
    getAvg(field: number): number;
    getVar(field: number): number;
    getVarp(field: number): number;
    getStdev(field: number): number;
    getStdevp(field: number): number;
    getDataCount(field: number): number;
    getDataAvg(field: number): number;
    findItem(fields: number[], values: any[], options: any, startIndex: number, endIndex: number): number;
    findCell(fields: any, value: any, options: any, startIndex: number, endIndex: number, startFieldIndex: number): any;
    private $_internalAddItem;
    private $_internalRemoveItem;
    private $_internalRowStateChanged;
    private $_selectField;
    private $_selectItem;
    protected _setItem(item: TreeItem, newItem: TreeItem): void;
    private $_resetVisibleItems;
    private $_clearItems;
    private $_buildItems;
    private $_sortItem;
    private $_sort;
    private $_buildTree;
    private $_resetSummary;
    private $_resetGroupSummary;
    private $_clearSummary;
    private $_getSummary;
    private $_summarize;
    protected _fireItemChanged(item: any): void;
    protected _fireExpanding(item: any): boolean;
    protected _fireExpanded(item: any): void;
    protected _fireCollapsing(item: any): boolean;
    protected _fireCollapsed(item: any): void;
    protected _fireParentChanging(itemIndex: any, parent: any, childIndex: any): boolean;
    protected _fireParentChanged(item: any, oldIndex: any, parent: any): void;
    protected _refreshItems(): void;
    protected _saveAndRefresh(restoreExpanded?: boolean, fireEvent?: boolean): void;
    onDataSourceCommandStackChanged(ds: DataSource, undoable: boolean, redoable: boolean): void;
    onTreeDataProviderDisposed(ds: TreeDataProvider): void;
    onTreeDataProviderReset(provider: TreeDataProvider): void;
    onTreeDataProviderRefresh(provider: TreeDataProvider): void;
    onTreeDataProviderRefreshClient(provider: TreeDataProvider): void;
    onDataProvderCleared(provider: TreeDataProvider): void;
    onTreeDataProviderRowCountChanged(provider: TreeDataProvider, newCount: number): void;
    onTreeDataProviderRowAdding(provider: TreeDataProvider, row: TreeDataRow, index: number): boolean;
    onTreeDataProviderRowAdded(provider: TreeDataProvider, row: TreeDataRow): void;
    onTreeDataProviderRowsAdded(provider: TreeDataProvider, parent: TreeDataRow, rows: TreeDataRow[]): void;
    onTreeDataProviderRowRemoving(provider: TreeDataProvider, row: TreeDataRow): boolean;
    onTreeDataProviderRowRemoved(provider: TreeDataProvider, row: TreeDataRow): void;
    onTreeDataProviderRowsRemoving(provider: TreeDataProvider, rows: TreeDataRow[]): boolean;
    onTreeDataProviderRowsRemoved(provider: TreeDataProvider, rows: TreeDataRow[]): void;
    onTreeDataProviderRowUpdating(provider: TreeDataProvider, row: TreeDataRow): boolean;
    onTreeDataProviderRowUpdated(provider: TreeDataProvider, row: TreeDataRow): void;
    onTreeDataProviderRowsUpdating(provider: TreeDataProvider, rows: TreeDataRow[]): boolean;
    onTreeDataProviderRowsUpdated(provider: TreeDataProvider, rows: TreeDataRow[]): void;
    onTreeDataProviderValueChanging(provider: TreeDataProvider, row: TreeDataRow, field: number): boolean;
    onTreeDataProviderValueChanged(provider: TreeDataProvider, row: TreeDataRow, field: number): void;
    onTreeDataProviderIconIndexChanged(provider: TreeDataProvider, row: TreeDataRow): void;
    onTreeDataProviderHasChildrenChanged(provider: TreeDataProvider, row: TreeDataRow): void;
    onTreeDataProviderRowStateChanged(provider: TreeDataProvider, row: TreeDataRow, refresh: boolean): void;
    onTreeDataProviderRowStatesChanged(provider: TreeDataProvider, rows: TreeDataRow[]): void;
    onTreeDataProviderRowSiblingMoved(provider: TreeDataProvider, row: TreeDataRow, delta: number): void;
    onTreeDataProviderRowsSiblingMoved(provider: TreeDataProvider, rows: TreeDataRow[], delta: number): void;
    onTreeDataProviderRowParentChanged(provider: TreeDataProvider, row: TreeDataRow, parent: TreeDataRow, childIndex: number): void;
    onTreeDataProviderRowsParentChanged(provider: TreeDataProvider, rows: TreeDataRow[], parent: TreeDataRow, childIndex: number): void;
    onTreeDataProviderRowsHideChanged(provider: TreeDataProvider, rows: number[], hidden: boolean): void;
    onTreeDataProviderDataLoadComplated(): void;
}

/** @internal */
declare class TreeGridItemProvider extends EditableItemProvider {
    private _observers;
    private _rs;
    private _summarizer;
    private _appending;
    private _insertAfter;
    private _insertIndex;
    private _editItem;
    constructor(indexing: boolean);
    protected _doDispose(): void;
    get summarizer(): GridSummarizer;
    getLevels(visibleOnly: boolean): number;
    setLabelComparer(comparer: any): void;
    orderBy(fields: number[], directions: SortDirection[], textCases: SortCase[]): void;
    getSortFields(): number[];
    getSortDirections(): SortDirection[];
    getSortCases(): SortCase[];
    get labelComparer(): any;
    set labelComparer(comparer: any);
    isFiltered(field: number): boolean;
    addFilter(field: number, refFilter: ColumnFilter): void;
    removeFilter(field: number, filter: ColumnFilter): void;
    clearFilters(field: number): void;
    clearAllFilters(): void;
    beginFiltering(): void;
    endFiltering(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    set includeParentItem(value: boolean);
    expand(item: TreeItem, recursive: boolean, force: boolean, level?: number): void;
    collapse(item: TreeItem, recursive: boolean): void;
    expandAll(level: number): void;
    collapseAll(): void;
    getCheckedRows(): TreeDataRow[];
    getCheckedRowIds(): number[];
    set checkableExpression(value: string);
    set checkableCallback(value: CheckableCallback);
    resetCheckables(): void;
    applyCheckables(): void;
    getAllItems(): GridItem[];
    getItem(index: any): GridItem;
    getItemOfRow(dataRow: any): GridItem;
    findItem(fields: any, values: any, options: any, startIndex: any, endIndex: any): any;
    findCell(fields: any, value: any, options: any, startIndex: number, endIndex: number, startFieldIndex: number): any;
    checkItem(item: any, checked: any, exclusive: any, checkEvent: any): void;
    checkAll(checked: any, visibleOnly: any, checkableOnly: any, checkEvent: any): void;
    setCheckFieldIndex(field: number): void;
    getJsonRows(): object[];
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    set groupSummaryMode(value: SummaryMode);
    get hideDeleted(): boolean;
    set hideDeleted(value: boolean);
    /** sortMode */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    get itemCount(): number;
    get rowCount(): number;
    get sorted(): boolean;
    get movable(): boolean;
    getItems(index: number, count: number): GridItem[];
    canAppend(): boolean;
    canInsert(item: GridItem): boolean;
    canDelete(item: GridItem): boolean;
    private $_replaceItem;
    protected _doBeginUpdate(item: GridItem): GridItem;
    protected _doBeginAppend(defaultValues: RowValues): GridItem;
    protected _doBeginInsert(item: GridItem, defaultValues: RowValues, shift?: boolean, ctrl?: boolean): GridItem;
    protected _doCompleteUpdate(orgItem: GridItem): boolean;
    protected _doCompleteInsert(appending: boolean): boolean;
    protected _doCancelEdit(state: ItemState, orgItem: GridItem): void;
    protected _doCommitEdit(state: ItemState, orgItem: GridItem): boolean;
    remove(item: GridItem): void;
    getRemovableRows(items: number[]): number[];
    removeRows(rows: any): void;
    updateRows2(rows: {
        [dataRow: number]: DataValues;
    }): void;
    setDataSource(value: TreeDataProvider): void;
    get rootItem(): GroupItem;
    protected _createEditItem(target: GridItem, state: ItemState, defaultValues: any[]): GridItem;
    onItemProviderFilterAdd(rs: ItemProvider, field: number, criteria: string): void;
    onItemProviderFilterRemove(rs: ItemProvider, field: number, filter: ColumnFilter): void;
    onItemProviderFilterClear(rs: ItemProvider, field: number): void;
    onItemProviderFilterClearAll(rs: ItemProvider): void;
    onItemProviderFilterAdded(rs: ItemProvider, field: number, criteria: string): void;
    onItemProviderFilterRemoved(rs: ItemProvider, field: number, filter: any): void;
    onItemProviderFilterCleared(rs: ItemProvider, field: number): void;
    onItemProviderFilterAllCleared(rs: ItemProvider): void;
    onItemProviderFiltered(rs: ItemProvider, filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    onItemProviderSort(rs: ItemProvider, fields: number[], directions: SortDirection[]): void;
    onItemProviderSorted(rs: ItemProvider): void;
    onItemProviderDataLoadComplated(): void;
    onTreeItemProviderItemChanged(rs: TreeItemProvider, item: TreeItem): void;
    onTreeItemProviderExpanding(rs: TreeItemProvider, item: TreeItem): boolean;
    onTreeItemProviderExpanded(rs: TreeItemProvider, item: TreeItem): void;
    onTreeItemProviderCollapsing(rs: TreeItemProvider, item: TreeItem): boolean;
    onTreeItemProviderCollapsed(rs: TreeItemProvider, item: TreeItem): void;
}

declare type TreeIconCallback = (tree: TreeView$1, itemIndex: number, dataRow: number, iconIndex: number) => number | undefined;
/**
 * TreeView 관련 설정 정보들
 * @internal
 */
declare class TreeOptions extends GridBaseOptions implements TreeOptions$1 {
    private _levelIndent;
    private _lineVisible;
    private _showCheckBox;
    private _iconImagesRoot;
    private _iconImages;
    private _defaultIcon;
    private _iconCallback;
    private _collapseWhenLeftKey;
    private _collapseWhenCtrlKey;
    private _expandWhenRightKey;
    private _expandWhenCtrlKey;
    private _iconVisible;
    private _expanderIconStyle;
    private _expandedIcon;
    private _collapsedIcon;
    constructor(grid: TreeView$1);
    /**
     * @internal
     */
    protected _doDispose(): void;
    /**
     * levelIndent
     */
    get levelIndent(): number;
    /**
     * 트리 라인 표시여부
     *
     * @defaultValue `true`
     */
    get lineVisible(): boolean;
    set lineVisible(value: boolean);
    /**
     * 트리 내부 체크 박스 여부
     *
     * @defaultValue `false`
     */
    get showCheckBox(): boolean;
    set showCheckBox(value: boolean);
    /**
     * 아이콘으로 사용할 이미지 경로.
     */
    get iconImagesRoot(): string;
    set iconImagesRoot(value: string);
    /**
     * 아이콘으로 사용할 이미지 파일 목록.
     */
    get iconImages(): string[];
    set iconImages(value: string[]);
    /**
     * 아이템의 아이콘 인덱스가 존재하지 않거나, 총 개수를 넘어가면 지정되는 아이콘 인덱스
     *
     * @defaultValue `-1`
     */
    get defaultIcon(): number;
    set defaultIcon(value: number);
    /**
     * node가 펼쳐졌을때 표시되는 아이콘의 index
     */
    get expandedIcon(): number;
    set expandedIcon(value: number);
    /**
     * node가 접혔을때 표시되는 아이콘의 index
     */
    get collapsedIcon(): number;
    set collapsedIcon(value: number);
    /**
     * undefined를 리턴하면 트리 데이터행에 설정된 값을 사용한다.
     */
    get iconCallback(): TreeIconCallback;
    set iconCallback(value: TreeIconCallback);
    /**
     * 왼쪽 방향키를 눌렀을 때 접힘 여부
     */
    get collapseWhenLeftKey(): boolean;
    set collapseWhenLeftKey(value: boolean);
    /**
     * ctrl 키를 같이 눌렀을 때 접힘 여부
     */
    get collapseWhenCtrlKey(): boolean;
    set collapseWhenCtrlKey(value: boolean);
    /**
     * 오른쪽 방향키를 눌렀을 때 펼침 여부
     */
    get expandWhenRightKey(): boolean;
    set expandWhenRightKey(value: boolean);
    /**
     * ctrl 키를 같이 눌렀을 때 펼침 여부
     */
    get expandWhenCtrlKey(): boolean;
    set expandWhenCtrlKey(value: boolean);
    /**
     * icon visible
     */
    get iconVisible(): boolean;
    set iconVisible(value: boolean);
    get expanderIconStyle(): TreeExpanderIconStyle;
    set expanderIconStyle(value: TreeExpanderIconStyle);
}

/** @internal */
declare class TreeLinesElement extends LayerElement {
    private _levelWidth;
    private _handleWidth;
    private _handleHeight;
    private _stroke;
    private _treeView;
    private _linePool;
    private _lines;
    private _startIndex;
    private _endIndex;
    constructor(treeView: TreeView$1);
    protected _doDispose(): void;
    /** levelWidth */
    get levelWidth(): number;
    set levelWidth(value: number);
    /** handleWidth */
    get handleWidth(): number;
    set handleWidth(value: number);
    /** handleHeight */
    get handleHeight(): number;
    set handleHeight(value: number);
    /** stroke */
    get stroke(): string;
    set stroke(value: string);
    setRange(treeView: TreeView$1, startIndex: number, endIndex: number): void;
    layout(lm: TreeGridLayoutManager): void;
    _getCssSelector(): string;
    protected _initDom(dom: HTMLElement): void;
    protected _doDraw(dom: HTMLElement): void;
    private $_borrowLine;
    private $_hideAll;
    private $_findLevelItem;
    private $_setBounds;
    private $_drawVertLine;
    private $_drawHorzLine;
    private $_drawChildLine;
}

/**
 * @internal
 */
declare class TreeItemExpanderCell extends GridCell {
    constructor();
    get getText(): string;
    get value(): any;
}
/**
 * @internal
 */
declare class TreeItemFooterCell extends GridCell {
    constructor();
    get getText(): string;
    get value(): any;
}
/**
 * @internal
 */
declare class TreeView$1 extends GridBase$1 {
    static readonly EXPANDING = "onTreeViewExpanding";
    static readonly EXPANDED = "onTreeViewExpanded";
    static readonly COLLAPSING = "onTreeViewCollapsing";
    static readonly COLLAPSED = "onTreeViewCollapsed";
    static readonly CHANGED = "onTreeViewChanged";
    private _rs;
    private _linesView;
    private _expanderCell;
    private _footerCell;
    private _treeOptions;
    private _focusedRow;
    constructor(container: GridContainer, accessibility: boolean, waiOptions: WaiOptions);
    protected _doDispose(): void;
    /** treeOptions */
    get treeOptions(): TreeOptions;
    /** linesView */
    get linesView(): TreeLinesElement;
    isTree(): boolean;
    protected _beforeChangeLayout(): void;
    getLevels(visibleOnly: boolean): number;
    getExpanderCell(index: number): TreeItemExpanderCell;
    getFooterCell(index: CellIndex): TreeItemFooterCell;
    expand(item: TreeItem, recursive: boolean, force: boolean, level?: number): void;
    collapse(item: TreeItem, recursive: boolean): void;
    expandAll(level?: number): void;
    collapseAll(): void;
    getTreeIcon(item: TreeItem): string;
    getCheckedItems(): TreeItem[];
    getCheckedItemIndices(): number[];
    getCheckedRows(visibleOnly: boolean): TreeDataRow[];
    getCheckedRowIds(visibleOnly: boolean): number[];
    checkChildren(parent: TreeItem, checked: boolean, recursive: boolean, visibleOnly: boolean, checkableOnly?: boolean, checkEvent?: boolean): void;
    resetCheckables(): void;
    applyCheckables(): void;
    getItemOfModel(model: any): GridItem;
    getJsonRows(): object[];
    get dataSource(): DataSource;
    set dataSource(value: DataSource);
    get maxItemCount(): number;
    set maxItemCount(value: number);
    get summarizer(): GridSummarizer;
    _initStyles(): void;
    protected _createItemSource(): TreeGridItemProvider;
    protected _doContentPanesCreated(): void;
    protected _createSidePane(): ContentPane;
    _createLayoutManager(): TreeGridLayoutManager;
    protected _createBodyView(body: GridBody): GridBodyElement;
    protected _createFixedBodyView(body: GridBody): GridBodyElement;
    protected _createRightBodyView(body: GridBody): GridBodyElement;
    _visualObjectChanged(obj: VisualObject): void;
    append(): boolean;
    _doCanInsert(item: TreeItem, shift: boolean, ctrl: boolean): boolean;
    _doMaxRowCountChanged(): void;
    getSortFields(): number[];
    getSortDirections(): SortDirection[];
    getSortCases(): SortCase[];
    _doSortItems(fields: number[], directions: SortDirection[], textCases: SortCase[]): void;
    _doColumnFiltersChanged(filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    setOptions(source: ConfigObject): void;
    protected _doPrepareRender(bounds: Rectangle): void;
    protected $_doLayout(lm: GridLayoutManager, bounds: Rectangle): void;
    assignImageList(list: any): void;
    refreshView(): void;
    getEditBounds(editor: CellEditor, index: CellIndex): Rectangle;
    updatePastedRow(item: TreeItem, values: RowValues, strict: boolean): void;
    appendPastedRow(values: RowValues): void;
    get undoable(): boolean;
    set undoable(value: boolean);
    get canUndo(): boolean;
    get canRedo(): boolean;
    get undoing(): boolean;
    get redoing(): boolean;
    undo(): boolean;
    redo(): boolean;
    execute(command: EditCommand): void;
    clearCommandStack(all?: boolean): void;
    getFirstRow(): GridItem;
    getLastRow(): GridItem;
    getPrevRow(item: GridItem): GridItem;
    getNextRow(item: GridItem): GridItem;
    canMoveRows(items: GridItem[], checkItems: boolean, target: GridItem): boolean;
    protected _getMoveTarget(eventFrom: EventFrom, items: GridItem[], r: number, delta: number): GridItem;
    /**
     * items는 모두 형제들이라고 가정한다.
     */
    protected _doMoveRows(items: GridItem[], before: GridItem): boolean;
    protected _fitLayoutWidth(layout: CellLayoutColumnItem): number;
    $_getVisibleAncestor(rowId: number): TreeItem;
    onItemProviderReset(rs: ItemProvider): void;
    onTreeItemProviderItemChanged(rs: TreeGridItemProvider, item: TreeItem): void;
    onTreeItemProviderExpanding(rs: TreeGridItemProvider, item: TreeItem): boolean;
    onTreeItemProviderExpanded(rs: TreeGridItemProvider, item: TreeItem): void;
    onTreeItemProviderCollapsing(rs: TreeGridItemProvider, item: TreeItem): boolean;
    onTreeItemProviderCollapsed(rs: TreeItemProvider, item: TreeItem): void;
}
/**
 * @internal
 */
declare class TreeGridLayoutManager extends GridLayoutManager {
    constructor(treeView: TreeView$1);
    layout(bounds: Rectangle): void;
    private $_layoutLines;
}

/**
 * 컬럼에 연결된 데이터 필드의 실제 값 대신 그 값과 연관된 다른 값을 셀에 표시하기 위한 설정 정보
 *
 * @remarks
 * {@link GridBase.setLookups | setLookups}, {@link GridBase.addLookupSource | addLookupSource} 에서 사용된다.
 *
 * @example
 * ```js
 * dataProvider.setFields([
 *     { fieldName:"field1"},
 *     { fieldName:"field2"},
 *     { fieldName:"text1"},
 *     { fieldName:"text2"},
 *     ....
 * ]);
 * gridView.setColumns([
 *     { fieldName:"field1", name:"field1", lookupDisplay:true, lookupSourceId:"field1Data", lookupKeyFields:["field1"], editor:{type:"dropDown"}},
 *     { fieldName:"field2", name:"field2", lookupDisplay:true, lookupSourceId:"field2Data", lookupKeyFields:["field1","field2"], editor:{type:"dropDown"}},
 *     { fieldName:"text1", name:"text1"},
 *     { fieldName:"text2", name:"text2"}
 *     ....
 * ]);
 * // field1의 셀을 수정하였을때 field2의 dropDown Editor의 목록이 변경되도록 컬럼 구성
 * ....
 * gridView.setLookups([
 *     { id:"field1Data",
 *       levels:1,
 *       keys:["data1","data2","data3"],
 *       values:["데이터1","데이터2","데이터3",],
 *     },
 *     { id:"field2Data",
 *       levels:2,
 *       ordered: true,
 *       keys: [
 *         ["data1","data1_code1"],
 *         ["data1","data1_code2"],
 *         ["data1","data1_code3"],
 *         ["data1","data1_code4"],
 *         ["data2","data2_code1"],
 *         ["data2","data2_code2"],
 *         ["data3","data3_code3"],
 *         ["data3","data3_code4"]
 *       ],
 *       values:[
 *         ["데이터1_코드1"],
 *         ["데이터1_코드2"],
 *         ["데이터1_코드3"],
 *         ["데이터1_코드4"],
 *         ["데이터2_코드1"],
 *         ["데이터2_코드2"],
 *         ["데이터3_코드1"],
 *         ["데이터3_코드2"]
 *       ],
 *      }
 * ]);
 * // field1에서 data1을 선택하면 field2의 dropDown Editor에는 data1의 하위코드들만 보여진다.
 * ```
 */
interface LookupSource {
    /**
     * 고유명 (id)
     */
    id: string;
    /**
     * lookup tree 에서의 수준
     *
     * @remarks
     * `1` 이상이어야 한다.
     */
    level?: number;
    /**
     * 정렬 여부
     *
     * @defaultValue `false`
     */
    ordered?: boolean;
    /**
     * 키들
     *
     * @remarks
     * `level` 이 1보다 큰 경우, 순차적으로 해당 레벨과 대응되는 key 값들을 입력해야한다.
     *
     * @example
     * ```js
     * // level 1 인 경우
     * ['동물', '식물', '균류']
     *
     * // level 2 인 경우
     * [['동물', '인간'], ['동물', '쥐'], ['식물', '피튜니아'], ['식물', '파리지옥'], ['균류', '푸른곰팡이'], ['균류', '송이버섯']]
     * ```
     */
    keys: string[] | string[][];
    /**
     * 값
     */
    values: string[];
}
/**
 * {@link LookupSource} 를 채우기 위한 모델 정보
 *
 * @remarks
 * {@link GridBase.fillLookupData | fillLookupData()} 시 매개변수로 사용된다.
 *
 * @example
 * ```js
 * // rows 속성을 이용할 경우
 * gridView.fillLookupData("empLookup", {
 *      rows: [
 *          ["TOMSP", "5", "TOMSP_5X"],
 *          ["TOMSP", "6", "TOMSP_6X"]
 *      ]});
 *
 * // key-value 속성을 이용할 경우
 * gridView.fillLookupData("empLookup", {
 *      keys: [
 *          ["TOMSP", "5", "TOMSP_5X"],
 *          ["TOMSP", "6", "TOMSP_6X"]
 *      ],
 *      values: [
 *          ["TOMSP_5X"],
 *          ["TOMSP_6X"]
 *      ]});
 * ```
 */
declare type LookupData = LookupDataRows | LookupDataKeyValues;
/**
 * {@link LookupData} 의 한 종류
 *
 * @example
 * ```js
 * // key1, key2, value
 * rows: [
 *      ["TOMSP", "5", "TOMSP_5X"],
 *      ["TOMSP", "6", "TOMSP_6X"]
 * ]
 * ```
 */
interface LookupDataRows {
    /**
     * 키들과 값들의 배열
     */
    rows: string[];
}
/**
 * {@link LookupData} 의 한 종류
 *
 * @example
 * ```
 * {
 *      keys: [
 *          ["TOMSP", "5"],
 *          ["TOMSP", "6"]
 *      ],
 *      values: [
 *          ["TOMSP_5X"],
 *          ["TOMSP_6X"]
 *      ]
 * }
 * ```
 */
interface LookupDataKeyValues {
    /**
     * 키들
     */
    keys: string[] | string[][];
    /**
     * 값
     */
    values: string[];
}

/**
 * @public
 * GridBase는 {@link GridView}와 {@link TreeView}의 기반 클래스(Base Class)이다.
 *
 * @remarks
 * GridBase 의 모든 속성과 method 는 이를 상속한 하위 클래스들에서만 호출할 수 있다.
 *
 * [하위 클래스]
 *
 * {@link GridView}
 *
 * {@link TreeView}
 *
 * @warning GridBase 로 직접 설정하거나 호출할 수 없다.
 */
declare abstract class GridBase {
    /**
     * @internal
     */
    protected _view: GridBase$1;
    /**
     * @internal
     */
    protected _container: GridContainer;
    /**
     * @internal
     */
    protected _dataDelegator: LocalDataProvider | LocalTreeDataProvider;
    /**
     * @internal
     */
    protected _dataProvider: DataSource;
    /**
     * @internal
     */
    private _listener;
    constructor(container: string | HTMLDivElement, accessibility?: boolean, waiOptions?: WaiOptions);
    /**
     * @internal
     */
    dispose(): void;
    /**
     * 현재 그리드의 합계를 계산하는 방식
     *
     * @remarks
     * 그리드에 설정되어 있는 {@link SummaryMode} 를 반환한다.
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.summaryMode = "aggregate";
     * ```
     */
    get summaryMode(): SummaryMode;
    set summaryMode(value: SummaryMode);
    /**
     * 그리드에 설정되어 있는 삭제된 행들의 숨김 여부
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.hideDeletedRows = true;
     * ```
     */
    get hideDeletedRows(): boolean;
    set hideDeletedRows(value: boolean);
    /**
     * 데이터 수정 이후 정렬 동작 모드
     *
     * @remarks
     * 그리드에 설정되어 있는 {@link SortMode} 를 반환한다.
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.sortMode = "explicit";
     * ```
     */
    get sortMode(): SortMode;
    set sortMode(value: SortMode);
    /**
     * 실행취소 기능 사용 가능 여부
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     *
     * ```js
     * gridView.undoable = false
     * ```
     */
    get undoable(): boolean;
    set undoable(value: boolean);
    /**
     * 현재상태에서 실행취소 가능 여부
     *
     * @example
     *
     * ```js
     * gridView.undoing = false
     * ```
     */
    get undoing(): boolean;
    /**
     * 현재상태에서 재실행 가능 여부
     *
     * @example
     *
     * ```js
     * gridView.redoing = false
     * ```
     */
    get redoing(): boolean;
    /**
     * 그리드가 마우스/키보드 이벤트에 대하여 반응안함 상태
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     *
     * @example
     * ```js
     * gridView.disabled = true;
     * ```
     */
    get disabled(): boolean;
    set disabled(value: boolean);
    /**
     * 스크롤바의 너비를 변경
     *
     * @defaultValue `16`
     *
     * @example
     * ```js
     * gridView.scrollBarWidth = 24;
     * ```
     */
    get scrollBarWidth(): number;
    set scrollBarWidth(value: number);
    /**
     * 스크롤바의 높이를 변경
     *
     * @defaultValue `16`
     *
     * @example
     * ```js
     * gridView.scrollBarHeight = 24;
     * ```
     */
    get scrollBarHeight(): number;
    set scrollBarHeight(value: number);
    /**
     * 그리드의 고정 행 및 컬럼에 대한 설정 모델
     *
     * @remarks
     * {@link FixedOptions} 객체를 반환한다.
     * FixedOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.fixedOptions.colCount = 2;
     * ```
     */
    get fixedOptions(): FixedOptions$1;
    /**
     * 그리드 수준에서 관리되는 표시 정보들에 대한 설정 모델
     *
     * @remarks
     * {@link DisplayOptions} 객체를 반환한다.
     * DisplayOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.displayOptions.columnResizable = true;
     * ```
     */
    get displayOptions(): DisplayOptions;
    /**
     * 데이터 필드 값의 변환 형식에 대한 설정 모델
     *
     * @remarks
     * {@link FormatOptions} 객체를 반환한다.
     * FormatOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.formatOptions.datetimeFormat = 'yyyy-mm-dd';
     * ```
     */
    get formatOptions(): FormatOptions$1;
    /**
     * 데이터 편집에 대한 설정 모델
     *
     * @remarks
     * {@link EditOptions} 객체를 반환한다.
     * EditOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.editOptions.deletable = true;
     * ```
     */
    get editOptions(): EditOptions$1;
    /**
     * 편집기에 대한 설정 모델
     *
     * @remarks
     * {@link EditorOptions} 객체를 반환한다.
     * EditorOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.editorOptions.yearDisplayFormat = "{Y}년";
     * ```
     */
    get editorOptions(): EditorOptions$1;
    /**
     * 클립보드에 복사하는 것에 대한 설정 모델
     *
     * @remarks
     * {@link CopyOptions} 객체를 반환한다.
     * CopyOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.copyOptions.singleMode = true;
     * ```
     */
    get copyOptions(): CopyOptions$1;
    /**
     * 클립보드의 데이터를 붙여 넣는 것에 대한 설정 모델
     *
     * @remarks
     * {@link PasteOptions} 객체를 반환한다.
     * PasteOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.pasteOptions.enabled = false;
     * ```
     */
    get pasteOptions(): PasteOptions$1;
    /**
     * 데이터 정렬에 대한 설정 모델
     *
     * @remarks
     * {@link SortingOptions} 객체를 반환한다.
     * SortingOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.sortingOptions.style = 'reverse';
     * ```
     */
    get sortingOptions(): SortingOptions$1;
    /**
     * 데이터 필터링에 대한 설정 모델
     *
     * @remarks
     * {@link FilteringOptions} 객체를 반환한다.
     * FilteringOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.filteringOptions.enabled = false;
     * ```
     */
    get filteringOptions(): FilteringOptions;
    /**
     * 모바일 관련 설정 모델
     *
     * @remarks
     * {@link MobileOptions| mobileOptions} 를 반환한다.
     * MobileOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.mobileOptions.longTapDuration = false;
     * ```
     */
    get mobileOptions(): MobileOptions$1;
    /**
     * 데이터 drag and drop 과 관련 된 설정 모델
     *
     * @remarks
     * {@link DataDropOptions| dataDropOptions} 를 반환한다.
     * DataDropOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.dataDropOptions.dropMode = 'copy';
     * ```
     */
    get dataDropOptions(): DataDropOptions;
    /**
     * 그리드 모바일 화면인 {@link FormView} 에 대한 설정 모델
     *
     * @example
     * ```js
     * gridView.formOptions.autoClose = true;
     * ```
     */
    get formOptions(): FormOptions$1;
    /**
     * 그리드의 인디케이터에 관한 설정 모델
     *
     * @remarks
     * {@link RowIndicator} 객체를 반환한다.
     * RowIndicator 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.rowIndicator.displayValue = 'row';
     * ```
     */
    get rowIndicator(): RowIndicator;
    /**
     * 그리드의 상태바에 관한 설정 모델
     *
     * @remarks
     * {@link StateBar} 객체를 반환한다.
     * StateBar 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.stateBar.mark = 'image';
     * ```
     */
    get stateBar(): StateBar$1;
    /**
     * 그리드의 체크바에 관한 설정 모델
     *
     * @remarks
     * {@link CheckBar} 객체를 반환한다.
     * CheckBar 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.checkBar.visibleOnly = true;
     * ```
     */
    get checkBar(): CheckBar;
    /**
     * 그리드의 헤더 영역에 관한 설정 모델
     *
     * @remarks
     * {@link GridHeader} 객체를 반환한다.
     * GridHeader 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.header.showTooltip = true;
     * ```
     */
    get header(): GridHeader;
    /**
     * 첫번째 푸터에 관한 설정 모델
     *
     * @remarks
     * {@link GridFooter} 객체를 반환한다.
     * GridFooter 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.footer.styleName = 'custom-footer-1';
     * ```
     */
    get footer(): GridFooter$1;
    /**
     * 푸터들에 관한 설정 모델
     *
     * @remarks
     * {@link GridFooter} 의 콜렉션 객체를 반환한다.
     * {@link GridFooterCollection} 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.footers.visible = false;
     * ```
     */
    get footers(): GridFooterCollection$1;
    /**
     * 그리드 헤더 영역에 표시되는 첫번째 Header Summary에 대한 설정 모델
     *
     * @remarks
     * {@link HeaderSummary} 객체를 반환한다.
     * HeaderSummary 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.headerSummary.visible = false;
     * ```
     */
    get headerSummary(): HeaderSummary$1;
    /**
     * 그리드 헤더 영역에 표시되는 Header Summary 에 대한 컬렉션 설정 모델
     *
     * @remarks
     * {@link HeaderSummary} 의 콜렉션 객체를 반환한다.
     * {@link HeaderSummaryCollection} 의 속성을 가져온다.
     *
     * @example
     * ```js
     * gridView.headerSummaries.visible = false;
     * ```
     */
    get headerSummaries(): HeaderSummaryCollection$1;
    /**
     * 그리드의 모바일 전용 화면 모델
     *
     * @example
     * ```js
     * form = gridView.formView;
     * ```
     */
    get formView(): FormView$1;
    /**
     * form view와 grid view 사이에 활성 상태가 변경될 때 발생한다.
     */
    onViewActivated: (grid: GridBase, active: boolean) => void;
    /**
     * 그리드의 focus cell 의 위치 변경을 결정하는 콜백
     *
     * @remarks
     * 변경된 후에는 {@link GridBase.onCurrentChanged | onCurrentChanged} 를 호출한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `oldIndex` - 변경 전 셀 위치정보
     *
     * `newIndex` - 변경 되는 셀 위치정보
     *
     * [반환값] - callback 함수에서 명시적으로 `false`를 반환하면 current가 변경되지 않음
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCurrentChanging =  function (grid, oldIndex, newIndex) {
     *      console.log(oldIndex);
     *      console.log(newIndex);
     *      // return false; 를 하는 경우 위치 변경이 되지 않는다.
     * };
     * ```
     */
    onCurrentChanging: (grid: GridBase, oldIndex: CellIndex$1, newIndex: CellIndex$1) => boolean;
    /**
     * 그리드의 focus cell 의 위치 변경을 알리는 콜백
     *
     * @remarks
     * 변경되기 직전에는 {@link GridBase.onCurrentChanging | onCurrentChanging} 을 호출
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `newIndex` - 변경된 셀 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCurrentChanged =  function (grid, newIndex) {
     *      console.log(newIndex);
     * }
     * ```
     */
    onCurrentChanged: (grid: GridBase, newIndex: CellIndex$1) => void;
    /**
     * 데이터 행의 위치가 변경됨을 알리는 콜백
     *
     * @remarks
     * {@link GridBase.onCurrentChanged | onCurrentChanged }의 경우 선택된 cell의 itemIndex가 변경되는 경우 발생된다.
     * 그러나 {@link GridBase.onCurrentRowChanged | onCurrentRowChanged } 의 경우 선택된 cell의 데이터 행의 index가 변경되는 경우에 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `oldRow` - 변경 전 데이터 행의 위치
     *
     * `newRow` - 변경 후 데이터 행의 위치, `-1`인 경우 신규행이거나 또는 `dataProvider`가 비워진 경우이다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onCurrentRowChanged =  function (grid, oldRow, newRow) {
     *      console.log("oldRow => ", oldRow, "newRow => ", newRow);
     * };
     * ```
     */
    onCurrentRowChanged: (grid: GridBase, oldRow: number, newRow: number) => void;
    /**
     * 셀 편집을 완료하고 다른 셀로 이동할때 Javascript를 통한 사용자 검증 결과를 결정하는 콜백
     *
     * @remarks
     * 해당 컬럼 값에 문제가 있다면 검증 에러와 에러 메시지를 그리드에 반환값으로 전달한다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 컬럼 오브젝트
     *
     * `inserting` - `true`: 열 추가 중, `false`: 열 수정 중
     *
     * `value` - 입력된 필드의 값
     *
     * `itemIndex` - 셀편집된 행의 순서
     *
     * `dataRow` - 셀편집된 행의 고유 번호.
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onValidateColumn =  function (grid, column, inserting, value, itemIndex, dataRow) {
     *      if (column.name != "Knock Knock") {
     *          return {
     *              level: 'warning';
     *              messsage: "It's a dad joke! Do not " + JSON.stringify(column);
     *          }
     *      }
     * };
     * ```
     */
    onValidateColumn: (grid: GridBase, column: GridColumn, inserting: boolean, value: any, itemIndex: number, dataRow: number) => ValidationError$1;
    /**
     * Javascript를 통한 행 단위 사용자 검증 결과를 결정하는 콜백
     *
     * @remarks
     * 해당 행의 값들에 문제가 있다면 검증 에러와 에러 메시지를 그리드에 반환값으로 전달한다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 검증하는 행의 순서
     *
     * `dataRow` - 검증하는 행의 고유 번호
     *
     * `inserting` - true: 열 추가 중, false: 열 수정 중
     *
     * `values` - 입력된 필드들의 값
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onValidateRow =  function (grid, itemIndex, dataRow, inserting, values) {
     *      if (dataRow % 2 === 0) {
     *          return {
     *              level: 'info';
     *              messsage: "even!";
     *          }
     *      }
     * };
     * ```
     */
    onValidateRow: (grid: GridBase, itemIndex: number, dataRow: number, inserting: boolean, values: any[]) => ValidationError$1;
    /**
     * validation 실패시 발생하는 콜백
     *
     * @remarks
     * 콜백함수에서 별도의 에러 처리가 가능하고, err 객체를 return 하면 자체 Validation 메세지가 표시되고 그 외의 경우 표시되지 않는다.
     *
     * `level`과 `message` 값을 포함하는 오브젝트를 그리드에 전달하면 검증에 실패한 것으로 판단한다.
     *
     * {@link ValidationError} 형태로 반환해야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 검증하는 행의 인덱스
     *
     * `column` - 컬럼 오브젝트
     *
     * `error` - 검증 결과
     *
     * [반환값] - {@link ValidationError}
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onValidationFail = function (grid, itemIndex, column, err) {
     *     console.log("onValidationFail:" + itemIndex + "," + JSON.stringify(column) + "," + JSON.stringify(err));
     *     if (column.name != "Mortal") {
     *         var editValue = grid.getEditValue();
     *         err.message = "입력된 "+editValue+" 는 잘못된 값입니다";
     *         return err;
     *     }
     * }
     * ```
     *
     */
    onValidationFail: (grid: GridBase, itemIndex: number, column: GridColumn, error: ValidationError$1) => ValidationError$1;
    /**
     * 사용자의 컬럼 헤더 체크박스를 클릭을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 컬럼 오브젝트
     *
     * `checked` - 체크 여부
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onColumnCheckedChanged =  function (grid, col, chk) {
     *      console.log(col.name + "was checked as: " + chk);
     * };
     * ```
     */
    onColumnCheckedChanged: (grid: GridBase, column: GridColumn, checked: boolean) => void;
    /**
     * 추가한 팝업메뉴 항목의 클릭을 알리는 콜백
     *
     * @remarks
     * MenuItem에 {@link PopupMenuItem.callback | callback} 이 지정된 경우 호출되지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `item` - MenuItem 객체
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onMenuItemClicked =  function (grid, item, clickData) {
     *      console.log(item.label + "was clicked.");
     * };
     * ```
     */
    onMenuItemClicked: (grid: GridBase, item: MenuItem, clickData: ClickData) => void;
    /**
     * 좌표와 함께 ContextMenu 표시를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `x` - ContextMenu 가 호출된 x좌표값
     *
     * `y` - ContextMenu 가 호출된 y좌표값
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * [반환값] - `false`를 반환하면 컨텍스트 메뉴가 표시되지 않는다. 또 menuName을 return하는 경우 해당 menu가 표시된다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onContextMenuPopup =  function (grid, x, y, clickData) {
     *      console.log(clickData);
     * };
     * ```
     */
    onContextMenuPopup: (grid: GridBase, x: number, y: number, clickData: ClickData) => boolean | string;
    /**
     * {@link GridBase.setContextMenu | setContextMenu()} 를 통해 추가한 컨텍스트 메뉴 항목 클릭을 알리는 콜백
     *
     * @remarks
     * MenuItem에 callback이 지정된 경우 호출되지 않는다.
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `item` - 클릭된 메뉴 항목의 정보
     *
     * `clickData` - 클릭 된 아이템의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onContextMenuItemClicked =  function (grid, item, clickData) {
     *      console.log(clickData);
     * };
     * ```
     */
    onContextMenuItemClicked: (grid: GridBase, item: MenuItem, clickData: ClickData) => void;
    /**
     * 사용자가 데이터 셀 내부의 action 버튼을 클릭했을 때 호출한다.
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 데이터 셀이 포함된 아이템의 위치정보
     *
     * `column` - 데이터 셀에 연결된 컬럼
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellButtonClicked =  function (grid, index, col) {
     *      console.log(index);
     * };
     * ```
     */
    onCellButtonClicked: (grid: GridBase, index: CellIndex$1, column: GridColumn) => void;
    /**
     * 사용자가 키보드나 스크롤 바 등을 조작하여 그리드에 마지막 행이 표시될 때 호출되는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onScrollToBottom =  function (grid) {
     *     var data = {"SearchKey":"searchData"},
     *     $.ajax({
     *         url:"/loadData.do",
     *         data: data,
     *         type:"post",
     *         async:false,
     *         success: function (data, textStatus) {
     *             grid.fillJsonData(data.dataList, {fillMode:"append"});
     *         }
     *     })
     * });
     * ```
     */
    onScrollToBottom: (grid: GridBase) => void;
    /**
     * 수직 스크롤 바의 위치가 변경됨을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 스크롤 중일때 그리드 상단에 표시되는 itemIndex 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onTopIndexChanged = function (grid, idx) {
     *      console.log(idx + "was changed!");
     * }
     * ```
     */
    onTopIndexChanged: (grid: GridBase, itemIndex: number) => void;
    /**
     * gridView.topIndex가 변경될때 호출되는 콜백
     *
     * @remarks
     *
     * 스크롤할때 사용자가 지정한 값만큼 이동할때 사용한다.
     * 페이지에 보여지는 값 이상을 return하지 말아야 한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `currentTop` - 변경되기전 topIndex
     *
     * `delta` - 변경값
     *
     * `focusing` - 포커스 변경에 의해서 topIndex가 변경되는 경우 `true`
     *
     * `adjust` - 그리드 내부에서 위치를 조정하는 경우 `true`
     *
     * [반환값] - `number`를 return하면 해당 값만큼 topIndex를 이동한다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * var userSetTopItem = false;
     * grid.onTopIndexChanging = function(_grid, current, delta, focusing, adjust) {
     * // mergeCell을 block처럼 사용하는 경우 스크롤도 block단위로 이동하기 위해서 사용한다.
     * // setTopItem의 경우 이벤트에서는 구분할수 없기 때문에 외부에서 구분할수 있는 값을 주어야 한다.
     * // rowGrouping된 경우는 아래 코드를 그대로 사용할수는 없다.
     *
     *     var fcnt = _grid.fixedOptions.rowCount;
     *     // 첫행으로 이동하거나 마지막행으로 이동되는 경우 또는 그리드 내부에서 위치를 보정하는 경우 'null'을 return하면 원래 이동하려는  delta값 만큼 이동한다.
     *     if (current + delta + _grid.fullItemCount() + fcnt >= _grid.getItemCount() || current + delta === 0 || (adjust && !focusing)) {
     *         console.log(current, delta, `scroll bottom or Top or adjust = ${adjust}`);
     *         return;
     *     }
     *
     *     var top = current + delta;  // 그리드가 이동하려는 topIndex
     *     var items = _grid.getMergedItems(top + fcnt, "merge컬럼", true, true);  // 이동할 block의 items
     *     var curItems = _grid.getMergedItems(current + fcnt, "merge컬럼", true, true);  // 현재 top block의 items
     *
     *     if (delta < 0 || top === items[0] + fcnt || userSetTopItem) {  // 위로 스크롤하거나 fixedRow가 있으면서 최상단으로 이동 또는 사용자가 setTopItem을 했을때
     *         top = items[0]; // 블록의 첫번째 행이 topIndex
     *     } else { // 아래쪽으로 스크롤 했을때
     *         top = items[0] === curItems[0] ? items[items.length - 1] + 1 : top = items[0]
     *     }
     *
     *     return top - current - fcnt;
     * }
     *
     * function setTop(index) {
     *     userSetTopItem = true;
     *     grid.setTopItem(index);
     *     userSetTopItem = false;
     * }
     * ```
     */
    onTopIndexChanging: (grid: GridBase, currentTop: number, delta: number, focusing: boolean, adjust: boolean) => number;
    /**
     * 사용자가 Ctrl+Del 키를 누르거나 {@link GridBase.deleteSelection | deleteSelection() } 으로 삭제할 때, 실제 삭제를 결정하는 콜백
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `rows` - 삭제하려는 행들의 데이터 행 순서들의 배열
     *
     * [반환값] - null이 아닌 값을 반환하면 지정 텍스트를 표시하고 삭제를 취소한다.
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowsDeleting = function (grid, rows) {
     *      console.log('Deleted: ' + rows.join());
     * }
     * ```
     */
    onRowsDeleting: (grid: GridBase, rows: number[]) => boolean;
    /**
     * 사용자가 Insert 키를 눌러 새로운 행을 삽입하거나, 마지막 행에서 아래 화살표를 눌러 행을 추가하는 것을 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 행 삽입 위치의 순서
     *
     * `dataRow` - 행 삽입 위치의 고유 id
     *
     * [반환값] - 행 추가를 금지 시킬 때 사용자에게 표시할 메시지
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowInserting = function (grid, itemIndex, dataRow) {
     *      console.log('Inserted: ' + dataRow + ' at ' + itemIndex);
     * }
     * ```
     */
    onRowInserting: (grid: GridBase, itemIndex: number, dataRow: number) => boolean;
    /**
     * 사용자가 마우스나 키보드로 선택 영역을 변경했을때 기존 선택 영역이 제거 되었음을 알리는 콜백
     *
     * @remarks
     * 기존 선택영역이 없는 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionCleared = function (grid) {
     *      console.log('Selection cleared');
     * }
     * ```
     */
    onSelectionCleared: (grid: GridBase) => void;
    /**
     * 사용자가 마우스나 키보드로 선택 영역의 크기를 변경했음을 알리는 콜백
     *
     * @remarks
     * 변경 중인 선택 영역의 정보는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * {@link DisplayOptions.selectionStyle | GridBase.displayOptions.selectionStyle} 이 {@link SelectionStyle.NONE} 인 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * `selection` - 선택 영역 정보
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionChanged = function (grid) {
     *      console.log('Selection changed!');
     * }
     * ```
     */
    onSelectionChanged: (grid: GridBase, selection: Selection) => void;
    /**
     * 선택 영역이 새로 추가됨을 알리는 콜백
     * @deprecated
     * 2.6.0 버전 이후 제거될 예정
     *
     * @remarks
     * 변경 중인 선택 영역의 정보는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * {@link Selection.style | GridBase.getSelection().style} 이 {@link SelectionStyle.NONE} 인 경우 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `selection` - 선택 영역 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSelectionAdded = function (grid, selection) {
     *      console.log(selection);
     * }
     * ```
     */
    onSelectionAdded: (grid: GridBase, selection: Selection) => void;
    /**
     * 사용자가 마우스로 선택 영역 변경 완료를 알리는 콜백
     * @deprecated
     * 2.6.0 버전 이후 제거될 예정
     *
     * @remarks
     * 변경된 선택 영역의 정보는 {@link GridBase.getSelection | getSelection} 함수로 알수 있고 선택영역의 데이터는 {@link GridBase.getSelectionData | getSelectionData} 함수로 알 수 있다.
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * `selection` - 선택 영역 정보
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onSelectionEnded = function (grid) {
     *      let cells = grid.getSelectionData();
     *      console.log(cells);
     * }
     * ```
     */
    onSelectionEnded: (grid: GridBase, selection: Selection) => void;
    /**
     * Cell 별로 열리는 Editor 의 표시를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집기가 열리려는 셀의 위치정보
     *
     * `props` - {@link CellEditor | 셀 편집기} 설정 정보
     *
     * `attrs` - 내부 편집기 element attributes. 사용자가 임의로 지정할 수 있는 값들.
     *
     * [반환값] - false 를 return하면 Editor가 표시되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onShowEditor = function (grid, index, props, attrs) {
     *      console.log("onShowEditor:" + index.itemIndex + "," + index.column);
     *      if (index.column == "OrderID") {
     * 	        props.textCase = 'upper';
     *      }
     * }
     * ```
     */
    onShowEditor: (grid: GridBase, index: CellIndex$1, props: any, attrs: any) => boolean;
    /**
     * 편집이 완료되고 편집기가 사라진 것을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집된 셀의 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onHideEditor = function (grid, index) {
     *      console.log("onHideEditor:" + index.itemIndex + "," + index.column);
     * }
     * ```
     */
    onHideEditor: (grid: GridBase, index: CellIndex$1) => void;
    /**
     * 아이템이 사용자의 Key 입력 등으로 값이 변경되었음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 현재 focus 된 셀의 위치정보
     *
     * `value` - 편집 중인 셀의 데이터 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditChange = function (grid, index, value) {
     *      console.log("grid.onEditChange driven, " + index.column + ' at ' + index.dataRow + ' was replaced by value: ' + value);
     * }
     * ```
     */
    onEditChange: (grid: GridBase, index: CellIndex$1, value: any) => void;
    /**
     * 셀 편집이 완료되었을 때 셀의 위차와 편집결과를 갖고 있는 콜백
     *
     * @remarks
     * DropDownCellEditor, SearchCellEditor, MultiCheckCellEditor의 경우 editResult.text에는 labels에 해당하는 값이 출력되고 editResult.value에는 values에 해당하는 값이 출력된다.
     *
     * DateCellEditor의 경우에는 editResult.text에는 editor의 datetimeFormat으로 Formatting된 값이 출력되고 editResult.value에는 Date객체가 출력된다.
     *
     * 다른 Editor의 경우 text와 value에 동일한 값이 출력된다.
     *
     * {@link EditResult} 의 형태로 출력된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집된 셀의 위치정보
     *
     * `editResult` - 편집된 셀의 text와 value를 속성으로 갖는 단순한 객체, 셀 편집기의 종류에 따라 출력되는 값이 달라진다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGetEditValue = function (grid, index, editResult) {
     *      console.log(editResult);
     * }
     * ```
     */
    onGetEditValue: (grid: GridBase, index: CellIndex$1, editResult: Object) => void;
    /**
     * 사용자 입력이 셀에 반영함을 결정하는 콜백
     *
     * @remarks
     * 편집 중인 셀에서 다른 셀로 이동하거나 또는 {@link GridBase.commitEditor | commitEditor()} 를 호출하면 발생한다.
     * {@link GridBase.setValue | setValue()} 등 사용자 코드로 변경될때는 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 변경된 셀의 위치 정보
     *
     * `oldValue` - 편집전 셀의 데이터 값
     *
     * `newValue` - 편집후 셀의 데이터 값
     *
     * [반환값] - `false` 를 반환 시 셀에 반영되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditCommit = function (grid, index, oldValue, newValue) {
     *      if (newValue === '') {
     *          return false;
     *      }
     *      console.log(oldValue + 'was changed to ' + newValue);
     * }
     * ```
     */
    onEditCommit: (grid: GridBase, index: CellIndex$1, oldValue: any, newValue: any) => boolean;
    /**
     * 사용자가 편집중 ESCAPE 키를 입력하거나 {@link GridBase.cancel | cancel()} 이 호출되어 편집이 취소됨을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 편집이 취소된 데이터 셀의 위치정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditCommit = function (grid, index) {
     *      console.log("Edit Cannceled at " + index.column);
     * }
     * ```
     */
    onEditCanceled: (grid: GridBase, index: CellIndex$1) => void;
    /**
     * 사용자가 행 편집을 취소했음을 알리는 콜백
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집이 취소된 행의 순서
     *
     * `state` - 편집 취소된 행의 상태
     *
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemEditCanceled = function (grid, itemIndex, state) {
     *      console.log(state);
     * }
     * ```
     */
    onItemEditCanceled: (grid: GridBase, itemIndex: number, state: string) => void;
    /**
     * 사용자가 행 편집을 취소를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집이 취소된 행의 순서
     *
     * `state` - 편집 취소된 행의 상태이다. updating, inserting, appending 이 반환된다.
     *
     * [반환값] - 기본값: `true`, `false` 를 반환하면 행 편집 취소가 취소된다. (계속 편집 상태)
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemEditCancel = function (grid, itemIndex, state) {
     *      console.log(state);
     *      if (itemIndex % 5 === 0) {
     *          return false;
     *      }
     * }
     * ```
     */
    onItemEditCancel: (grid: GridBase, itemIndex: number, state: string) => boolean;
    /**
     * 검색을 했음을 알리는 콜백
     *
     * @remarks
     * {@link SearchCellEditor}에서 {@link SearchCellEditor.searchLength | searchLenght} 와 {@link SearchCellEditor.searchDelay | searchDelay} 조건이 만족하면 발생한다. 또는 Ctrl+Enter 키 또는 Enter 키를 입력시 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 변경된 셀 위치정보
     *
     * `text` - 셀에 입력된 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditSearch = function (grid, index, text) {
     *      console.log(text + ' was searched!');
     * }
     * ```
     *
     */
    onEditSearch: (grid: GridBase, index: CellIndex$1, text: string) => void;
    /**
     * {@link SearchCellEditor} 에서 버튼을 클릭했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 셀 위치정보
     *
     * `text` - 셀에 입력된 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSearchCellButtonClick = function (grid, index, text) {
     *      console.log(text + ' button was clicked!');
     * }
     * ```
     *
     */
    onSearchCellButtonClick: (grid: GridBase, index: CellIndex$1, text: string) => void;
    /**
     * 수정이나 추가 중인 편집 아이템의 한 필드값이 편집 완료되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 편집 중인 행의 순서
     *
     * `row` - 편집 중인 행의 고유 번호
     *
     * `field` - 방금 편집된 필드의 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellEdited = function (grid, itemIndex, row, field) {
     *      console.log('Edit done! at ' + itemIndex + ', ' + field);
     * }
     * ```
     *
     */
    onCellEdited: (grid: GridBase, itemIndex: number, row: number, field: number) => void;
    /**
     * 사용자 입력으로 변경된 값이 행에 반영되었음을 알리는 콜백
     *
     * @remarks
     * {@link PasteOptions.noEditEvent | pasteOptions.noEditEvent} 가 `true` 면 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 변경된 행의 순서
     *
     * `row` - 변경된 행의 고유 번호
     *
     * `field` - 변경된 필드의 인덱스
     *
     * `oldValue` - 편집전 셀의 데이터 값
     *
     * `newValue` - 편집후 셀의 데이터 값
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditRowChanged = function (grid, itemIndex, dataRow, field, oldValue, newValue) {
     *     let v = grid.getValue(itemIndex, field);
     *     console.log("onEditRowChanged, " + field + ": " + oldValue + " => " + newValue);
     * };
     * ```
     */
    onEditRowChanged: (grid: GridBase, itemIndex: number, row: number, field: number, oldValue: any, newValue: any) => void;
    /**
     * 그리드 셀에 붙여넣기 했음을 알리는 콜백
     *
     * @remarks
     * 여러 행을 붙여넣기 할때는 {@link GridBase.onRowsPasted | onRowsPasted} 참조
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 변경된 행의 순서
     *
     * `row` - 변경된 행의 고유 번호
     *
     * `fields` - 필드의 인덱스들
     *
     * `oldValues` - 편집전 셀의 데이터 값들
     *
     * `newValues` - 편집후 셀의 데이터 값들
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onEditRowPasted = function (grid, itemIndex, row, fields, oldValues, newValues) {
     *     console.log('Row pasted!: {' + newValues.join() + '}');
     * };
     * ```
     */
    onEditRowPasted: (grid: GridBase, itemIndex: number, row: number, fields: number[], oldValues: any[], newValues: any[]) => void;
    /**
     * 여러 행을 붙여넣기 했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `items` - 붙여넣기된 행들의 그리드에서의 순서
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onRowsPasted = function (grid, items) {
     *     console.log('Rows pasted!: ' + items.join());
     * };
     * ```
     *
     */
    onRowsPasted: (grid: GridBase, items: number[]) => void;
    /**
     * 셀에 붙여넣기를 결정하는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 데이터 셀의 위치정보
     *
     * `value` - 붙여넣기 중인 데이터 값
     *
     * [반환값] - `false`를 반환하면 그 셀에는 붙여넣기가 되지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellPasting = function (grid, index, value) {
     *      if (value === 'hello') {
     *          return false;
     *      }
     * };
     * ```
     */
    onCellPasting: (grid: GridBase, index: CellIndex$1, value: any) => boolean;
    /**
     * 사용자가 checkBar의 체크박스를 클릭하거나 checkItem을 호출하여 체크를 변경했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `itemIndex` - 체크된 데이터 행의 순서
     *
     * `checked` - 체크가 되었으면 `true`, 해제되었으면 `false`가 출력
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemChecked = function (grid, itemIndex, checked) {
     *     console.log('Checked as ' + checked + ' at ' + itemIndex);
     * };
     * ```
     */
    onItemChecked: (grid: GridBase, itemIndex: number, checked: boolean) => void;
    /**
     * 사용자가 checkBar의 Header를 클릭하여 전체선택, 해제를 하거나 또는 checkAll `true` / `false` 을 입력하여 전체선택, 해제를 했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `checked` - 체크가 되었으면 true, 해제가 되었으면 false가 출력
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onItemAllChecked = function (grid, checked) {
     *     console.log('All checked as ' + checked);
     * };
     * ```
     */
    onItemAllChecked: (grid: GridBase, checked: boolean) => void;
    /**
     * 그리드에 발생한 에러창을 클릭했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `error` - 에러 메세지
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onErrorClicked = function (grid, error) {
     *     console.log(error);
     * }
     * ```
     */
    onErrorClicked: (grid: GridBase, error: string) => void;
    /**
     * 정렬을 결정하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `fields` - 정렬하는 필드의 목록
     *
     * `direction` - 각 필드에 대한 정렬 방식 목록
     *
     * [반환값] - `false` 를 반환하면 정렬은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSorting = function (grid) {
     *      if (fields.length > 5) {
     *          return false;
     *      }
     * }
     * ```
     */
    onSorting: (grid: GridBase, fields: number[], directions: string[]) => boolean;
    /**
     * 정렬했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onSortingChanged = function (grid) {
     *     console.log('Sorted! ');
     * }
     * ```
     *
     */
    onSortingChanged: (grid: GridBase) => void;
    /**
     * 필터링을 결정하는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * [반환값] - 기본값: `true`, 필터링 실행 여부를 지정한다. `false` 를 반환하면 필터링은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onFiltering = function (grid) {
     *      return false;
     * }
     * ```
     */
    onFiltering: (grid: GridBase) => boolean;
    /**
     * 컬럼에 필터들이 설정되어 있고, 그 필터의 상태가 변경되었음을 알리는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 필터링된 컬럼 정보
     *
     * `filter` - 해당 필터의 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onFilteringChanged = function (grid, column, filter) {
     *      console.log('Filter changed!');
     * }
     * ```
     */
    onFilteringChanged: (grid: GridBase, column: GridColumn, filter: ColumnFilter$1) => void;
    /**
     * 키 입력을 결정하는 콜백
     *
     * @remarks
     * KeyDown 될 때 발생한다.
     * 키를 입력하고 있는 동안 계속 발생된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * [반환값] - 키 입력을 금지할때 false 를 반환한다/
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onKeyDown = function (grid, event) {
     *      console.log('You pressed... ' + "event);
     * }
     * ```
     */
    onKeyDown: (grid: GridBase, event: KeyboardEvent) => boolean;
    /**
     * 키가 입력되고 있음을 알리는 콜백
     *
     * @remarks
     * KeyPress 될 때 발생한다.
     * 키를 입력하고 있는 동안 계속 발생된다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onKeypross = function (grid, event) {
     *      console.log('You are pressing... ' + event);
     * }
     * ```
     */
    onKeyPress: (grid: GridBase, event: KeyboardEvent) => void;
    /**
     * 키를 입력하였음을 알리는 콜백.
     *
     * @remarks
     * KeyUp 될 때 발생한다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `event` - KeyboardEvent
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onKeyUp = function (grid, event) {
     *      console.log('You pressed... ' + "event);
     * }
     * ```
     */
    onKeyUp: (grid: GridBase, event: KeyboardEvent) => void;
    /**
     * 데이터 셀의 툴팁이 표시되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤.
     *
     * `index` - 마우스 포인터가 위치한 영역의 셀 위치정보
     *
     * `value` - 마우스 포인터가 위치한 데이터
     *
     * [반환값] - 툴팁에 표시할 값. 아무것도 return 하지 않으면 데이터 셀 값과 셀 정보가 툴팁에 표시된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onShowTooltip = function (grid, index, value) {
     *      if (index % 7 === 0) {
     *              return '7-multiple Row!'
     *      }
     * }
     * ```
     */
    onShowTooltip: (grid: GridBase, index: CellIndex$1, value: any) => any;
    /**
     * 컬럼 헤더의 툴팁이 표시되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 툴팁이 표시될 컬럼
     *
     * `value` - 툴팁에 표시될 값. 기본값으로 컬럼헤더 text가 전달된다.
     *
     * [반환값] - 툴팁에 표시할 값. 아무것도 return 하지 않으면 컬럼명과 데이터 셀 값이 툴팁에 표시된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onShowHeaderTooltip = function (grid, index, value) {
     *     return 'header-tooltip: ' + value;
     * }
     * ```
     */
    onShowHeaderTooltip: (grid: GridBase, column: GridColumn, value: any) => any;
    /**
     *
     * @deprecated
     * 컬럼의 속성 중 width, displayIndex, visible 속성값이 변경되었음을 알리는 콜백
     * {@link GridBase.onLayoutPropertyChanged}로 대체
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `column` - 변경된 컬럼의 정보
     *
     * `property` - 컬럼의 displayWidth, displayIndex, visible 속성 중 변경된 것
     *
     * `value` - 변경된 값이 전달된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onColumnPropertyChanged = function (grid, column, property, newValue, oldValue) {
     *
     *         console.log(column + "s props werer changed!");
     * }
     * ```
     */
    onColumnPropertyChanged: (grid: GridBase, column: GridColumn, property: string, newValue: any, oldValue: any) => void;
    /**
     *
     * Layout의 속성 중 displayWidth, displayIndex, visible 속성값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `layout` - 변경된 layout의 정보
     *
     * `property` - 컬럼의 displayWidth, displayIndex, visible 속성 중 변경된 것
     *
     * `newValue` - 변경후 값이 전달된다.
     *
     * `oldValue` - 변경전 값이 전달된다.
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onLayoutPropertyChanged = function (grid, layout, property, newValue, oldValue) {
     *
     *         console.log(layout + "s props werer changed!");
     * }
     * ```
     */
    onLayoutPropertyChanged: (grid: GridBase, layout: CellLayoutItem$1, property: string, newValue: any, oldValue: any) => void;
    /**
     * 그리드가 선택되었음을 알리는 콜백
     *
     * @remarks
     * grid를 전역변수에 저장해서 사용하는 것이 좋다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGridActivated = function (grid) {
     *      alert('Selected!');
     * }
     * ```
     */
    onGridActivated: (grid: GridBase) => void;
    /**
     * control + c 키로 복사하기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `selection` - 선택 영역 정보
     *
     * `event` - 이벤트 정보 ({@link https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent| ClipboardEvent})
     *
     * [반환값] - `false`를 반환하면 복사하기가 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCopy = function(grid, selection, event) {
     *      let data = JSON.stringify(grid.getSelectionData());
     *      if (data) {
     *      	data = 'onCopy\r\n' + data;
     *      	if (window.clipboardData) {
     *      		window.clipboardData.setData("Text", data);
     *      	} else {
     *      		event.clipboardData.setData('text/plain', data);
     *      	}
     *      }
     *      return false;
     * }
     * ```
     */
    onCopy: (grid: GridBase, selection: Selection | Selection[], event: ClipboardEvent) => boolean;
    /**
     * 그리드에 붙여넣기를 결정하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 셀 위치정보
     *
     * `event` - 이벤트 정보 ({@link https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent| ClipboardEvent})
     *
     * [반환값] - `false`를 반환하면 붙여넣기가 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPaste = function (grid, index, event){
     *     console.log("Pasting Starts!");
     * }
     * ```
     */
    onPaste: (grid: GridBase, index: CellIndex$1, event: ClipboardEvent) => boolean;
    /**
     * 그리드에 붙여넣기 했음을 알리는 콜백
     *
     * @remarks
     * 입력 편집기가 표시된 상태에서는 발생하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPasted = function (grid){
     *     console.log("Pasted!");
     * }
     * ```
     */
    onPasted: (grid: GridBase) => void;
    /**
     * 사용자가 checkBar의 체크박스를 클릭하거나 checkItem을 호출하여 체크를 변경했음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `items` - 체크된 데이터 행의 순서
     *
     * `checked` - `true`: 체크, `false`: 해제
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onItemsChecked = function (grid, items, checked){
     *     console.log(items.join() + ' are checked as ' + checked);
     * }
     * ```
     */
    onItemsChecked: (grid: GridBase, items: number[], checked: boolean) => void;
    /**
     * 그리드 셀이 클릭되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellClicked = function (grid, clickData) {
     *      console.log(clickData);
     * }
     * ```
     */
    onCellClicked: (grid: GridBase, clickData: ClickData) => void;
    /**
     * 그리드 셀이 더블 클릭되었음을 알리는 콜백
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCellDblClicked = function (grid, clickData) {
     *      console.log(clickData);
     * }
     * ```
     */
    onCellDblClicked: (grid: GridBase, clickData: ClickData) => void;
    /**
     * 그리드 셀에 포함된 엘리먼트가 클릭되었음을 알리는 콜백
     *
     * @remarks
     * 이 이벤트 내에서 클릭을 처리했다면 반드시 `false`를 리턴해야 element의 기본 동작을 실행하지 않는다.
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `index` - 클릭된 데이터 셀의 위치정보
     *
     * `clickData` - 클릭된 셀 정보
     *
     * @defaultValue `null`
     * @eventProperty
     * @example
     * ```js
     * gridView.onCellItemClicked = function (grid, index, clickData) {
     *      console.log(clickData);
     *      return true;
     * }
     * ```
     */
    onCellItemClicked: (grid: GridBase, index: CellIndex$1, clickData: ClickData) => boolean;
    /**
     * CommandStack이 바뀌었음을 알리는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * `undoable` - 뒤로
     *
     * `redoable` - 앞으로
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onCommandStackChanged =  function (grid, undoable, redoable) {
     *      if (undoable === true) {
     *          console.log('You can undo now!');
     *      }
     * };
     * ```
     */
    onCommandStackChanged: (grid: GridBase, undoable: boolean, redoable: boolean) => void;
    /**
     * dataProvider.setRows()를 실행한 이후 그리드 refresh가 완료된 후 발생하는 콜백
     *
     * @remarks
     *
     * [매개변수 목록]
     *
     * `grid` - GridBase 컨트롤
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onDataLoadComplated =  function (grid) {
     *      console.log("Grid DataLoadComplated")
     * };
     * ```
     */
    onDataLoadComplated: (grid: GridBase) => void;
    /**
     * alert 창에 입력된 메시지를 표시한다.
     *
     * @param message - 입력된 메세지
     * @example
     *
     * ```
     * gridView.ping("테스트");
     * ```
     */
    ping(message: any): void;
    /**
     * 그리드를 내부적으로 새로 그린다.
     *
     * @example
     * ```
     * gridView.refresh()
     * ```
     */
    refresh(force: boolean): void;
    /**
     * 그리드와 관련된 속성들이 변경될 때마다 update lock 을 걸어 내부적인 변경 처리 호출을 지연시킨다.
     *
     * @remarks
     * {@link GridBase.endUpdate | endUpdate()} 와 같이 사용한다.
     *
     * @example
     *
     * ```js
     * gridview.beginUpdate();
     * try {
     *     gridview.displayOptions( { ... });
     *     gridview.selectOptions( { ... });
     * ...
     * } finally {
     *     gridview.endUpdate();
     * }
     * ```
     */
    beginUpdate(): void;
    /**
     * update lock 을 풀고 그리드를 다시 그린다.
     *
     * @remarks
     * {@link GridBase.beginUpdate | beginUpdate()} 와 같이 사용한다.
     *
     * @param force - beginUpdate() 의 호출 여부에 상관없이 그리드를 다시 그린다.
     *
     * @example
     * {@link GridBase.beginUpdate | beginUpdate()} 참조
     */
    endUpdate(force: boolean): void;
    /**
     * 그리드가 표시된 상태면 `true` 를 반환한다.
     *
     * ```js
     * let visible = gridView.isVisible();
     * ```
     */
    isVisible(): boolean;
    /**
     * 그리드를 표시하거나 감춘다.
     *
     * @param value - `true`: 그리드 표시, `false`: 그리드 감추기
     *
     * @example
     * ```js
     * gridView.setVisible(false);
     * ```
     */
    setVisible(value: boolean): void;
    /**
     * 그리드에 현재 표시된 Grid Item 개수를 반환한다.
     *
     * @remarks
     * rowGroup의 header, footer가 있는 경우 itemCount에 포함된다.
     *
     * @example
     * ```js
     * let count = gridView.getItemCount();
     * ```
     */
    getItemCount(): number;
    /**
     * 지정한 그리드 행의 고유 번호를 반환한다.
     *
     * @param itemIndex - 행의 순서
     *
     * @example
     * ```js
     * let row = gridView.getDataRow(0);
     * ```
     */
    getDataRow(itemIndex: number): number;
    /**
     * 지정한 그리드 행들의 고유 번호들을 반환한다.
     *
     * @param items - 행의 순서의 배열
     *
     * @example
     * ```js
     * let rows = gridView.getRowsOfItems([0, 2, 4, 6]);
     * ```
     */
    getRowsOfItems(items: number[]): number[];
    /**
     * 행의 고유 번호로 행의 순서를 반환한다.
     *
     * @param dataRow - 행의 고유 번호
     *
     * ```
     * let answerRow = gridView.getItemIndex(42);
     * ```
     */
    getItemIndex(dataRow: number): number;
    /**
     * 입력된 데이터 행들의 고유번호들로 행들의 순서들을 반환한다.
     *
     * @param rows - 행의 고유 번호의 배열
     *
     * @example
     * let harshadRows = getItemsOfRows([10, 12, 18, 142857]);
     *
     */
    getItemsOfRows(rows: number[]): number[];
    /**
     * 해당 컬럼을 제거한다.
     *
     * @param column - 제거할 컬럼 이름
     *
     * @example
     * ```js
     * gridView.removeColumn('KorName');
     * ```
     *
     */
    removeColumn(name: string): boolean;
    /**
     * 그리드의 칼럼위치를 최초상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.restoreColumns();
     * ```
     *
     */
    restoreColumns(): void;
    /**
     * 그리드에 연결되어 있는 DataProvider를 반환한다.
     * @example
     * ```js
     * let ds = gridView.getDataSource();
     * ```
     */
    getDataSource(): LocalDataProvider | LocalTreeDataProvider;
    /**
     * 그리드에 Data Provider를 연결한다.
     *
     * @param dataProvider - DataProvider 객체.
     *
     * @example
     * ```js
     * let dataProvider = new RealGrid.LocalDataProvider();
     * gridView = new RealGrid.GridView("realgrid");
     * gridView.setDataSource(dataProvider);
     * ```
     */
    setDataSource(dataProvider: LocalDataProvider | LocalTreeDataProvider): void;
    /**
     * 그리드 옵션 정보를 반환한다.
     *
     * @remarks
     * {@link GridOptions} 의 모델로 반환한다.
     *
     * @returns {@link GridBase.setOptions | setOptions } 와 다르게 그리드 수준의 정보만을 반환한다.
     *
     * @example
     * ```js
     * let options = gridView.getOptions();
     * ```
     */
    getOptions(): GridOptions;
    /**
     * 그리드 옵션 정보를 재설정한다.
     *
     * @remarks
     * 그리드 수준의 정보만을 반환하는 {@link GridBase.getOptions | getOptions } 와 달리 이 method를 통해 하위 구성 요소 및 다른 실행 정보들을 동시에 재설정할 수 있다.
     * {@link GridOptions} 의 모델로 설정한다.
     *
     * @param options - 설정 정보
     * @example
     * ```js
     * let options =  {
     *     summaryMode: 'aggregate',
     *     displayOptions: {
     *         columnResizable : false
     *     }
     * };
     * gridView.setOptions(options);
     * ```
     */
    setOptions(options: GridOptions): void;
    /**
     * 그리드 고정 영역에 관한 설정 정보들을 {@link FixedOptions} 의 모델로 반환한다.
     *
     * @example
     * ```js
     * let fixed = gridView.getFixedOptions();
     * fixed.colCount = 1;
     * gridView.setFixedOptions(fixed);
     * ```
     */
    getFixedOptions(): FixedOptions$1;
    /**
     * 그리드 고정 영역에 관한 정보를 {@link FixedOptions} 의 모델로 설정한다.
     *
     * @param options - {@link FixedOptions} 모델과 같은 설정 정보. 변경하고자 하는 값들만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setFixedOptions({colCount: 2});
     * ```
     */
    setFixedOptions(options: FixedOptions$1): void;
    /**
     * 그리드 표시와 관련된 설정 정보들을 {@link DisplayOptions} 의 모델로 반환한다.
     *
     * @example
     * ```js
     * let display = gridView.getDisplayOptions();
     * display.rowHeight = 20;
     * gridView.setDisplayOptions(display);
     * ```
     */
    getDisplayOptions(): DisplayOptions;
    /**
     * 그리드 표시 정보를 {@link DisplayOptions} 모델로 설정한다.
     *
     * @param options - {@link DisplayOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setDisplayOptions({rowResizable: true});
     * ```
     */
    setDisplayOptions(options: DisplayOptions): void;
    /**
     * 그리드의 {@link FormatOptions} 를 반환한다.
     *
     * @example
     * ```js
     * let format = gridView.getFormatOptions();
     * format.booleanFormat = 'X:O';
     * gridView.setFormatOptions(format);
     * ```
     */
    getFormatOptions(): FormatOptions$1;
    /**
     * 그리드의 {@link FormatOptions} 를 설정한다.
     *
     *
     * @param options - {@link FormatOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setFormatOptions({booleanFormat: 'wrong:correct'});
     * ```
     */
    setFormatOptions(options: FormatOptions$1): void;
    /**
     * 그리드 편집 방식과 관련된 정보들을 {@link EditOptions} 모델로 반환한다.
     * @example
     * ```js
     * let edit = gridView.getEditOptions();
     * edit.editable = true;
     * gridView.setEditOptions(edit);
     * ```
     */
    getEditOptions(): EditOptions$1;
    /**
     * 그리드 편집 방식과 관련된 정보들을 {@link EditOptions} 모델로 재설정한다.
     *
     * @param options - {@link EditOptions} 모델과 같은 설정 정보. 변경하고자 하는 값들만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setEditOptions({editable: false});
     * ```
     */
    setEditOptions(options: EditOptions$1): void;
    /**
     * 편집기 표시 정보를 {@link EditorOptions} 모델로 반환한다.
     * @example
     * ```js
     * let editor = gridView.getEditorOptions();
     * editor.yearDisplayFormat = '{Y} year';
     * gridView.setEditorOptions(editor);
     * ```
     */
    getEditorOptions(): EditorOptions$1;
    /**
     * 편집기 표시 정보를 {@link EditorOptions} 모델로 설정한다.
     *
     * @remarks
     * 날자 편집기의 표시형태를 변경하는 경우 달력 팝업이 최초 실행(생성)되기 전에 먼저 설정되어야 한다(한번 실행되고난 후 중간에 변경할 수 없음).
     *
     * @param options - {@link EditorOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setEditorOptions({yearDisplayFormat: "{Y} year"});
     * ```
     */
    setEditorOptions(options: EditorOptions$1): void;
    /**
     * ctrl+c 를 이용해서 그리드를 복사할때 적용되는 설정을 {@link CopyOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let copy = gridView.getCopyOptions();
     * copy.enabled = false;
     * gridView.setCopyOptions(copy);
     * ```
     */
    getCopyOptions(): CopyOptions$1;
    /**
     * 복사 정보를 {@link CopyOptions} 모델로 설정한다.
     *
     * @param options - {@link CopyOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setCopyOptions({enabled: false});
     * ```
     */
    setCopyOptions(options: CopyOptions$1): void;
    /**
     * 그리드에 붙여넣기를 할때 적용되는 설정을 {@link PasteOptions} 모델로 반환한다.
     * @example
     * ```js
     * let paste = gridView.getPasteOptions();
     * paste.enabled = false;
     * gridView.setPasteOptions(paste);
     * ```
     */
    getPasteOptions(): PasteOptions$1;
    /**
     * 그리드에 {@link PasteOptions} 모델로 붙여넣기 정보를 설정한다.
     *
     * @param options - PasteOptions 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setPasteOptions({enabled: false});
     * ```
     */
    setPasteOptions(options: PasteOptions$1): void;
    /**
     * 그리드 정렬과 관련된 설정 정보들을 {@link SortingOptions} 모델로 반환한다.
     * @example
     * ```js
     * let sorting = gridView.getSortingOptions();
     * sorting.enabled = false;
     * gridView.setSortingOptions(sorting);
     * ```
     */
    getSortingOptions(): SortingOptions$1;
    /**
     * 그리드 정렬과 관련된 정보들을 {@link SortingOptions} 모델로 설정한다.
     *
     * @remarks
     * {@link ToastOptions} 는 속성으로 직접 접근해서 수정해야한다.
     *
     * @param options - {@link SortingOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setSortingOptions({enabled: false});
     * ```
     */
    setSortingOptions(options: SortingOptions$1): void;
    /**
     * 그리드 필터링과 관련된 설정 정보들을 {@link FilteringOptions} 모델로 반환한다.
     * @example
     * ```js
     * let filtering = gridView.getFiteringOptions();
     * filtering.enabled = false;
     * gridView.setFiteringOptions(filtering);
     * ```
     */
    getFilteringOptions(): FilteringOptions;
    /**
     * 그리드 필터링과 관련된 정보들을 {@link FilteringOptions} 모델로 설정한다.
     *
     * @remarks
     * {@link FilterSelectorOptions}, {@link FilterAutomatingOptions}, {@link ToastOptions} 는 속성으로 직접 접근해서 수정해야한다.
     *
     * @param options - {@link FilteringOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setFilteringOptions({enabled: false});
     * ```
     */
    setFilteringOptions(options: FilteringOptions): void;
    /**
     * 모바일과 관련된 설정 정보들을 {@link MobileOptions} 모델로 반환한다.
     * @example
     * ```js
     * let mobile = gridView.getMobileOptions();
     * mobile.longTabDuration = 400;
     * gridView.setMobileOptions(mobile);
     * ```
     */
    getMobileOptions(): MobileOptions$1;
    /**
     * 모바일과 관련된 설정 정보들을 {@link MobileOptions} 모델로 설정한다.
     *
     * @param options - {@link MobileOptions} 모델과 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setMobileOptions({longTapDuration: 300});
     * ```
     */
    setMobileOptions(options: MobileOptions$1): void;
    /**
     * 데이터 drag 앤 drop과 관련 된 설정 정보들을 {@link DataDropOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let drop = gridView.getDataDropOptions();
     * drop.dropMode = 'copy'
     * gridView.setDataDropOptions(drop);
     * ```
     */
    getDataDropOptions(): DataDropOptions;
    /**
     * 데이터 drag 앤 drop과 관련 된 설정 정보들을 {@link DataDropOptions} 모델로 설정한다.
     *
     * @param options - {@link DataDropOptions} 와 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * gridView.setDataDropOptions({dropMode: 'copy'});
     * ```
     */
    setDataDropOptions(options: DataDropOptions): void;
    /**
     * {@link FormView}에 대한 설정 정보들을 {@link FormOptions} 모델로 반환한다.
     *
     * @example
     * ```js
     * let formOpts = gridView.getFormOptions();
     * ```
     */
    getFormOptions(): FormOptions$1;
    /**
     * {@link FormView}에 대한 설정 정보들을 {@link FormOptions} 모델로 설정한다.
     *
     * @param options - {@link FormOptions} 와 같은 설정 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * gridView.setFormOptions({autoClose: true});
     * ```
     */
    setFormOptions(options: FormOptions$1): void;
    /**
     * 그리드 인디케이터와 관련된 설정 정보들을 {@link RowIndicator} 모델로 반환한다.
     * @example
     * ```js
     * let indicator = gridView.getRowIndicator();
     * indicator.zeroBase = true;
     * gridView.setRowIndicator(indicator);
     * ```
     */
    getRowIndicator(): RowIndicator;
    /**
     * 그리드 인디케이터와 관련된 설정 정보들을 {@link RowIndicator} 모델로 설정한다.
     *
     * @param value - RowIndicator 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setRowIndicator({zeroBase: true});
     * ```
     */
    setRowIndicator(value: RowIndicator): void;
    /**
     * 그리드 상태바의 설정 정보를 {@link StateBar} 의 모델로 반환한다.
     * @example
     * ```js
     * let stateBar = gridView.getStateBar();
     * stateBar.errorVisible = false;
     * gridView.setStateBar(stateBar);
     * ```
     */
    getStateBar(): StateBar$1;
    /**
     * 그리드 상태바의 설정 정보를 {@link StateBar} 의 모델로 설정한다.
     *
     * @param value - {@link StateBar} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setStateBar({errorVisible: true});
     * ```
     */
    setStateBar(value: StateBar$1): void;
    /**
     * 그리드 체크바와 관련된 설정 정보를 {@link CheckBar} 의 모델로 반환한다.
     * @example
     * ```js
     * let checkBar = gridView.getCheckBar();
     * checkBar.exclusive = false;
     * gridView.setStateBar(checkBar);
     * ```
     */
    getCheckBar(): CheckBar;
    /**
     * 그리드 체크바의 설정 정보를 {@link CheckBar} 의 모델로 설정한다.
     *
     * @param value - {@link CheckBar} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setCheckBar({exclusive: true});
     * ```
     */
    setCheckBar(value: CheckBar): void;
    /**
     * 그리드 헤더와 관련된 설정 정보들을 {@link GridHeader} 모델로 반환한다.
     * @example
     * ```js
     * let header = gridView.getHeader();
     * header.sortable = false;
     * gridView.setHeader(header);
     * ```
     */
    getHeader(): GridHeader;
    /**
     * 그리드 헤더의 설정 정보를 {@link GridHeader} 모델로 설정한다.
     *
     * @param value - {@link GridHeader} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setHeader({sortable: false});
     * ```
     */
    setHeader(value: GridHeader): void;
    /**
     * 첫번째 그리드 푸터와 관련된 설정 정보를 {@link GridFooter} 모델로 반환한다.
     * @example
     * ```js
     * let footer = gridView.getFooter();
     * footer.visible = false;
     * gridView.setFooter(footer);
     * ```
     */
    getFooter(): GridFooter$1;
    /**
     * 첫번째 그리드 푸터의 설정 정보를 {@link GridFooter} 모델로 설정한다.
     *
     * @param value - {@link GridFooter} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setFooter({className: 'custom-footer-1'});
     * ```
     */
    setFooter(value: GridFooter$1): void;
    /**
     * 그리드 푸터들의 설정 정보들을 {@link GridFooterCollection} 모델로 반환한다.
     *
     * @example
     * ```js
     * let footers = gridView.getFooters()
     * footers[0].visible = false;
     * gridView.setFooters(footers);
     * ```
     */
    getFooters(): GridFooterCollection$1;
    /**
     * 그리드 푸터들의 설정 정보들을 {@link GridFooter} 의 컬렉션 모델로 설정한다.
     *
     * @param value - GridFooterCollection 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     * ```js
     * // object
     * gridView.setFooters({
     *      visible: false;
     *      items: [
     *          {
     *              styleName: 'custom-footer-1';
     *          },
     *          {
     *              styleName: 'custom-footer-2';
     *          },
     *      ]
     * });
     *
     * // array
     * gridView.setFooters([
     *          {
     *              styleName: 'custom-footer-1';
     *          },
     *          {
     *              styleName: 'custom-footer-2';
     *          },
     *      ]);
     * ```
     */
    setFooters(value: GridFooterCollection$1): void;
    /**
     * 첫번째 그리드 header summary 와 관련된 설정 정보를 {@link HeaderSummary} 모델로 반환한다.
     *
     * @example
     * ```js
     * let headerSummary = gridView.getHeaderSummary();
     * headerSummary.visible = false;
     * gridView.setHeaderSummary(headerSummary);
     * ```
     */
    getHeaderSummary(): HeaderSummary$1;
    /**
     * 첫번째 그리드 header summary 의 설정 정보를 {@link HeaderSummary} 모델로 설정한다.
     *
     * @param value - {@link HeaderSummary} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setHeaderSummary({styleName: 'custom-hsummary-1'});
     * ```
     */
    setHeaderSummary(value: HeaderSummary$1): void;
    /**
     * 그리드 header summary 들의 설정 정보들을 {@link HeaderSummaryCollection} 모델로 반환한다.
     *
     * @example
     * ```js
     * let headerSummaries = gridView.getHeaderSummaries()
     * headerSummaries[0].visible = false;
     * gridView.setHeaderSummaries(headerSummaries);
     * ```
     */
    getHeaderSummaries(): HeaderSummaryCollection$1;
    /**
     * 그리드 header summary 들을 {@link HeaderSummaryCollection} 모델로 설정한다.
     *
     * @param value - {@link HeaderSummaryCollection} 모델과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * // object
     * gridView.setHeaderSummaries({
     *      visible: false;
     *      items: [
     *          {
     *              styleName: 'custom-hsumarry-1';
     *          },
     *          {
     *              styleName: 'custom-hsumarry-2';
     *          },
     *      ]
     * });
     *
     * // array
     * gridView.setFooters([
     *          {
     *              styleName: 'custom-hsumarry-1';
     *          },
     *          {
     *              styleName: 'custom-hsumarry-2';
     *          },
     *      ]);
     * ```
     */
    setHeaderSummaries(value: HeaderSummaryCollection$1): void;
    /**
     * 셀 스타일을 변경한다.
     *
     * @remarks
     * 컬럼 당 설정을 위해서는 {@link ValueColumn.styleCallback | 컬럼의 styleCallback} 을 사용해야 한다.
     *
     * {@link ColumnFooter | 푸터} 나 {@link ColumnHeaderSummary | header summary} 당 설정을 위해서는 해당 모델의 {@link ColumnSummary.styleCallback | styleCallback} 속성을 사용해야 한다.
     *
     * @param f - 셀 스타일을 특정하기 위한 콜백
     *
     * @example
     * ```js
     * const f = function (grid, cell) {
     *      return {
     *          styleName: 'custom-cell'
     *          editor: 'text'
     *      }
     * }
     * gridView.setCellStyleCallback(f);
     * ```
     */
    setCellStyleCallback(f: CellStyleCallback): void;
    /**
     * 행 스타일을 변경한다.
     *
     * @param f - 행 스타일을 특정하기 위한 콜백
     *
     * @example
     * ```js
     * const f = function(grid, item, fixed) {
     *      if (fixed) {
     *          return 'custom-fixed-row';
     *      }
     *      else {
     *          return 'custom-data-row';
     *      }
     * }
     * gridView.setRowStyleCallback(f)
     * ```
     */
    setRowStyleCallback(f: RowStyleCallback): void;
    /**
     * 하나 이상의 데이터 필드를 기준으로 Grid Item들을 정렬한다.
     *
     * @remarks
     *
     * 정렬은 Item Model 수준에서 실행되고, Data Provider 행들의 실제 위치는 변경되지 않는다.
     *
     * @param fieldNames - 정렬한 필드 이름 목록
     * @param sortDirs - 각 필드에 대한 정렬 방식 목록
     * @param textCases - 대소문자 구분
     *
     * @example
     * ```js
     * gridView.orderBy(['fruit'], ['descending'], ['insensitive']);
     * ```
     */
    orderBy(fieldNames: string[], sortDirs?: SortDirection[], textCases?: SortCase[]): void;
    /**
     * 현재 정렬되어 있는 필드들의 정렬 정보를 반환한다.
     *
     * @returns Sort 필드 정보 배열. 배열의 각 항목은 `direction`, `orgFieldName`, `fieldName` 의 정보를 가지고 있다.
     *
     * @example
     * ```js
     * let sFields = gridView.getSortedFields();
     *
     * console.log(sFields[0]);
     * //{
     * // fieldName: "COMPANYNAME"
     * // orgFieldName: "CompanyName"
     * // direction: "descending"
     * //}
     * ```
     */
    getSortedFields(): any[];
    /**
     * 그리드가 focus된다.
     *
     * @example
     * ```js
     * gridView.setFocus();
     * ```
     */
    setFocus(): void;
    /**
     * 해당하는 index 번째의 컬럼을 반환한다.
     *
     * @param index - 그리드에서의 순서
     *
     * @example
     * ```js
     * let col = gridView.getColumn(0);
     * ```
     */
    getColumn(index: number): GridColumn;
    /**
     * 그리드에 설정된 컬럼들을 반환한다.
     *
     * @param vOnly - 기본값: `false`, 표시된 컬럼만 가져올 건지의 여부.
     *
     * @example
     * ```js
     * let cols = gridView.getColumns();
     * ```
     */
    getColumns(): GridColumn[];
    /**
     * 기존에 설정된 컬럼들을 모두 제거하고 새로운 컬럼들로 그리드를 재구성한다.
     *
     * @param columns - {@link GridColumn | GridColumn} 과 같은 오브젝트의 컬럼 설정 정보 배열
     *
     * @example
     * ```js
     *  let cols = [{
     *      "name": "EmployeeID",
     *      "fieldName": "EmployeeID",
     *      "type": "data",
     *      "width": "90",
     *      "header": {
     *          "text": "Employee ID"
     *      }
     *  }, {
     *      "name": "OrderDate",
     *      "fieldName": "OrderDate",
     *      "type": "data",
     *      "width": "130",
     *      "header": {
     *          "text": "Order Date"
     *      }
     *  }]
     *
     *  gridView.setColumns(cols);
     * ```
     */
    setColumns(columns: ConfigObject[]): void;
    /**
     * 설정된 컬럼들 외에 추가로 컬럼을 설정한다.
     *
     * @param column - 추가할 컬럼 ({@link GridColumn | GridColumn} 과 같은 오브젝트)
     * @param index - 해당 컬럼이 위치할 순서(숨김컬럼 포함). 값을 지정하지 않으면 컬럼의 가장 마지막에 추가된다.
     *
     * @example
     * ```js
     *let col = {
     *      "name": "EmployeeID",
     *      "fieldName": "EmployeeID",
     *      "type": "data",
     *      "width": "90",
     *      "header": {
     *          "text": "Employee ID"
     *      }
     * }
     *
     * gridView.addColumn(col);
     * ```
     */
    addColumn(column: ConfigObject, index?: number): void;
    /**
     * 컬럼명을 이용해서 컬럼의 layout설정정보를 찾아온다.
     *
     * @param column - 컬럼의 name
     * @returns column의 layout설정정보
     * @example
     * ```js
     * let layout = gridView.layoutByName("column");
     * ```
     */
    layoutByColumn(column: string): CellLayoutColumnItem;
    /**
     * layout의 이름을 이용해서 layout설정정보를 찾아온다.
     *
     * @param name - layout의 이름
     * @returns 컬럼 또는 Group의 layout설정정보
     * @example
     * ```js
     * let group = gridView.layoutByName("group");
     * group.direction = "vertical"
     * ```
     */
    layoutByName(name: string): CellLayoutItem;
    /**
     * 그리드에 설정된 컬럼들을 반환한다.
     *
     * @param columnsOnly - 기본값: `false`, false면 반환 시 컬럼 그룹들을 포함
     * @param visibleOnly - 기본값: `false`, false면 반환 시 숨긴 컬럼들을 포함
     * @returns 컬럼 이름 배열
     *
     * @example
     *
     * ```js
     * let onlyColsNames = gridView.getColumnNames(true, false);
     * ```
     */
    getColumnNames(columnsOnly: boolean, visibleOnly: boolean): string[];
    /**
     * 컬럼 이름으로 컬럼 설정 정보를 반환한다.
     *
     * @param name - 컬럼 이름
     * @returns 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let col = gridView.columnByName('colName');
     * ```
     */
    columnByName(name: string): GridColumn;
    /**
     * 필드 이름으로 지정되는 데이터필드에 연결되어 있는 첫 번째 컬럼 정보를 반환한다.
     *
     * @param fieldName - 필드이름
     * @returns 컬럼 설정 정보나 컬럼이 존재하지 않는 경우 `null`
     *
     * @example
     * ```js
     * let col = gridView.columnByField('fieldName');
     * ```
     */
    columnByField(fieldName: string): GridColumn;
    /**
     * 해당 컬럼의 속성을 반환한다.
     *
     * @param column - 컬럼의 이름 또는 컬럼 객체
     * @param prop - 속성 이름
     * @returns `prop`에 입력된 속성명의 값이다.
     *
     * @example
     * ```js
     * let colRenderer = getColumnProperty('colName', 'renderer');
     * ```
     */
    getColumnProperty(column: string | GridColumn, prop: string): any;
    /**
     * 그리드에 설정된 컬럼의 특정 속성 정보를 변경한다.
     *
     * @remarks
     * editor 속성 안에 있는 속성을 변경하려는 경우 editor 전체를 다시 지정해야 한다.
     *
     * `values`, `labels`를 변경하는 경우 {@link GridBase.setColumnProperty | setColumnProperty()} 로 변경할 수 없으며 {@link GridBase.setColumn | setColumn()} 으로 컬럼을 재지정해야 한다.
     *
     * @param column - 컬럼의 이름 또는 컬럼 객체
     * @param prop - 속성 이름
     * @param value - 변경 값
     *
     * @example
     * ```js
     * gridView.setColumnProperty('colName', 'editor', {
     *      type: 'text'
     * });
     * ```
     */
    setColumnProperty(column: string | GridColumn, prop: string, value: any): void;
    /**
     * 그리드에 설정된 컬럼의 정보를 변경한다.
     *
     * @remarks
     * 컬럼 정보를 재설정하기 위해서는 먼저 {@link GridBase.columnByName | columnByName} 등으로 먼저 기존 설정 정보를 가져와야 한다.
     *
     * @param value - 변경할 정보. 컬럼의 이름 또는 {@link GridColumn} 과 같은 모델의 오브젝트.
     *
     * @example
     * ```js
     * let col = {
     *      name: 'existed column'
     * }
     * col.editor = {
     *     type: 'text'
     * }
     * gridView.setColumn(col);
     * ```
     */
    setColumn(value: ConfigObject): void;
    /**
     * 현재 보여지고 있는 컬럼들을 반환한다.
     *
     * @example
     * ```js
     * let displayCols = gridView.getDisplayColumns();
     * ```
     */
    getDisplayColumns(): GridColumn[];
    /**
     * 그리드의 컬럼 레이아웃을 설정한다.
     *
     * @remarks
     * `string` 으로 입력할 경우 미리 등록되어이 있는 레이아웃으로 설정한다.
     *
     * @param layout - 변경할 레이아웃 정보
     *
     * @example
     * ```js
     * layout = [{
     *         "OrderID",
     *         {
     *             name: "companyGroup",
     *             items: [
     *                 "Country",
     *                 50,
     *                 50,
     *                 {
     *                     column: "CompanyName",
     *                     cellSpan: 2
     *                 },
     *                 50,
     *                 50
     *             ],
     *             header: {
     *                 text: "Company Group",
     *                 visible: true
     *             }
     *         }
     *     }
     * ];
     * gridView.setColumnLayout(layout)
     * ```
     */
    setColumnLayout(layout: string | LayoutItem[]): void;
    /** @deprecated */
    /**
     * 해당 컬럼의 레이아웃 정보를 반환한다.
     * @param column - 정보를 얻고자 하는 컬럼의 이름 또는 컬럼 오브젝트
     *
     * @returns {@link CellLayoutColumnItem } 오브젝트
     *
     * @example
     *
     * ```js
     * let layout = gridView.getLayoutByColumn('OrderID');
     * ```
     */
    getLayoutByColumn(column: string | GridColumn): CellLayoutColumnItem$1;
    /**
     * 현재 화면의 레이아웃 정보를 반환한다.
     *
     * @example
     * ```js
     * let layouts = gridView.saveColumnLayout();
     * ```
     */
    saveColumnLayout(): LayoutInfo$1[];
    /**
     * 컬럼 그룹들을 모두 제거하고 데이터 값을 표시하는 컬럼들만 일렬로 배치한다.
     *
     * @param sortProp - 컬럼 순서 정렬을 지정하기 위한 정보
     *
     * @example
     * ```js
     * gridView.linearizeColumns();
     * ```
     */
    linearizeColumns(sortProps?: string[]): void;
    /**
     * 컬럼 레이아웃들을 미리 등록한다.
     *
     * @param layouts - 컬럼 레이아웃 배열
     *
     * @example
     * ```js
     * let layouts = [{
     *         "OrderID",
     *         {
     *             name: "companyGroup",
     *             items: [
     *                 "Country",
     *                 50,
     *                 50,
     *                 {
     *                     column: "CompanyName",
     *                     cellSpan: 2
     *                 },
     *                 50,
     *                 50
     *             ],
     *             header: {
     *                 text: "Company Group",
     *                 visible: true
     *             }
     *         },
     *     },
     * ...
     * ];
     * ```
     */
    registerColumnLayouts(layouts: LayoutItem[]): void;
    /**
     * 셀의 너비를 글자 길이에 맞게 변경한다.
     *
     * @remarks
     * GroupLayout의 하위 그룹이 있는 경우 자동으로 변경할수 없다.
     * grid.displayOptions.refreshMode 가 "visibleOnly"인 경우 화면에 표시되지 않는 컬럼의 너비는 조정되지 않는다.
     *
     * @param layout - layout이름 또는 column
     * @param maxWidth - 최대 너비
     * @param minWidth - 최소 너비
     *
     * @example
     * ```js
     * gridView.fitLayoutWidth('layout1')
     * ```
     */
    fitLayoutWidth(layout: string | DataColumn, maxWidth?: number, minWidth?: number): number;
    /**
     * 행 높이를 지정한 높이로 변경한다.
     *
     * @remarks
     * displayOptions.eachRowResizable: true로 지정되어 있어야 한다.
     *
     * @param itemIndex - 높이 변경할 행의 순서
     * @param height - 기본값: `0`, 행 높이. `0`으로 지정시 {@link DisplayOptions | displayOptions}.minRowHeight, maxRowHeight 에 맞게 행 높이가 변경된다.
     * @param refresh - 기본값: `true`, 변경한 행 높이를 바로 화면에 반영할 것인지의 여부
     *
     * @example
     * ```js
     * gridView.setRowHeight(2, 40);
     * ```
     */
    setRowHeight(itemIndex: number, height?: number, refresh?: boolean): void;
    /**
     * 행 높이를 반환한다.
     *
     * @param itemIndex - 높이를 반환할 행의 인덱스
     * @example
     * ```js
     * gridView.getRowHeight(2);
     * ```
     */
    getRowHeight(itemIndex: number): number;
    /**
     * 변경 적용한 개별 행 높이를 초기값으로 되돌린다.
     *
     * @param all - `true`: 전부, `false`: `setRowHeight()` 로 바꾼것만 비포함
     * @example
     * ```js
     * gridView.clearRowHeights(true);
     * ```
     */
    clearRowHeights(all: boolean): void;
    /**
     * 현재 focus 된 셀의 위치정보를 반환한다.
     *
     * ```js
     * console.log(JSON.stringify(grid.getCurrent()));
     * ```
     */
    getCurrent(): CellIndex$1;
    /**
     * focus cell 의 위치를 지정한다.
     *
     * @remarks
     * 행의 경우 itemIndex, dataRow 중 하나 지정할 수 있고, 컬럼의 경우 column(컬러명), fieldIndex, fieldName 중 하나로 지정할 수 있다.
     *
     * 단, 중복 적용될 경우 뒤부터 순서대로 우선 적용된다.
     *
     * @param current - 셀 위치정보
     * @param select - 선택 영역 초기화 여부
     *
     * @example
     *
     * ```js
     * gridView.setCurrent({ itemIndex: 1, column: '행정구역별' });
     * ```
     */
    setCurrent(current: CellIndex$1, select?: boolean): void;
    /**
     * focus cell 의 위치를 첫번째 행, 첫번째 열로 초기화한다.
     *
     * @example
     * ```js
     * gridView.resetCurrent();
     * ```
     */
    resetCurrent(): void;
    /**
     * focus를 제거한다.
     *
     * @example
     * ```js
     * gridView.clearCurrent();
     * ```
     */
    clearCurrent(): void;
    /**
     * (x, y) 좌표에 해당하는 셀의 위치정보를 반환한다.
     *
     * @param x - x 좌표
     * @param y - y 좌표
     * @returns 셀 위치정보, {@link CellIndex} 또는 존재하지 않을 경우 `null` 을 반환한다.
     *
     * @example
     * ```js
     * console.log(gridView.mouseToIndex(10, 10));
     * ```
     */
    mouseToIndex(x: number, y: number): ConfigObject;
    /**
     * 그리드에서 지정한 셀의 좌표값을 반환한다.
     *
     * @param itemIndex - 행의 순서
     * @param column - 컬럼 이름이나 컬럼 객체
     * @returns 좌표값, 보이지 않는 영역에 있을 경우 `null` 을 반환한다.
     *
     * @example
     * ```js
     * let bounds = gridView.getCellBounds(3, '행정구역별');
     *
     * // {x, y, width, height} 반환
     * ```
     */
    getCellBounds(itemIndex: number, column: string | GridColumn, outer?: boolean): object;
    /**
     * HTMLElemnt가 속한 셀의 위치정보를 반환한다.
     *
     * @remarks customRenderer에서 사용자가 생성한 element가 속해있는 셀의 index를 찾기위해 사용.
     *
     * @param element - HTMLElement
     * @returns element가 속한 Cell의 index
     */
    getIndexOfElement(element: HTMLElement): CellIndex$1;
    /**
     * 그리드 컬럼에 필터를 설정한다.
     *
     * @remarks
     * 사용가능한 Operator와 variables는 Expression 참조
     *
     * @param column - 설정 될 컬럼의 이름 또는 컬럼 객체
     * @param filters - 필터 객체의 배열, {@link ColumnFilter} 의 배열
     *
     * @example
     * ```js
     * let filters = [{
     *          name: "전",
     *          criteria: "value = '전'"
     *      }, {
     *          name: "답",
     *          criteria: "value = '답'"
     *      }, {
     *          name: "'임야' or '공장용지'",
     *          criteria: "(value = '임야') or (value = '공장용지')"
     *      }, {
     *          name: "대지: value > '대지'",
     *          criteria: "value > '대지'"
     *      }];
     *
     * gridView.setColumnFilters('지목', filters);
     * ```
     */
    setColumnFilters(column: string | DataColumn, filters: ColumnFilter$1[]): void;
    /**
     * 컬럼에 등록된 필터들을 제거한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     *
     * @example
     * ```js
     * gridView.clearColumnFilters();
     * ```
     */
    clearColumnFilters(column: string | DataColumn): void;
    /**
     * 컬럼에 하나 이상의 필터를 등록한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filters - 등록할 필터 객체의 배열, {@link ColumnFilter} 의 배열
     * @param overwrite - 기본값: `false`, overwrite가 `false` 시 중복된 이름의 필터가 있을 경우 에러를 발생시킨다.
     *
     * @example
     *
     * ```js
     * gridView.addColumnFilters('행정구역별', [{
     *          name: "전",
     *          criteria: "value = '전'"
     *      }, {
     *          name: "답",
     *          criteria: "value = '답'"
     *      }])
     * ```
     *
     */
    addColumnFilters(column: string | DataColumn, filters: ColumnFilter$1[], overwrite?: boolean): void;
    /**
     * 컬럼에 등록되어 있는 필터들 중 `filterNames`에 포함된 필터명을 갖는 필터들을 제거한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 제거할 필터의 이름 또는 필터들의 이름의 배열
     *
     * @example
     *
     * ```js
     * gridView.removeColumnFilters('행정구역별', ['전']);
     * ```
     */
    removeColumnFilters(column: string | DataColumn, filterNames: string | string[]): void;
    /**
     * 컬럼에 등록된 필터들 중, `filterNames` 에 포함된 필터명을 갖는 필터들을 적용시키거나 해제한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 적용 또는 해제할 필터의 이름 혹은 필터들의 이름의 배열
     * @param active - `true`: 적용, `false`: 해제.
     *
     * @example
     *
     * ```js
     * gridView.activateColumnFilters('행정구역별', ['전'], true);
     * ```
     *
     */
    activateColumnFilters(column: string | DataColumn, filterNames: string | string[], active: boolean): void;
    /**
     * 컬럼에 등록된 모든 필터들을 적용 또는 해제한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param active - `true`: 적용, `false`: 해제.
     *
     * @example
     *
     * ```js
     * gridView.activateAllColumnFilters('행정구역별', true);
     * ```
     */
    activateAllColumnFilters(column: string | DataColumn, active: boolean): void;
    /**
     * 컬럼에 등록된 필터들 중, `filterNames` 에 포함된 필터명을 갖는 필터들을 숨기거나 표시한다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @remarks
     * 활성화 된 필터를 숨기는 경우 활성화 된 상태로 숨긴다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 필터의 이름 혹은 필터들의 이름의 배열
     * @param hide - 기본값: `true`, `true`: 숨김, `false`: 보여줌.
     *
     * @example
     *
     * ```js
     * gridView.hideColumnFilters('행정구역별', ['전']);
     * ```
     */
    hideColumnFilters(column: string | DataColumn, filterNames: string | string[], hide?: boolean): void;
    /**
     * 컬럼에 등록된 모든 필터를 숨기거나 보여준다.
     * column.autoFilter가 true인 경우 적용되지 않는다.
     *
     * @remarks
     * 활성화 된 필터를 숨기는 경우 활성화 된 상태로 숨긴다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param hide - 기본값: `true`, `true`: 숨김, `false`: 보여줌.
     *
     * @example
     * ```js
     * gridView.hideAllColumnFilters('행정구역별');
     * ```
     */
    hideAllColumnFilters(column: string | DataColumn, hide?: boolean): void;
    /**
     * 해당 컬럼의 지정한 필터들을 토글한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param filterNames - 토글할 필터의 이름 혹은 필터들의 이름의 배열
     *
     * @example
     *
     * ```js
     * gridView.toggleColumnFilters('행정구역별', ['전', '답']);
     * ```
     */
    toggleColumnFilters(column: string | DataColumn, filterNames: string | string[]): void;
    /**
     * 해당 컬럼의 지정한 모든 필터들을 토글한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     *
     * @example
     *
     * ```js
     * gridView.toggleAllColumnFilters('행정구역별', ['전']);
     * ```
     */
    toggleAllColumnFilters(column: string | DataColumn): void;
    /**
     * 지정한 컬럼에서 필터 이름에 해당하는 필터를 반환한다.
     *
     * @param column - 지정한 컬럼의 이름 또는 컬럼 객체
     * @param filterName - 필터 이름
     * @returns {@link ColumnFilter} 와 같은 모델의 필터 오브젝트
     *
     * @example
     *
     * ```js
     * gridView.getColumnFilter('행정구역별', ['전']);
     * ```
     */
    getColumnFilter(column: string | DataColumn, filterName: string): ColumnFilter$1;
    /**
     * 지정한 컬럼에서 필터들을 반환한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @returns {@link ColumnFilter} 와 같은 모델의 필터 오브젝트의 배열
     *
     * @example
     *
     * ```js
     * gridView.getColumnFilters('행정구역별');
     * ```
     */
    getColumnFilters(column: string | DataColumn): ColumnFilter$1[];
    /**
     * 등록된 필터들 중 적용된 필터 또는 해제된 필터의 이름을 반환한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @param active - 기본값: true, `true`: 활성화 된 필터 반환, `false`: 해제된 필터 반환
     * @returns 활성화 상태에 해당하는 {@link ColumnFilter} 와 같은 모델의 필터 오브젝트의 배열
     *
     * @example
     * ```js
     * gridView.getActiveColumnFilters('행정구역별');
     * ```
     */
    getActiveColumnFilters(column: string | DataColumn, active?: boolean): ColumnFilter$1[];
    /**
     * 그리드의 특정 컬럼이 필터링 되어 있는지 여부를 반환한다.
     *
     * @remarks
     *
     * 컬럼을 생략하면 필터링이 되어있는 컬럼이 있으면 `true`를 return하고 없으면 `false`를 return한다.
     *
     * @param column - 해당하는 컬럼의 이름 또는 컬럼 객체
     * @returns 필터링 여부
     *
     * @example
     * ```js
     * gridView.isFiltered('행정구역별');
     * //
     * gridView.isFiltered();
     * ```
     */
    isFiltered(column?: string | DataColumn): boolean;
    /**
     * column.autoFilter가 true인경우 filter목록을 갱신한다.
     *
     * @param columns - 컬럼이름 또는 컬럼 객체의 배열. 입력하지 않는 경우 전체 컬럼.
     * @param applyFilters - active된 filter의 적용 여부.
     *
     * @remarks
     * autoFilter의 목록을 갱신할때 호출한다.
     * 또는 사용자가 filter 아이콘을 클릭하면 자동으로 갱신된다.
     */
    autoFiltersRefresh(columns: string[] | DataColumn[], applyFilters: boolean): void;
    /**
     * 지정한 행의 데이터 값들을 JSON객체로 반환한다.
     *
     * @remarks
     * itemIndex와 연결된 행의 고유번호는 반환되는 객체의 __rowId에 담겨있다.
     *
     * @param itemIndex - 정보를 가져올 행의 순서
     * @returns 입력된 `itemIndex`가 행의 고유 번호와 연결된 행이 아닌경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getValues('3');
     * ```
     */
    getValues(itemIndex: number): object;
    /**
     * 지정한 행의 데이터 값들을 각종 포맷이나 정규식이 적용된 형태의 JSON객체로 반환한다.
     *
     * @param itemIndex - 정보를 가져올 행의 순서
     * @param useColumnName - `true`이면 JSON객체의 속성명을 fieldName이 아닌 column.name으로 만든다.
     * @returns 입력된 `itemIndex`가 행의 고유 번호와 연결된 행이 아닌경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getDisplayValues(3);
     * ```
     */
    getDisplayValues(itemIndex: number, useColumnName?: boolean): object;
    /**
     * 행 고유 번호로 지정한 행의 데이터 값들을 각종 포맷이나 정규식이 적용된 형태의 JSON객체로 반환한다.
     *
     * @param dataRow - 행의 고유 번호
     * @param useColumnName - `true`이면 JSON객체의 속성명을 fieldName이 아닌 column.name으로 만든다.
     * @returns 입력된 `dataRow`가 존재하지 않을 경우 `null`이 출력된다.
     *
     * @example
     * ```js
     * gridView.getDisplayValuesOfRow(42);
     * ```
     */
    getDisplayValuesOfRow(dataRow: number, useColumnName?: boolean): object;
    getJsonRows(): object[];
    /**
     * 지정한 행의 여러 필드의 값을 수정한다.
     *
     * @param itemIndex - 정보를 가져올 행의 인덱스
     * @param values - 수정할 필드의 데이터 값들
     * @param strict - 기본값: `false`, `true` 일때 필드의 값을 `undefined` 로 지정한 경우 기존의 값을 유지한다.
     *
     * @example
     * ```js
     * gridView.setValues(3, [123, 142, 'happy', 133]);
     * ```
     */
    setValues(itemIndex: number, values: any[] | object, strict?: boolean): void;
    /**
     * 행의 순서와 데이터 필드 인덱스로 지정되는 데이터셀의 값을 반환한다.
     *
     * @remarks
     * 지정한 행이 수정중인 경우 수정된 값을 반환한다. 편집이 완료되지 않은 셀의 값은 가져올수 없다.
     *
     * @param itemIndex - 행의 순서
     * @param field - 필드 인덱스 또는 필드명
     * @returns 데이터 필드의 값
     * @example
     * ```js
     * gridView.getValue(3, 'UnitPrice');
     * ```
     */
    getValue(itemIndex: number, field: string | number): any;
    /**
     * 행의 순서와 데이터 필드 인덱스로 지정되는 데이터 셀의 값을 변경한다.
     *
     * @remarks
     * 그리드가 편집 중인 경우 편집 중인 itemIndex 의 값만 변경할수 있으며 편집이 완료된후 dataProvider에 값이 반영되고 편집중이 아닌경우 dataProvider에 즉시 반영된다.
     *
     * @param itemIndex - 행의 순서
     * @param field - 필드 인덱스 또는 필드명
     * @param value - 필드에 설정할 값
     *
     * @example
     * ```js
     * gridView.setValue(3, 'UnitPrice', 52);
     * ```
     */
    setValue(itemIndex: number, field: string | number, value: any): void;
    /**
     * 그리드가 편집 중일때 현재 수정 중인 셀의 값을 반환한다.
     *
     * @returns 데이터 필드의 값
     *
     * @example
     * ```js
     * gridView.getEditValue();
     * ```
     */
    getEditValue(): any;
    /**
     * focus가 위치한 셀에 값을 설정한다.
     *
     * @param value - 설정하려는 값
     * @param startEdit - 기본값: `false`, `true`: 셀이 편집중이 아닌 경우 값을 설정하고 편집기를 표시. `false`: 값을 설정하지 않음.
     * @param dropdown - 기본값: `true`, `false`: dropdownCellEditor, dateCellEditor등과 같이 dropdown이 되는 editor의 경우 dropdown을 표시하지 않는다.
     *
     * @example
     * ```js
     * gridView.setEditValue('newValue');
     * ```
     */
    setEditValue(value: any, startEdit?: boolean, dropdown?: boolean): void;
    /**
     * 사용자 지정의 렌더러를 등록한다.
     *
     * @param type - 사용자가 지정한 렌더러 종류 (이름)
     * @param renderer - {@link CustomCellRenderer} 객체
     *
     * @example
     * ```js
     * // CustomCellRenderer 모델
     * gridView.registerCustomRenderer("renderer01", {
     *     initContent(parent) {
     *         var span = this._span = document.createElement("span");
     *         parent.append(span);
     *     }
     * }
     * ```
     */
    registerCustomRenderer(type: string, renderer: CustomCellRenderer): void;
    /**
     * 사용자 지정의 렌더러를 등록 해제 한다.
     *
     * @param type - 해제 할 렌더러 종류 (이름)
     *
     * @example
     * ```js
     * gridView.unregisterCustomRenderer('Renderer01');
     * ```
     */
    unregisterCustomRenderer(type: string): void;
    /**
     * 사용자렌더러가 있는지 확인한다.
     * @param type - 등록한 렌더러 이름
     */
    existsCustomRenderer(type: string): boolean;
    /**
     * 모든 사용자 지정의 렌더러를 등록 해제 한다.
     *
     * @example
     * ```js
     * gridView.unregisterAllCustomRenderer('Renderer01');
     * ```
     */
    unregisterAllCustomRenderer(): void;
    /**
     * 그리드에 Popup Menu를 추가한다.
     *
     * @remarks
     * 추가된 메뉴는 데이터셀 등에 연결할 수 있다.
     *
     * @param name - 메뉴 이름
     * @param menuItems - {@link PopupMenuItem} 형식을 따르는 배열, 계층적 구조의 메뉴 정보
     *
     * @example
     * ```js
     * let menu = [{
     *      label: "menu1 입니다.",
     *      children: [{
     *          label: "submenu1 입니다."
     *      }, {
     *          label: "submenu2 입니다."
     *      }]
     *  }, {
     *      label: "menu2 입니다",
     *  }, {
     *      label: "-"
     *  }, {
     *      label: "menu3 입니다",
     *      type: "check",
     *      checked: true,
     *      tag: "check_menu"
     *  }];
     *
     * gridView.addPopupMenu('menu1', menu);
     * ```
     */
    addPopupMenu(name: string, menuItems: PopupMenuItem$1[]): void;
    /**
     * 그리드에서 특정 Popup Menu 를 제거한다.
     *
     * @param name - 제거할 Popup Menu 의 이름
     *
     * @example
     * ```js
     * gridView.removePopupMenu('menu1');
     * ```
     */
    removePopupMenu(name: string): void;
    /**
     * 그리드에서 오른쪽 마우스를 클릭했을때 표시되는 컨텍스트 메뉴에 추가할 메뉴 항목들을 지정한다.
     *
     * @remarks
     * 메뉴가 클릭되면 {@link GridBase.onContextMenuItemClicked | onContextMenuItemClicked} 콜백을 호출한다
     *
     * @param menuItems - 메뉴 정보 배열
     *
     * @example
     * ```js
     * let menu = [{
     *      label: "menu1 입니다.",
     *      children: [{
     *          label: "submenu1 입니다."
     *      }, {
     *          label: "submenu2 입니다."
     *      }]
     *  }, {
     *      label: "menu2 입니다",
     *  }, {
     *      label: "-"
     *  }, {
     *      label: "menu3 입니다",
     *      type: "check",
     *      checked: true,
     *      tag: "check_menu"
     *  }];
     *
     * gridView.setContextMenu(menu);
     * ```
     */
    setContextMenu(menuItems: PopupMenuItem$1[]): void;
    /**
     * 현재 선택된 영역 정보를 반환한다.
     *
     * @param index - 선택영역이 여러개인 경우 선택영역의 index
     *
     * @example
     * ```js
     * let sel = gridView.getSelection();
     * console.log("Selection: ", JSON.stringify(sel, function(key, value) { return key.indexOf("Layout") >= 0 ? value.column : value }));
     * ```
     */
    getSelection(index?: number): Selection;
    /**
     * 현재 선택된 영역 정보를 배열형태로 반환한다.
     *
     * @example
     * ```js
     * let sels = gridView.getSelections();
     * console.log("Selection count: ", sels.length);
     * sels.forEach((sels) => {
     *     console.log("Selection: ", JSON.stringify(sel, (key, value) => {return key.indexOf("Layout") >= 0 ? value.column : value}));
     * })
     * ```
     *
     * @returns 선택된 영역 배열
     */
    getSelections(): Selection[];
    /**
     * 그리드에서 선택할 영역을 지정한다.
     *
     * @remarks
     * 기존 선택영역이 있는 경우 제거된다.
     *
     * @param item - {@link Selection} 모델과 같은 설정 정보. 선택하고자 하는 영역의 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * let sel = {
     *      style: "block",
     *      startItem: 2,
     *      startColumn: "지목",
     *      endItem: 3,
     *      endColumn: "단위"
     * }
     * gridView.setSelection(sel);
     * ```
     */
    setSelection(item: Selection): void;
    /**
     * 그리드에서 선택할 영역을 추가한다.
     *
     * @remarks
     * {@link DisplayOptions.selectionMode | selectionMode}가 {@link SelectionMode.EXTENDED | extended}인 경우에만 추가된다.
     *
     * @param item - {@link Selection} 모델과 같은 설정 정보. 선택하고자 하는 영역의 속성만 전달하면 된다.
     *
     * @example
     * ```js
     * let sel = {
     *      style: "block",
     *      startItem: 2,
     *      startColumn: "지목",
     *      endItem: 3,
     *      endColumn: "단위"
     * }
     * gridView.addSelection(sel);
     * ```
     */
    addSelection(item: Selection): void;
    /**
     * 선택 영역을 모두 제거한다.
     *
     * @example
     * ```js
     * gridView.clearSelection();
     * ```
     */
    clearSelection(): void;
    /**
     * @internal
     * find를 할수 있는 방법이 애매하다. getSelections()를 이용해서 전체 선택정보를 가져온후 특정 selection을 찾아서 제거해야 한다.
     * block, rows, columns가 혼재되어있고 중복된 영역이 존재할때 제거가 만만치 않다.
     * 지정된 선택영역을 제거한다.
     *
     * @param index - number
     *
     * @example
     * ```js
     * gridView.removeSelection(0);
     * ```
     */
    removeSelection(index: number): void;
    /**
     * 현재 선택 영역 안의 행의 인덱스들을 반환한다.
     *
     * @param dataOnly -  데이터행만 반환한다.
     *
     * @example
     * ```js
     * let selectedItems = gridView.getSelectedItems(true);
     * ```
     */
    getSelectedItems(dataOnly: boolean): number[];
    /**
     * 현재 선택 영역 안의 데이터 행의 고유번호들을 반환한다.
     *
     *  @example
     * ```js
     * let selectedRows = gridView.getSelectedRows();
     * ```
     */
    getSelectedRows(): number[];
    /**
     * 현재 선택 영역 안의 행들을 삭제한다.
     *
     * @remarks
     * {@link GridBase.editOptions | grid.editOptions.deletable} 이 false인 경우 작동하지 않는다.
     *
     * @param force - `true` 시 대화 상자 표시 없이 바로 삭제한다.
     *
     * @example
     * ```js
     * gridView.deleteSelection(true);
     * ```
     */
    deleteSelection(force: boolean): void;
    /**
     * 선택 영역 안의 셀들의 값을 지운다. 즉, undefined로 값을 변경한다.
     *
     * @example
     * ```js
     * gridView.eraseSelection();
     * ```
     */
    eraseSelection(): void;
    /**
     * 현재 선택 영역에 포함된 셀들의 값을 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우에도 첫번째 선택영역의 data만 반환한다.
     *
     * @param maxRows - 반환할 최대 행의 개수. 기본값: `-1`. `0`보다 작은 값이면 제한 없이 모든 행을 반환한다.
     * @param index - 선택영역의 index 기본값: `0`
     * @returns 셀 데이터들
     *
     * @example
     * ```js
     * let selData = gridView.getSelectionData();
     * ```
     */
    getSelectionData(maxRows?: number, index?: number): RowObject[];
    /**
     * 현재 선택 영역에 포함된 셀들의 값을 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우 사용한다.
     *
     * @returns 셀 데이터들
     */
    getSelectionsData(): RowObject[][];
    /**
     * 선택한 영역에 포함된 셀들의 정보를 복사 혹은 반환한다.
     *
     * @remarks
     * 선택된 영역이 여러개인경우 사용할수 없다.
     *
     * @param selection - 선택 영역의 정보, 지정하지 않으면 그리드 전체가 복사된다.
     * @param copy - 기본값: `true`, `true:` 클립보드에 복사, `false`: 반환
     * @returns `copy` 가 `false` 시 반환
     *
     * @example
     * ```js
     * let sel = gridView.getSelection();
     * let copied = gridView.copyToClipBoard(sel);
     * ```
     */
    copyToClipboard(selection: Selection, copy?: boolean): any;
    /**
     * 현재 편집기의 내용을 셀에 반영한다.
     *
     * @remarks
     * 실행 후 {@link GridBase.onEditCommit | onEditCommit}, {@link GridBase.onEditRowChanged | onEditRowChanged}, {@link GridBase.onCellEdited | onCellEditted} 이벤트가 순차적으로 발생한다.
     *
     * @param hideEditor - 기본값: true, Editor의 종료 여부
     *
     * @example
     * ```js
     * gridView.commitEditor();
     * ```
     */
    commitEditor(hideEditor?: boolean): void;
    /**
     * 편집 중인 행의 편집을 완료하고 DataProvider에 저장한다.
     *
     * @param force - 기본값: `false`, `true`: 입력/편집 중 편집을 취소한 행(RowState 변경은 없고, Indicator 에 편집으로 표시된)을 커밋
     * @returns  데이터 변경이 발생한 경우 `true` 반환
     *
     * @example
     * ```js
     * gridView.commit();
     * ```
     */
    commit(force?: boolean): boolean;
    /**
     * 현재 편집 중인 행의 편집을 취소한다.
     *
     * @remarks
     * 편집 중이 아니라면 아무 일도 하지 않는다.
     * 편집을 완료할 때는 {@link GridBase.commit | commit()} 을 호출해야 한다.
     *
     * @returns 취소 성공 여부
     *
     * @example
     * ```js
     * gridView.cancel();
     * ```
     */
    cancel(): boolean;
    /**
     * 입력값과 관련된 항목을 조회하여 리스트에 표시한다. 부분검색 용도로 사용된다.
     *
     * @param column - 리스트가 표시 될 컬럼 객체 또는 컬럼명
     * @param searchKey - 검색 키 값
     * @param values - 검색된 value 값들
     * @param labels - 검색된 label 값들
     *
     * @example
     * ```js
     * let CustomerNames = ["ALFKI", "ANATR", "ANTON", "AROUT", "BERGS", "BLAUS"];
     * dataProvider.setFields([
     *      {fieldName:"code"},
     *      {fieldName:"codeName"} // 코드 명을 가지고 있는 필드
     * ]);
     * gridView.setColumns([{
     *      fieldName:"code",
     *      name:"code",
     *      editor:{type:"search",searchLength:1, searchDelay:500, useCtrlEnterKey:true, useEnterKey:true },
     *      lookupDisplay:true,
     *      labelField:"codeName"
     * }]);
     *
     * // 마지막 키가 입력되고 searchDelay가 지나면 발생되는 이벤트
     * gridView.onEditSearch = function (grid, index, text) {
     *      console.log("onEditSearch:" + index.itemIndex + "," + index.column + ", " + text);
     *      let values = CustomerNames.filter(function (str) {
     *          return str.indexOf(text) == 0;
     *      });
     *      let labels = CustomerNames.filter(function (str) {
     *          return str.indexOf(text) == 0;
     *      });
     *      console.log(values);
     *      gridView.fillEditSearchItems(index.column, text, values, labels);
     * };
     *
     * // searchEditor에서 선택이 되며 발생되는 이벤트
     * gridView.onGetEditValue = function (grid, index, editResult) {
     *      if (index.column === "code") {
     *          grid.setValue(index.itemIndex, "codeName",editResult.text);
     *      };
     * };
     * ```
     */
    fillEditSearchItems(column: string, searchKey: string, values: string[], labels: string[]): void;
    /**
     * 셀 편집은 끝났으나 커밋은 하지 않았을 때, 편집 중이면 `true` 를 반환한다.
     *
     * @example
     * ```js
     * let isItemEditing = gridView.isItemEditing();
     * ```
     */
    isItemEditing(): boolean;
    /**
     * isItemEdited?
     */
    /**
     * 셀이 현재 편집중이면 `true` 를 반환한다.
     *
     * @example
     * ```js
     * let isEditing = gridView.isEditing();
     * ```
     */
    isEditing(): boolean;
    /**
     * 현재 위치한 셀에서 그리드의 편집기를 표시한다.
     *
     * @remarks
     * 그리드가 편집 불가 상태(editable: false)라면 편집기는 표시되지 않는다.
     *
     * @example
     * ```js
     * gridView.showEditor();
     * ```
     */
    showEditor(dropdown?: boolean): void;
    /**
     * 현재 그리드에서 열려진 편집기를 닫는다.
     *
     * @example
     * ```js
     * gridView.hideEditor();
     * ```
     */
    hideEditor(): void;
    /**
     * 편집을 취소하고 편집기 창을 닫는다.
     *
     * @example
     * ```js
     * gridView.cancelEditor();
     * ```
     */
    cancelEditor(): void;
    /**
     * 행 수준의 편집 검증 조건의 목록을 설정한다.
     *
     * @param value - {@link EditValidation} 모델과 같은 설정 정보들의 배열 또는 검증식
     *
     * @example
     * ```js
     * // 문자열
     * gridView.setValidations("values['UnitPrice'] > 100");
     *
     * // 오브젝트
     * gridView.setValidations({
     *      message: 'Too expensive!',
     *      criteria: "values['UnitPrice'] > 100"
     * })
     *
     * // 배열
     * gridView.setValidations([{
     *      message: 'Too expensive!',
     *      criteria: "values['UnitPrice'] > 100"
     * }])
     * ```
     */
    setValidations(value: EditValidation$1[] | EditValidation$1 | string | string[]): void;
    /**
     * 입력시 검증하는 것이 아닌 그리드에 있는 데이터들을 대상으로 일괄로 검증을 수행한다.
     *
     * @remarks
     * column validation을 사용하여 검증을 수행하며 row validation은 하지 않는다.
     *
     * @param itemIndices - 그리드의 행 인덱스들, `null`로 지정하면 그리드 전체 행을 대상으로 검증을 수행
     * @param visibleOnly - 기본값: `true`, `false` 이면 트리 그리드의 접혀있는 노드 등 보이지 않는 행들도 검증 대상에 포함한다. `false`는 전체 행을 체크하는 경우에만 적용한다.
     * @param pageAllItems - 기본값: `false`,
     * @returns 검증에 실패한 셀 정보들
     *
     * @example
     * ```js
     * gridView.validateCells(null, false);
     * ```
     */
    validateCells(itemIndices: number[], visibleOnly?: boolean, ignorePaging?: boolean): object;
    /**
     * 값 검증에 실패한 셀 정보들을 반환한다.
     *
     * @remarks
     * 이 함수는 {@link GridBase.validateCells | validateCells()} 를 먼저 실행한 후 검증에 실패한 데이터를 수정 후 다시 검증할 때 사용한다.
     *
     * @returns 검증에 실패한 셀 정보들, {@link InvalidCell} 의 배열 형식을 따른다.
     *
     * @example
     * ```js
     * let invalids = gridView.getInvalidCells();
     * ```
     *
     */
    getInvalidCells(): InvalidCell[];
    /**
     * 값 검증에 실패한 셀 정보들을 삭제한다.
     *
     * @remarks
     * 이 함수는  {@link GridBase.validateCells | validateCells()} 를 먼저 실행한 후 가져온 검증에 실패한 데이터의 목록을 지울때 사용한다.
     *
     * @example
     * ```js
     * gridView.validateCells();
     * gridView.clearInvalidCells();
     * let invalids = gridView.getInvalidCells(); // null
     * ```
     */
    clearInvalidCells(): void;
    /**
     * 그리드가 편집 중인 아이템의 정보를 반환한다.
     *
     * @returns 편집 중인 그리드 아이템의 정보. 편집 중이 아닌 경우 `null` 반환. {@link EditingItemInfo} 형식.
     *
     * @example
     * ```js
     * let eItemInfo = gridView.getEditingItem();
     * ```
     */
    getEditingItem(): EditingItemInfo;
    /**
     * 아이템의 상태값을 반환한다.
     *
     * @param itemIndex - 상태를 가져오려는 아이템의 인덱스
     * @returns 그리드 아이템의 상태값
     *
     * @example
     * ```js
     * let itemStates = gridView.getItemState(3);
     * ```
     */
    getItemState(itemIndex: number): ItemState;
    /**
     * Toast 팝업 창을 표시한다.
     *
     * @param options - 메시지와 메시지 표시여부를 지정, {@link ToastOptions} 와 같은 모델의 오브젝트. 기본적으로 메시지만 지정해도 된다.
     * @param force - 기존 toast 창이 표시되어 있을때 강제로 다시 표시 여부를 지정한다.
     *
     * ```js
     * let config = {
     *      message: 'Toast!'
     * }
     * gridView.showToast(config, true);
     * ```
     */
    showToast(options: ToastOptions, force: boolean): void;
    /**
     * Toast 팝업 창을 숨긴다.
     *
     * @param action - toast 창을 숨긴 뒤 수행할 콜백함수를 지정한다. 지정하지 않으면 바로 숨긴다.
     *
     * @example
     * ```js
     * const f = function () {
     *      console.log('hidden toast!');
     * }
     * gridView.hideToats(f);
     * ```
     */
    hideToast(action: VoidFunction): void;
    /**
     * lookup tree 에서 사용할 lookup source 들을 등록한다.
     *
     * @remarks
     * 기존id에 추가를 원하는 경우는 {@link GridBase.fillLookupData | fillLookupData()} 를 사용한다.
     *
     * @param sources - {@link LookupSource} 오브젝트 배열
     *
     * @example
     * ```js
     * let area1codes = {
     *      id: "area1code",
     *      levels: 1,
     *      keys: ['11', '21'],
     *      values: ['서울특별시', '부산광역시']
     * }
     *
     * let area2codes = {
     *      id:"area2code",
     *      levels:2,
     *      keys: [['11', '11010'], ['11', '11020']],
     *      values: ['종로구', '중구']
     * };
     *
     * gridView.setLookups([area1codes, area2codes]);
     * ```
     */
    setLookups(sources: LookupSource[]): void;
    /**
     * lookup tree에서 사용할 {@link LookupSource} 를 추가 등록한다.
     *
     * @remarks
     *
     * 기존id에 추가를 원하는 경우는 {@link GridBase.fillLookupData | fillLookupData()} 를 사용한다.
     *
     * @param source - {@link LookupSource} 오브젝트
     *
     * @example
     * ```js
     * let area3codes = {
     *      id:"area2code",
     *      levels:3,
     *      keys: [['11', '11010', '1101053'], ['11', '11010', '1101054']],
     *      values: ['사직동', '삼청동']
     * };
     * gridView.addLookupSource(area3codes);
     * ```
     */
    addLookupSource(source: LookupSource): void;
    /**
     * 지정한 룩업 소스를 삭제한다.
     *
     * @param sourceId - 삭제할 LookupSource id
     *
     * @example
     * ```js
     * gridView.removeLookupSource('area1code');
     * ```
     */
    removeLookupSource(sourceId: string): void;
    /**
     * 지정된 lookupsource에 지정된 키가 존재하는지 여부를 반환한다.
     *
     * @param sourceId - LookupSource의 Id.
     * @param keys - 찾을 키 값, 값들.
     *
     * @example
     * ```js
     * gridView.existsLookupData('area1code', ['12']);
     * ```
     */
    existsLookupData(sourceId: string, keys: string[]): boolean;
    /**
     * lookupSource에 lookupData를 추가한다.
     *
     * @param sourceId - LookupSource의 id
     * @param data - 설정하고자 하는 {@link LookupData}
     *
     * @example
     * ```js
     * gridView.fillLookupData("lookup1", {keys:[["14"],["15"]], values:["가나다라","일이삼사"]});
     * ```
     */
    fillLookupData(sourceId: string, data: LookupData): void;
    /**
     * 지정된 SourceId에 해당하는 lookup source를 clear한다.
     *
     * @param sourceId - LookupSource의 id
     *
     * @example
     * ```js
     * gridView.clearLookupData('area1code');
     * ```
     */
    clearLookupData(sourceId: string): void;
    /**
     * 지정한 아이템의 인덱스로 체크바의 체크 가능 여부를 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @returns 체크 가능한지의 여부
     *
     * @example
     * ```js
     * let isCheckable = gridView.isCheckable(4);
     * ```
     */
    isCheckable(itemIndex: number): boolean;
    /**
     * 지정한 아이템의 고유 번호로 체크바의 체크 가능 여부를 반환한다.
     *
     * @param dataRow - 아이템의 dataRow
     * @returns 체크 가능한지의 여부
     *
     * @example
     * ```js
     * gridView.isCheckableOfRow(4);
     * ```
     */
    isCheckableOfRow(dataRow: number): boolean;
    /**
     * 지정한 아이템의 체크바의 체크 가능성 여부를 지정한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param value - 체크 가능한지의 여부
     *
     * @example
     * ```js
     * gridView.setCheckable(4, false);
     * ```
     */
    setCheckable(itemIndex: number, value: boolean): void;
    /**
     * 지정한 행의 체크바의 체크 가능성 여부를 지정한다.
     *
     * @param dataRow - 아이템의 dataRow
     * @param value - 체크 가능한지의 여부
     *
     */
    setCheckableOfRow(dataRow: number, value: boolean): void;
    /**
     * 해당 체크바에 체크가 되어있으면 `true` 를 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     *
     * @example
     * ```js
     * gridView.isCheckedItem(4);
     * ```
     */
    isCheckedItem(itemIndex: number): boolean;
    /**
     * 행이 체크되어있는지 여부
     *
     * @param row - 행 고유 번호
     *
     * @example
     * ```js
     * gridView.isCheckedRow(4);
     * ```
     */
    isCheckedRow(row: number): boolean;
    /**
     * 지정된 아이템을 체크하거나 해제한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param exclusive - 기본값: `false`, `true`: 체크된 다른아이템이 있는 경우 모두 해제하고 아이템 인덱스로 입력된 아이템만 체크
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkItem(4);
     * ```
     */
    checkItem(itemIndex: number, checked?: boolean, exclusive?: boolean, checkEvent?: boolean): void;
    /**
     * 지정된 데이터 행을 체크하거나 해제한다.
     *
     * @param row - 행 고유 번호
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param exclusive - 기본값: `false`, `true`: 체크된 다른아이템이 있는 경우 모두 해제하고 row로 입력된 아이템만 체크
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkRow(4);
     * ```
     */
    checkRow(row: number, checked?: boolean, exclusive?: boolean, checkEvent?: boolean): void;
    /**
     * 입력된 아이템 배열에 해당하는 아이템을 체크하거나 해제한다.
     *
     * @param itemIndices - 아이템 인덱스 배열
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param checkEvent - 기본값: `true`,  {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkItems([1,2,3,4]);
     * ```
     */
    checkItems(itemIndices: number[], checked?: boolean, checkEvent?: boolean): void;
    /**
     * 입력된 고유 행 번호들과 연결된 Item을 체크하거나 해제한다.
     *
     * @param rows - 고유 행 번호의 배열
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkRows([1,2,3,4]);
     * ```
     */
    checkRows(rows: number[], checked?: boolean, checkEvent?: boolean): void;
    /**
     * 그리드의 데이터행을 모두 체크,해제한다.
     *
     * @remarks
     * {@link CheckBar} 의 exclusive에 영향을 받지않는다.
     *
     * @param checked - 기본값: `true`, `true`: 체크, `false`: 체크 해제
     * @param visibleOnly - collapse로 인해 접혀서 보이지 않는 행의 포함여부
     * @param checkableOnly - 체크가능한 행만 체크할 것인지의 여부
     * @param checkEvent - 기본값: true, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * gridView.checkAll();
     * ```
     */
    checkAll(checked?: boolean, visibleOnly?: boolean, checkableOnly?: boolean, checkEvent?: boolean): void;
    /**
     * CheckBar에 설정된 옵션으로 그리드의 데이터행을 모두 체크 또는 해제한다.
     *
     * @remarks
     * {@link CheckBar} 의 exclusive에 영향을 받지않는다.
     * {@link GridBase.onItemChecked | onItemChecked()} 는 발생하지 않는다.
     * CheckBar|CheckBar.head의 v 표시를 활성 상태로 적용시킨다.
     *
     * @param checked - 기본값: true, true: 체크, false, 해제
     * @param itemChecked - 기본값: true, CheckBar.head의 v표시 활성 여부
     *
     *  @example
     * ```js
     * gridView.setAllCheck();
     * ```
     */
    setAllCheck(checked?: boolean, itemChecked?: boolean): void;
    /**
     * 모든 아이템들이 체크되어있는지 여부를 반환한다.
     *
     * @returns CheckBar|CheckBar.head의 v 표시가 활성 상태이면 true를 반환한다.
     *
     * @example
     * ```js
     * let all = gridView.isAllChecked();
     * ```
     */
    isAllChecked(): boolean;
    /**
     * CheckBar에 적용된 모든 행의 Checkable 상태를 초기화한다.
     *
     * @param clearExpression - CheckBar의 checkableExpression을 clear 실행 여부
     *
     */
    resetCheckables(clearExpression: boolean): void;
    /**
     * CheckBar에 Expression 기준으로 checkable을 적용한다.
     *
     * @example
     * ```js
     * gridView.applyCheckables();
     * ```
     */
    applyCheckables(): void;
    /**
     * CheckBar에 checkableExpression 설정한 후 적용을 한다. 혹은 동시수행 한다.
     *
     * @param expression - 체크 가능 여부의 수식
     * @param apply - 기본값: true, 즉시 적용 여부
     * @example
     * ```js
     * gridView.setCheckableExpression("row % 2 = 1");
     * ```
     */
    setCheckableExpression(expression: string, apply?: boolean): void;
    /**
     * CheckBar에 checkableCallback 설정한 후 적용을 한다. 혹은 동시수행 한다.
     *
     * @param callback - 체크 가능 여부의 콜백
     * @param apply - 기본값: true, 즉시 적용 여부
     *
     * ```js
     * const f = function(dataSource, item) {
     *      console.log("checked!")
     *      return true;
     * }
     * gridView.setCheckableCallback(f);
     * ```
     */
    setCheckableCallback(callback: CheckableCallback, apply?: boolean): void;
    /**
     * 필드의 합계값을 반환한다.
     *
     * @remarks
     * {@link GridBase.summaryMode | summaryMode} 에 따라서 가져올수 있는 값이 다르다.
     *
     * 숫자형 데이터 종류의 필드만 합계값을 가져올수 있다.
     *
     * summaryMode가 {@link SummaryMode.NONE | none}인 경우 미리 계산을 해 놓지 않는다.
     *
     * summaryMode가 {@link SummaryMode.AGGREGATE | aggregate}인 경우 "sum","avg","min",’max","count", "datacount", "dataavg" 를 가져올수 있다.
     *
     * {@link SummaryMode.STATISTICAL | statistical}인 경우 "var","varp","stdev","stdevp"을 추가적으로 가져올수 있다.
     *
     * @param field - 해당 필드명 혹은 인덱스
     * @param type - 기본값: "sum", 다른 속성값은 {@link SummaryType} 참조
     *
     * @example
     *
     * ```js
     * let sum = gridView.getSummary('unitPrice', 'sum');
     * ```
     */
    getSummary(field: string | number, type: SummaryType): number;
    /**
     * itemIndex 에 해당하는 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * ```
     */
    getModel(itemIndex: number, extended?: boolean): GridItem$1;
    /**
     * itemIndex 와 itemType 해당하는 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param itemType - {@link ItemType | 아이템 종류}
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModelAs(3, 'row');
     * ```
     */
    getModelAs(itemIndex: number, itemType: ItemType, extended?: boolean): GridItem$1;
    /**
     * itemIndex 에 해당하는 그룹 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 형식으로 반환한다.
     *
     * @param itemIndex - 아이템의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let group = gridView.getGroupModel(1);
     * ```
     */
    getGroupModel(itemIndex: number, extended?: boolean): GridItem$1;
    /**
     * 아이템 모델의 최상위 조상 아이템 모델을 반환한다.
     *
     * @param model - 모델 정보
     * @param extended - 확장 정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * const idx = gridView.getCurrent();
     * const item = gridView.getModel(idx.itemIndex);
     * const root = gridView.getRootModel(item, extended);
     * ```
     */
    getRootModel(model: GridItem$1, extended?: boolean): GridItem$1;
    /**
     * 지정한 아이템의 인덱스들에 해당하는 아이템 모델들을 반홚나다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param itemIndices - 아이템의 인덱스 배열
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let models = gridView.getModels([1,2,3]);
     * ```
     */
    getModels(itemIndices: number[], extended?: boolean): GridItem$1[];
    /**
     * 행 고유번호에 해당하는 아이템 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param dataRow - 행 고유번호
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let row = gridView.getModelOfRow(1);
     * ```
     */
    getModelOfRow(dataRow: number, extended?: boolean): GridItem$1;
    /**
     * 행 고유번호들에 해당하는 아이템 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param dataRows - 행 고유번호 배열
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let rows = gridView.getModelsOfRows([1,2,3]);
     * ```
     */
    getModelsOfRows(dataRows: number[], extended?: boolean): GridItem$1[];
    /**
     * 아이템 모델의 부모 아이템 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param model - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let parent = gridView.getParentModel(model);
     * ```
     */
    getParentModel(model: GridItem$1, extended?: boolean): GridItem$1;
    /**
     * 아이템 모델의 자식 모델을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param index - 자식 모델 사이에서의 해당 자식 모델의 인덱스
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let child = gridView.getChildModel(model, 2);
     * ```
     */
    getChildModel(parentModel: GridItem$1, index: number, extended?: boolean): GridItem$1;
    /**
     * 아이템 모델의 자식 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let childs = gridView.getChildModels(model);
     * ```
     */
    getChildModels(parentModel: GridItem$1, extended?: boolean): GridItem$1[];
    /**
     * 아이템 모델의 자손 모델들을 반환한다.
     *
     * @remarks
     * {@link GridItem} 의 배열 형식으로 반환한다.
     *
     * @param parentModel - 아이템 모델 정보
     * @param extended - 확장정보 포함 여부, 기본값: `false`
     *
     * @example
     * ```js
     * let model = gridView.getModel(3);
     * let descendants = gridView.getChildModels(model);
     * ```
     */
    getDescendantModels(parentModel: GridItem$1, extended?: boolean): GridItem$1[];
    /**
     * 지정한 그룹아이템 모델의 합계 정보를 반환한다.
     *
     * @remarks
     * 숫자형 필드에 대해서만 의미있는 값을 리턴한다.
     *
     * {@link GroupSummary} 형식으로 반환한다.
     *
     * @param model - 아이템 모델 정보
     * @param field - 필드명
     * @param statistical - 기본값: `false`, {@link GridBase.summaryMode | summaryMode}를 {@link SummaryMode.STATISTICAL | statistical}로 할 경우 `true`, {@link SummaryMode.AGGREGATE | aggregate}으로 할 경우 `false`로 한다.
     *
     * @example
     * ```js
     * let group = gridView.getGroupModel(1);
     * let summary = gridView.getGroupSummary(group, 'fieldName', true);
     * ```
     */
    getGroupSummary(model: GridItem$1, field: string, statistical?: boolean): GroupSummary;
    /**
     * 프로그레스 바를 표시한다.
     *
     * @remarks
     * 진척 상태를 알리는 Progress Bar를 화면에 표시한다.
     *
     * 진척 값과 문자열 정보는 {@link GridBase.setProgress | setProgress()}를 통해 설정한다.
     *
     * @example
     * ```js
     * gridView.showProgress();
     * ```
     */
    showProgress(): void;
    /**
     * 프로그레스 바의 상태를 설정한다.
     *
     * @remarks
     * 화면에 표시될 진척의 최소/최대값 현재값, 표시 문자을 설정한다.
     *
     * @param min - 최소 값
     * @param max - 최대 값
     * @param position - 최소 값과 최대 값 사이의 현재 값
     * @param message - Progress Bar 하단에 표시할 문자열, 미 지정시 기본 문자열 출력
     *
     * @example
     * ```js
     * gridView.setProgress(0, 100, 50);
     * ```
     */
    setProgress(min: number, max: number, position: number, message?: string): void;
    /**
     * 프로그레스 바를 닫는다.
     *
     * @example
     * ```js
     * gridView.closeProgress();
     * ```
     */
    closeProgress(): void;
    /**
     * 로딩 애니메이션을 표시한다.
     *
     * @param disabled - true이면 마우스와 키보드의 동작을 막는다.  - 기본값: `false`,
     * @example
     * ```js
     * gridView.showLoading();
     * ```
     */
    showLoading(disabled?: boolean): void;
    /**
     * 로딩 애니메이션을 숨긴다.
     *
     * @example
     * ```js
     * gridView.closeLoading();
     * ```
     */
    closeLoading(): void;
    /**
     * 지정한 필드들의 값에 해당하는 첫번째 행을 찾아 행의 번호를 반환한다.
     *
     * @param options - {@link SearchOptions} 형태의 설정 정보 모델
     *
     * @example
     *
     * ```js
     * function searchItemHandler() {
     *     let values = ["PR20012392", "QF24212112"]
     *     let fields = [ "RequestType", "ServiceCode" ];
     *     let startFieldIndex = fields.indexOf(gridView.getCurrent().fieldName) + 1;
     *     let options = {
     *          fields : fields,
     *          values: values,
     *          startIndex : gridView.getCurrent().itemIndex,
     *          startFieldIndex : startFieldIndex,
     *          wrap : true,
     *          caseSensitive : false,
     *          partialMatch : true
     *     }
     *     let index = gridView.searchCell(options);
     *     gridView.setCurrent(index);
     * }
     * ```
     */
    searchItem(options: SearchOptions): number;
    /**
     * 지정한 필드들의 값에 해당하는 셀을 찾아 {@link CellIndex}를 반환한다.
     *
     * @param options - {@link SearchCellOptions} 형태의 설정 정보 모델
     *
     *
     * @example
     * ```js
     * function searchCellHandler() {
     *     let value = "PR20012392"
     *     let fields = [ "RequestType", "ServiceCode" ];
     *     let startFieldIndex = fields.indexOf(gridView.getCurrent().fieldName) + 1;
     *     let options = {
     *          fields : fields,
     *          value : value,
     *          startIndex : gridView.getCurrent().itemIndex,
     *          startFieldIndex : startFieldIndex,
     *          wrap : true,
     *          caseSensitive : false,
     *          partialMatch : true
     *     }
     *     let index = gridView.searchCell(options);
     *     gridView.setCurrent(index);
     * }
     * ```
     */
    searchCell(options: SearchCellOptions): any;
    /**
     * 그리드 상위 DIV 영역의 크기를 변경했는데 그리드의 크기가 변경되지 않을때 명시적으로 변경한다.
     *
     * @remarks
     * 그리드가 올라갈 element의 크기가 결정되기 전에 그리드가 생성되거나 element의 style.display속성이 none이어서 그리드의 크기가 0 인 경우,
     *
     * 그리드 상위 DIV 영역의 크기를 변경했는데 그리드의 크기가 변경되지 않을때 사용한다.
     *
     * @param callback - 크기가 재설정 된 후 실행될 콜백
     *
     * ```js
     * const f = function() {
     *      console.log('resized1)
     * }
     * gridView.resetSize(f)
     * ```
     */
    resetSize(callback: any): void;
    /**
     * 필터박스 또는 DropDown Editor를 닫는다.
     *
     * @example
     * ```js
     * gridView.closeList();
     * ```
     */
    closeList(): void;
    /**
     * 지정한 설정에 따라 현재 그리드의 모양과 데이터를 외부 문서로 내보낸다.
     *
     * @param options - {@link GridExportOptions} 과 같은 설정 모델.
     *
     * @example
     * ```js
     * gridView.exportGrid({
     *      type: 'csv'
     * })
     * ```
     */
    exportGrid(options: GridExportOptions): void;
    /**
     * 현재를 기준으로 페이지를 이동한다.
     *
     * @param offset - 현재를 기준으로 이동하려는 페이지 수. 이전 페이지는 음수.
     *
     * @example
     * ```js
     * gridView.scrollPage(3);
     * ```
     */
    scrollPage(offset: number): void;
    /**
     * 그리드 맨 위의 지정한 행의 인덱스를 반환한다.
     *
     * @example
     * ```js
     * let topItem = gridView.getTopItem();
     * ```
     */
    getTopItem(): number;
    /**
     * 그리드 맨 위에 지정한 행으로 위치한다.
     *
     * @param itemIndex - 기본값: 0, 그리드 상단에 위치하고자 하는 행의 인덱스
     *
     * @example
     * ```js
     * gridView.setTopItem();
     * ```
     */
    setTopItem(itemIndex?: number): void;
    /**
     * 가장 왼쪽 화면에 표시되고 있는 컬럼의 x 좌표값을 반환한다.
     *
     * @example
     * ```js
     * let leftPos = gridView.getLeftPos();
     * ```
     */
    getLeftPos(): number;
    /**
     * 그리드 왼쪽 경계가 지정한 값에 위치한다.
     *
     * @param position - x좌표 값
     *
     * @example
     * ```js
     * gridView.setLeftPos(10);
     * ```
     */
    setLeftPos(position: number): void;
    /**
     * 그리드 왼쪽 경계에 지정한 컬럼이 위치한다.
     *
     * @param position - x좌표 값
     *
     * @example
     * ```js
     * gridView.setLeftCol(10);
     * ```
     */
    setLeftCol(index: number): void;
    /**
     * 그리드가 위치한 div를 반환한다.
     *
     * @example
     * ```js
     * let gridContainer = gridView.getContainer;
     * ```
     */
    getContainer(): HTMLDivElement;
    /**
     * 그리드를 해제한다.
     *
     * @example
     * ```js
     * gridView.destory();
     * ```
     */
    destroy(): void;
    /**
     * 그리드의 전체 아이템 갯수를 반환한다.
     *
     * @example
     * ```js
     * let totalCount = gridView.fullItemCount();
     * ```
     */
    fullItemCount(): number;
    /**
     * 그리드에 연결되어 있는 datasource를 이전 상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.undo();
     * ```
     */
    undo(): boolean;
    /**
     * 그리드에 연결되어 있는 datasource를 undo했을 때, 다시 수정 후 상태로 되돌린다.
     *
     * @example
     * ```js
     * gridView.redo();
     * ```
     */
    redo(): boolean;
    /**
     * Command Stack 을 초기화한다.
     *
     * @param all - ?
     *
     * @example
     * ```js
     * gridView.clearCommandStack();
     * ```
     */
    clearCommandStack(all?: boolean): void;
    /**
     * @internal
     */
    protected abstract _createView(container: string | HTMLDivElement, accessibility: boolean, waiOptions: WaiOptions): GridBase$1;
    /**
     * @internal
     */
    protected abstract _createListener(view: GridBase$1): GridViewListener | TreeViewListener;
    /**
     * @internal
     */
    protected _getView(): GridBase$1;
}
/**
 * @public
 * GridView 클래스, {@link GridBase} 의 자식 클래스이다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link GridBase}
 */
declare class GridView extends GridBase {
    /**
     * @internal
     */
    constructor(container: string | HTMLDivElement, accessibility?: boolean, waiOptions?: WaiOptions);
    /**
     * @internal
     */
    protected _view: GridView$1;
    /**
     * 그리드에 설정되어 있는 행 그룹 모델
     *
     * @remarks
     * {@link RowGroup} 객체를 반환한다.
     * RowGroup 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.rowGroup.mergeMode = true;
     * ```
     */
    get rowGroup(): RowGroup;
    /**
     * 그리드에 설정되어 있는 Group Panel 모델
     *
     * @remarks
     * {@link GroupPanel} 객체를 반환한다.
     * GroupPanel 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.groupPanel.visible = true;
     * ```
     */
    get groupPanel(): GroupPanel;
    /**
     * 데이터 수정 이후 필터의 동작 모드
     *
     * @remarks
     * `'explicit'` 을 사용하면 필터링 된 데이터가 수정되었을 때 명시적으로 필터링을 수행해야 필터링이 된다.
     *
     * @example
     * ```js
     * gridView.filterMode = 'explicit';
     * ```
     */
    get filterMode(): FilterMode;
    set filterMode(value: FilterMode);
    /**
     * 컬럼 간 필터 조건을 or 로 할 것인지의 여부
     *
     * @remarks
     * `true` 로 지정하면 각 컬럼의 필터간 필터링이 or 조건으로 반영되어 표시된다.
     *
     * @example
     * ```js
     * gridView.filterOr = true;
     * ```
     */
    get filterOr(): boolean;
    set filterOr(value: boolean);
    /**
     * 행 그룹핑된 컬럼의 합계를 계산하는 방식
     *
     * @remarks
     * 값 할당으로 변경할 수 있다.
     * {@link SummaryMode} 의 값으로 설정한다.
     *
     * @example
     * ```js
     * gridView.groupSummaryMode = 'aggregate';
     * ```
     */
    get groupSummaryMode(): SummaryMode;
    set groupSummaryMode(value: SummaryMode);
    /**
     * 그리드에 설정되어 있는 행 그룹핑에 관한 설정 정보들
     *
     * @remarks
     * {@link GroupingOptions} 객체를 반환한다.
     * GroupingOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * gridView.groupingOptions.linear = true;
     * ```
     */
    get groupingOptions(): GroupingOptions;
    /**
     * 그리드가 Paging 상태일 때, 페이지 이동을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `page` - 새로 이동하게 될 페이지 인덱스
     *
     * [반환값] - false를 반환하면 페이지 이동이 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageChanging = function(grid, page) {
     *      if(page % 2 === 0) {
     *          return true;
     *      }
     *      return false;
     * };
     * ```
     */
    onPageChanging: (grid: GridView, page: number) => boolean;
    /**
     * 그리드가 Paging 상태일 때, 다른 페이지로 이동했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `page` - 새로 이동한 페이지 인덱스
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageChanged = function(grid, page) {
     *      if(page % 2 === 0) {
     *          console.log('even number changed!')
     *      }
     * };
     * ```
     */
    onPageChanged: (grid: GridView, page: number) => void;
    /**
     * 그리드가 Paging 상태일 때, 변경된 페이지 수와 함께 다른 페이지로 이동했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `pageCount` - 변경된 페이지 수
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onPageCountChanged = function(grid, pageCount) {
     *      console.log('pageCount: ' + pageCount);
     * };
     * ```
     */
    onPageCountChanged: (grid: GridView, pageCount: number) => void;
    /**
     * 그룹핑을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `fields` - 그룹핑되는 필드의 인덱스들
     *
     * [반환값] - 그룹핑 실행 여부. false를 반환하면 그룹핑은 취소된다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGrouping = function(grid, fields) {
     *      alert("onGrouping 이벤트가 발생했습니다. false를 반환합니다.");
     *      return false;
     * };
     * ```
     */
    onGrouping: (grid: GridView, fields: number[]) => boolean;
    /**
     * 그룹핑했음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onGrouped = function(grid) {
     *      console.log("I am Grouped!");
     * };
     * ```
     */
    onGrouped: (grid: GridView) => void;
    /**
     * 그룹핑 된 컬럼 펼치기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 펼칠 그룹 아이템의 itemIndex
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onExpanding = function(grid, itemIndex) {
     *      if (itemIndex % 2 === 0) {
     *          return false;
     *      }
     * };
     * ```
     */
    onExpanding: (grid: GridView, itemIndex: number) => boolean;
    /**
     * 그룹핑 된 컬럼이 펼쳐졌음을 알리는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 펼친 그룹 아이템의 id
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onExpanded = function(grid, itemIndex) {
     *      console.log('Expanded at: ' + itemIndex)
     * };
     * ```
     */
    onExpanded: (grid: GridView, itemIndex: number) => void;
    /**
     * 그룹핑 된 컬럼 접기를 결정하는 콜백
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 접을 그룹 아이템의 itemIndex
     *
     * @eventProperty
     * @example
     * ```js
     * gridView.onCollapsing = function(grid, itemIndex) {
     *      if (itemIndex % 2 === 0) {
     *          return false;
     *      }
     * };
     * ```
     */
    onCollapsing: (grid: GridView, itemIndex: number) => boolean;
    /**
     * 그룹핑 된 컬럼이 접힘을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `grid` - GridView 컨트롤
     *
     * `itemIndex` - 접힌 그룹 아이템의 itemIndex
     *
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * gridView.onExpanded = function(grid, itemIndex) {
     *      console.log('Collapsed at: ' + itemIndex)
     * };
     * ```
     */
    onCollapsed: (grid: GridView, itemIndex: number) => void;
    /**
     * 그리드의 {@link RowGroup} 을 반환한다.
     * @example
     *
     * ```js
     * let rowGroup = gridView.getRowGroup();
     * rowGroup.levelIndent = false;
     * gridView.setRowGroup(rowGroup);
     * ```
     */
    getRowGroup(): RowGroup;
    /**
     * 그리드의 {@link RowGroup} 을 설정한다.
     *
     * @param value - {@link RowGroup} 모델과 같은 설정정보. 변경하고자 하는 속성만 전달하면 된다.
     * @example
     *
     * ```js
     * gridView.setRowGroup({levelIndent: false});
     * ```
     */
    setRowGroup(value: RowGroup): void;
    /**
     * 그리드의 {@link GroupPanel} 을 반환한다.
     *
     * @example
     * ```js
     * let groupPanel = gridView.getGroupPanel();
     * groupPanel.visible = false;
     * gridView.setGroupPanel(groupPanel);
     * ```
     */
    getGroupPanel(): GroupPanel;
    /**
     * 그리드 {@link GroupPanel} 을 설정한다.
     *
     * @param value - {@link GroupPanel} 과 같은 정보. 변경하고자 하는 속성만 전달하면 된다.
     *
     * @example
     *
     * ```js
     * gridView.setGroupPanel({visible: false});
     * ```
     */
    setGroupPanel(value: GroupPanel): void;
    /**
     * 그리드 옵션 정보를 반환한다.
     *
     * @remarks
     * {@link GridBase.getOptions} 에 반환되는 모델에 grouping 속성이 추가되어 반환된다.
     *
     * @returns {@link GridView.setOptions | setOptions()} 와 다르게 GridOptions 에서 선언된 그리드 수준의 정보만을 반환한다.
     * @example
     * ```js
     * let options = gridView.getOptions();
     * ```
     */
    getOptions(): ViewOptions;
    /**
     * 그리드 옵션 정보를 재설정한다.
     *
     * @remarks
     * 그리드 수준의 정보만을 반환하는 {@link GridView.getOptions | getOptions} 와 달리 이 method를 통해 하위 구성 요소 및 다른 실행 정보들을 동시에 재설정할 수 있다.
     *
     * @param options - 설정 정보. GridBase의 {@link GridBase.setOptions | setOptions()}의 value 와 동일한 모델에서 grouping 속성이 추가되었다.
     * ```js
     * let options =  {
     *     summaryMode: 'aggregate',
     *     displayOptions: {
     *         columnResizable : false
     *     },
     *     grouping: {
     *         prompt: 'I am Groop'
     *     }
     * };
     * gridView.setOptions(options);
     * ```
     */
    setOptions(options: ViewOptions): void;
    /**
     * 그리드 행 그룹핑에 관한 설정 정보들을 반환한다.
     *
     * @returns {@link GroupingOptions} 와 동일한 모델이다.
     *
     * @example
     * ```js
     * let groupingOpts = gridView.getGroupingOptions();
     * groupingOpts.prompt = "I am Groop";
     * gridView.setGroupingOptions(groupingOpts);
     * ```
     */
    getGroupingOptions(): GroupingOptions;
    /**
     * 그리드 행 그룹핑에 관한 설정을 한다.
     *
     * @param value - 설정하고자 하는 정보. {@link GroupingOptions} 와 동일한 모델이다.
     *
     * @example
     *
     * ```js
     * gridView.setGroupingOptions({prompt: "I am Groop"});
     * ```
     *
     */
    setGroupingOptions(value: GroupingOptions): void;
    /**
     * 지정한 필드 목록에 포함된 순서대로 또는 데이터 정렬 후 순서대로 행 그룹핑을 실행한다.
     *
     * @param fieldNames - 필드 이름 목록. 그룹을 해제하려는 경우 빈 배열을 입력해야 한다.
     * @param sorting - 정렬 여부
     * @param sortDirs - 정렬 방식
     *
     * @example
     * ```js
     * // 그룹 설정
     * gridView.groupBy(["field1", "field2"]);
     *
     * // 그룹 해제
     * gridView.groupBy([]);
     * ```
     */
    groupBy(fieldNames: string[], sorting?: boolean, sortDir?: SortDirection): void;
    /**
     * 그리드가 그룹핑되어 있는지 여부를 반환한다.
     *
     * @example
     * ```js
     * let isGrouped = gridView.isGrouped();
     * ```
     */
    isGrouped(): boolean;
    /**
     * 그리드가 mergeMode로 되어 있는지 여부를 반환한다.
     *
     * @returns 그리드의 {@link RowGroup.mergeMode} 의 설정값
     *
     * @example
     * ```js
     * let isMergedGrouped = gridView.isMergedGrouped();
     * ```
     */
    isMergedGrouped(): boolean;
    /**
     * 그룹핑 된 필드의 인덱스들을 반환한다.
     *
     * @example
     * ```js
     * let GFields = gridView.getGroupFields();
     * ```
     */
    getGroupFields(): number[];
    /**
     * 그룹핑 된 필드의 이름들을 반환한다.
     *
     * @param orginal - 기본값: true, true: 지정한 이름으로 반환, false: 대문자로 반환
     * @returns 필드들의 이름들. DataProvider가 연결되어 있지 않으면, 필드들의 인덱스들을 반환한다.
     *
     * @example
     * ```js
     * let GFieldNames = gridView.getGroupFieldNames();
     * ```
     */
    getGroupFieldNames(orginal?: boolean): string[] | number[];
    /**
     * 현재 몇 level로 그룹핑되어 있는지를 반환한다.
     *
     * @returns group level의 깊이
     *
     * @example
     * ```js
     * let Glevels = gridView.getGroupLevels();
     * ```
     */
    getGroupLevels(): number;
    /**
     * 지정한 필드의 그룹 level을 반환한다.
     *
     * @remarks
     * 첫번째 그룹 레벨은 1이다.
     *
     * @param field - 필드명 또는 인덱스
     * @returns 해당 필드로 그룹핑되지 않았다면 `0`을 반환한다, 없는 필드명이 지정됐을 경우 `-1`이 반환된다.
     *
     * @example
     * ```js
     * let Glevel = gridView.getGroupLevel('field1');
     * ```
     */
    getGroupLevel(field: string | number): number;
    /**
     * 자신이 속한 그룹의 인덱스를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     * @returns 그룹이 없거나, 그룹이 있을 경우 가장 첫 행의 결과는 `-1`이다.
     *
     * @example
     * ```js
     * let GIndex = gridView.getGroupIndex(2);
     * ```
     */
    getGroupIndex(itemIndex: number): number;
    /**
     * 지정한 인덱스가 그룹 아이템인지의 여부를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     *
     * @example
     * ```js
     * let isGroupItem = gridView.isGroupItem(4);
     * ```
     */
    isGroupItem(itemIndex: number): boolean;
    /**
     * 지정한 인덱스의 부모의 표시 여부를 반환한다.
     *
     * @param itemIndex - 그리드 상의 인덱스
     * @returns 해당 아이템이 존재하지 않거나, 해당 아이템의 부모가 존재하지 않으면 `false`를 반환한다.
     *
     * @example
     * ```js
     * let isParentVis = gridView.isParentVisible(2);
     * ```
     */
    isParentVisible(itemIndex: number): boolean;
    /**
     * 지정한 그룹을 펼친다(expand).
     *
     * @remarks
     * 지정한 아이템이 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 그룹에 포함된 자손 그룹의 펼침 여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 true일 때 자손들의 펼침 여부
     * @param level - 기본값: `0`, 0일 때 recursive가 true면 모든 자손을 펼친다.
     *
     * @example
     * ```js
     * gridView.expandGroup(2, true);
     * ```
     */
    expandGroup(itemIndex: number, recursive: boolean, force?: boolean, level?: number): void;
    /**
     * 지정한 그룹을 접는다(collapse).
     *
     * @remarks
     * 지정한 아이템이 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 그룹에 포함된 자손 그룹의 접힘여부. true 일때 이미 collapsed 상태라면 아무일도 하지 않는다.
     * @param force - 기본값: `false`, 이미 collapsed 상태라도 recursive가 true일 때 자손들의 접힘여부.
     *
     * @example
     * ```js
     * gridView.collapseGroup(2, true);
     * ```
     */
    collapseGroup(itemIndex: number, recursive: boolean, force?: boolean): void;
    /**
     * 지정한 그룹의 부모를 펼친다.
     *
     * @remarks
     * 지정한 아이템 또는 그 부모가 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 부모 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 true일 때 부모 그룹의 자손들의 펼침여부
     * @param level - 기본값: `0`, 0일 때 recursive가 true면 모든 자손 expand.
     *
     * @example
     * ```js
     * gridView.expandParent(2, true);
     * ```
     */
    expandParent(itemIndex: number, recursive: boolean, force?: boolean, level?: number): void;
    /**
     * 지정한 그룹의 부모를 접는다(collapse).
     *
     * @remarks
     * 지정한 아이템 또는 그 부모가 존재하지 않거나, 그룹이 아니라면 아무 일도 일어나지 않는다.
     *
     * @param itemIndex - 해당 그룹의 그리드 상의 인덱스
     * @param recursive - 부모 그룹에 포함된 자손 그룹의 접힘여부. true 일때 이미 collapsed 상태라면 아무일도 하지 않는다.
     * @param force - 기본값: `false`, 이미 collapsed 상태라도 recursive가 true일 때 부모 그룹의 자손들의 접힘여부
     *
     * @example
     * ```js
     * gridView.collapseParent(2, true);
     * ```
     */
    collapseParent(itemIndex: number, recursive: boolean, force?: boolean): void;
    /**
     * 루트 그룹을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부.
     * @param level - 기본값: `undefined`, `undefined`: recursive가 true시 모든 자손 expand.
     *
     * @example
     * ```js
     * gridView.expandAll();
     * ```
     */
    expandAll(recursive?: boolean, level?: number): void;
    /**
     * 루트 그룹을 접는다.
     *
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부. `true`일 때 그룹에 포함된 자손 그룹도 접힌 상태가 된다.
     *
     * @example
     * ```js
     * gridView.collapseAll();
     * ```
     */
    collapseAll(recursive?: boolean): void;
    /**
     * 그룹Layout의 expandable이 설정된 경우 그룹Layout을 펼친다.
     *
     * @param recursive - 하위 그룹이 있는 경우 하위 그룹도 펼친다.
     */
    layoutExpandAll(recursive: boolean): void;
    /**
     * 그룹Layout의 expandable이 설정된 경우 그룹Layout을 접는다.
     *
     * @param recursive - 하위 그룹이 있는 경우 하위 그룹도 접는다.
     */
    layoutCollapseAll(recursive: boolean): void;
    /**
     * 그리드에 인덱스로 입력된 데이터행 앞 또는 뒤에 새로운 데이터행을 생성한다.
     *
     * @remarks
     * 그리드가 편집상태이거나 데이터 건수가 없는 경우 추가되지 않는다.
     * itemIndex를 입력하지 않으면 (-1이 입력되면), 이전에 실행된 beginInsertRow의 itemIndex 앞에 추가되거나 실행된적이 없으면 0번째 itemIndex앞에 추가된다.
     * 0 이상의 값을 입력하면 데이터행 앞에 새로운 데이터행을 생성한다.
     *
     * @param itemIndex - 기본값: `-1`, 기준 데이터 행. 이 행 앞에 새로운 데이터행을 생성한다.
     * @param shift - 기본값: `false`, `true`: 데이터 행 뒤에 생성
     *
     * @example
     * ```js
     * gridView.beginInsertRow();
     * ```
     */
    beginInsertRow(itemIndex?: number, shift?: boolean): void;
    /**
     * 그리드 마지막 데이터행 이후에 새로운 데이터행을 추가한다.
     *
     * @example
     * ```js
     * gridView.beginAppendRow();
     * ```
     */
    beginAppendRow(): void;
    /**
     * 입력된 인덱스에 해당하는 데이터 행을 편집상태로 변경한다.
     *
     * @param itemIndex - 행의 인덱스. 지정하지 않으면 focuse 행.
     *
     * @example
     * ```js
     * gridView.beginUpdateRow();
     * ```
     */
    beginUpdateRow(itemIndex?: number): void;
    /**
     * 그리드가 Paging 모드로 실행된다.
     *
     * @param paging - true 시 페이징 모드
     * @param size - 기본값: `10`, 한 페이지에 표시할 행의 개수
     * @param maxCount - 기본값: `-1`, 최대 페이지 개수
     *
     * @example
     * ```js
     * gridView.setPaging(true);
     * ```
     */
    setPaging(paging: boolean, size?: number, maxCount?: number): void;
    /**
     * Paging 모드에서 현재 페이지 번호를 반환한다.
     * @example
     * ```js
     * let currPage = gridView.getPaging();
     * ```
     */
    getPage(): number;
    /**
     * Paging 모드일 때 표시할 페이지를 지정한다.
     *
     * @param page - 페이지 번호
     * @param startItem - 기본값: `-1`, 이 페이지에 표시할 첫번째 행의 인덱스. -1이면 {@link GridView.setPaging | setPaging} 에 지정한 페이지 크기에 따라 결정된다.
     *
     * @example
     * ```js
     * gridView.setPage(4);
     * ```
     */
    setPage(page: number, startItem?: number): void;
    /**
     * Paging 모드일 때 전체 페이지 개수를 반환한다.
     *
     * @example
     * ```js
     * let pageCount = gridView.getPageCount();
     * ```
     */
    getPageCount(): number;
    /**
     * Paging 개수를 변경한다.
     *
     * @param count - 새 페이지 개수
     *
     * @example
     * ```js
     * gridView.setPageCount(20);
     * ```
     */
    setPageCount(count: number): void;
    /**
     * @public
     * 행이 위치한 페이지를 찾는다.
     *
     * @param dataRow - 찾을려고 하는 행의 dataRow
     * @returns 행이 위치한 페이지번호 찾지 못하는 경우 `-1`을 return한다.
     */
    getPageOfDataRow(dataRow: number): number;
    /**
     * 체크된 아이템들의 목록을 배열로 반환한다.
     *
     * @param rowOnly - 기본값: `true`, `true`: 행만 반환, `false`: 그룹푸터 등 비데이터 영역도 반환
     *
     * @example
     * ```js
     * let checkedItems = gridView.getCheckedItems();
     * ```
     */
    getCheckedItems(rowOnly?: boolean): number[];
    /**
     * 체크된 데이터 행들의 목록을 반환한다.
     *
     * @param sort - 기본값: `true`, `true`: 오름차순으로 반환, `false`: 화면에 보이는 순서대로 반환.
     * @param visibleOnly - 기본값: `false`, `true`로 입력하면 collapse 되거나 페이징시 보이지 않는 행들은 제외한다.
     * @param allRows - 기본값: `false`, `true`로 입력하면 페이징 처리시 보이지 않는 페이지들의 체크된 행들도 반환한다.
     *  @example
     * ```js
     * let checkedRows = gridView.getCheckedRows();
     * ```
     */
    getCheckedRows(sort?: boolean, visibleOnly?: boolean, allRows?: boolean): number[];
    /**
     * @remarks
     * merge된 셀에 포함되는 itemIndex를 배열로 가져온다.
     *
     * @param itemIndex - 그리드 행의 itemIndex
     * @param column - column의 이름
     * @param dataOnly - 데이터행만 가져올지 여부 default `true`
     * @param force - `true`이면 merge된 셀이 아니어도 입력된 itemIndex를 포함하는 배열로 return default `true`
     *
     * @returns merge된 셀의 itemIndex 배열
     *
     * @example
     * ```js
     * let mergeItems = gridView.getMergedItems(1, "column", true, true);
     * let mergeDataRows = gridView.getRowsOfItems(mergeItems);
     * ```
     */
    getMergedItems(itemIndex: number, column: string | DataColumn, dataOnly?: boolean, force?: boolean): number[];
    /**
     * @internal
     */
    protected _createView(container: string | HTMLDivElement, accessibility: boolean, waiOptions: WaiOptions): GridBase$1;
    /**
     * @internal
     */
    protected _createListener(view: GridView$1): GridViewListener;
}
/**
 * @public
 * TreeView 클래스, {@link GridBase} 의 자식 클래스이다.
 *
 * @remarks
 * [상위 클래스]
 *
 * {@link GridBase}
 */
declare class TreeView extends GridBase {
    /**
     * @internal
     */
    protected _view: TreeView$1;
    /**
     * TreeView 만이 고유로 가지는 설정 모델
     *
     * @remarks
     * {@link TreeOptions} 객체를 반환한다.
     * TreeOptions 의 속성을 가져오거나 설정할 수 있다.
     *
     * @example
     * ```js
     * treeView.treeOptions.iconWidth = 20;
     * ```
     */
    get treeOptions(): TreeOptions$1;
    /**
     * TreeView의 아이템 노드 펼치기를 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 펼쳐지려는 행의 인덱스
     *
     * `rowId` - 펼쳐지려는 행의 고유번호
     *
     *
     * [반환값] - `false`를 반환하면 펼쳐지지 않는다.
     * @defaultValue `null`
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemExpanding = function (tree, itemIndex, rowId) {
     *     return false;
     * };
     * ```
     */
    onTreeItemExpanding: (tree: TreeView, itemIndex: number, rowId: number) => boolean;
    /**
     * TreeView의 아이템 노드가 펼쳐졌음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 펼쳐진 행의 인덱스
     *
     * `rowId` - 펼쳐진 행의 고유번호
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemExpanded = function (tree, itemIndex, rowId) {
     *     console.log('Expanded at: ' + itemIndex);
     * };
     * ```
     */
    onTreeItemExpanded: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 아이템 노드 접힘을 결정하는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 접으려는 행의 인덱스
     *
     * `rowId` - 접으려는 행의 고유번호
     *
     * @eventProperty
     *
     * [반환값] - `false`를 반환하면 펼쳐지지 않는다.
     * @defaultValue `null`
     *
     * @example
     * ```js
     * treeView.onTreeItemCollapsing = function (tree, itemIndex, rowId) {
     *     return false;
     * };
     * ```
     */
    onTreeItemCollapsing: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 아이템 노드가 졉혔음을 알리는 콜백
     *
     * @remarks
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 접힌 아이템 행의 인덱스
     *
     * `rowId` - 접힌 행의 고유번호
     *
     * @eventProperty
     *
     * @example
     * ```js
     * treeView.onTreeItemCollapsed = function (tree, itemIndex, rowId) {
     *     console.log('Collapsed at: ' + itemIndex);
     * };
     * ```
     */
    onTreeItemCollapsed: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * TreeView의 값이 변경되었음을 알리는 콜백
     *
     * @remarks
     * 값이 변경된 후 {@link GridBase.commit | commit()} 시 발생한다.
     *
     * [매개변수 목록]
     *
     * `tree` - TreeView 컨트롤
     *
     * `itemIndex` - 값이 변경된 행의 인덱스
     *
     * `rowId` - 값이 변경된 행의 고유번호
     *
     *
     * @eventProperty
     * @example
     * ```js
     * treeView.onTreeItemChanged = function (tree, itemIndex, rowId) {
     *     console.log("TreeItem item changed:: " + itemIndex);
     * };
     * ```
     */
    onTreeItemChanged: (tree: TreeView, itemIndex: number, rowId: number) => void;
    /**
     * 트리 그리드 선택 표시 등, 관련된 설정 정보들을 가져온다.
     *
     * @returns {@link TreeOptions} 설정 모델과 동일한 내용의 객체.
     *
     * @example
     * ```js
     * let treeOpts = tree.getTreeOptions();
     * treeOpts.lineVisible = false;
     * tree.setTreeOptions(treeOpts);
     * ```
     */
    getTreeOptions(): TreeOptions$1;
    /**
     * 트리뷰 표시 및 동작과 관련된 설정을 한다.
     *
     * @remarks
     * {@link TreeOptions} 에서 원하는 속성만 지정하여 사용한다.
     *
     * @param options - {@link TreeOptions} 설정 모델과 동일한 내용의 객체. 변경하고자 하는 속성만 변경하면 된다.
     *
     * @example
     *
     * ```js
     * tree.setTreeOptions({lineVisible: false});
     * ```
     */
    setTreeOptions(options: TreeOptions$1): void;
    /**
     * 부모 행의 인덱스를 반환한다.
     *
     * @param itemIndex - 자식 행의 인덱스
     *
     * @example
     *
     * ```js
     * let pIndex = tree.getParent(3);
     * ```
     */
    getParent(itemIndex: number): number;
    /**
     * 자식 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 부모 행의 인덱스
     *
     * @example
     *
     * ```js
     * let cIndexes = tree.getChildren(3);
     * ```
     *
     */
    getChildren(itemIndex: number): number[];
    /**
     * 자손 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 조상 행의 인덱스
     *
     * @example
     *
     * ```js
     * let dIndexes = gridView.getDescendatns(3);
     * ```
     *
     */
    getDescendants(itemIndex: number): number[];
    /**
     * 조상 행들의 인덱스들을 반환한다.
     *
     * @param itemIndex - 해당 행의 인덱스
     * @param includeRoot - 기본값: `true`, `true`: 숨겨진 최상위 루트행의 인덱스를 포함하여 결과 값으로 반환한다.
     *
     * @example
     *
     * ```js
     * let aIndexes = tree.getAncestors(3);
     * ```
     */
    getAncestors(itemIndex: number, includeRoot?: boolean): number[];
    /**
     * 행을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param itemIndex - 펼치려는 행의 인덱스
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 `true`일 때 자손들의 펼침여부
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     *
     * @example
     *
     * ```js
     * tree.expand(3);
     * ```
     */
    expand(itemIndex: number, recursive?: boolean, force?: boolean, level?: number): void;
    /**
     * 아이템(행)을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param model - 펼치려는 아이템의 모델
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param force - 기본값: `false`, 이미 expanded 상태라도 recursive가 `true`일 때 자손들의 펼침여부
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     *
     * @example
     *
     * ```js
     * let model = tree.getModel(4);
     * tree.expand(model);
     * ```
     */
    expandModel(model: GridItem$1, recursive?: boolean, force?: boolean, level?: number): void;
    /**
     * 행을 접는다.
     *
     * @param itemIndex - 접으려는 행의 인덱스
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부
     *
     * @example
     *
     * ```js
     * tree.collapse(3);
     * ```
     */
    collapse(itemIndex: number, recursive?: boolean): void;
    /**
     * 아이템(행)을 접는다.
     *
     * @param model - 접으려는 아이템 모델
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 접힘여부
     *
     * @example
     *
     * ```js
     * let model = tree.getModel(4);
     * tree.collapseModel(model);
     * ```
     */
    collapseModel(model: GridItem$1, recursive: boolean): void;
    /**
     * 모든 행을 펼친다.
     *
     * @remarks
     * recursive가 true일 때 level을 지정하면 해당 level까지 펼친다.
     *
     * @param level - 기본값: `0`, `0`일 때 recursive가 `true`면 모든 자손 펼침
     * @example
     *
     * ```js
     * tree.expandAll();
     * ```
     */
    expandAll(level?: number): void;
    /**
     * 모든 행을 접는다.
     *
     * @example
     *
     * ```js
     * tree.collapseAll();
     * ```
     */
    collapseAll(): void;
    /**
     * Check된 아이템들의 index 목록을 배열로 반환한다.
     *
     * @example
     * ```js
     * let checkedItems = treeView.getCheckedItems();
     * ```
     */
    getCheckedItems(): number[];
    /**
     * Check된 데이터 행들의 index 목록을 반환한다.
     *
     * @param visibleOnly - 기본값: `false`, `true`로 입력하면 collapse되거나 페이징시 보이지 않는 행들은 제외한다.
     * @returns 체크 된 트리 데이텅 행들의 고유번호의 배열
     *
     * @example
     * ```js
     * let checkedRows = treeView.getCheckedRows(true);
     * ```
     */
    getCheckedRows(visibleOnly: boolean): number[];
    /**
     * 입력된 행의 자식 행들을 체크하거나 해제한다.
     *
     * @param itemIndex - 부모행의 ItemModel index
     * @param checked - `true`: 체크, `false`: 해제
     * @param recursive - 기본값: `false`, 그룹에 포함된 자손 그룹의 펼침여부
     * @param visibleOnly - `true`면 collapse되거나 페이징시 보이지 않는 행들은 제외한다.
     * @param checkableOnly - `true`면 체크 가능한 상태인 것들만 체크 한다.
     * @param checkEvent - 기본값: `true`, {@link GridBase.onItemChecked | onItemChecked()} 의 발생 여부
     *
     * @example
     * ```js
     * treeView.checkChildren(4, truee, true, true, true);
     * ```
     */
    checkChildren(itemIndex: number, checked: boolean, recursive: boolean, visibleOnly: boolean, checkableOnly: boolean, checkEvent?: boolean): void;
    /**
     * @internal
     */
    protected _createView(container: string | HTMLDivElement, accessibility: boolean, waiOptions: WaiOptions): GridBase$1;
    /**
     * @internal
     */
    protected _createListener(view: TreeView$1): TreeViewListener;
}
/** @internal */
declare class GridBaseListener extends EventListenerBase {
    protected _del: GridView | TreeView;
    protected _view: GridBase$1;
    constructor(del: GridView | TreeView, view: GridBase$1);
    dispose(): void;
    onGridBaseViewActivated(grid: GridBase$1, active: boolean): void;
    onGridBaseCurrentChanging(grid: GridBase$1, oldIndex: CellIndex, newIndex: CellIndex): boolean;
    onGridBaseCurrentChanged(grid: GridBase$1, index: CellIndex): void;
    onGridBaseCurrentRowChanged(grid: GridBase$1, oldRow: number, newRow: number): void;
    onGridBaseValidateCell(grid: GridBase$1, index: CellIndex, inserting: boolean, value: any): void;
    onGridBaseValidateRow(grid: GridBase$1, item: GridItem, inserting: boolean, values: any[]): void;
    onGridBaseValidationFail(grid: GridBase$1, itemIndex: number, column: GridColumn, err: any): any;
    onGridBaseCellClicked(grid: GridBase$1, clickData: any): void;
    onGridBaseCellDblClicked(grid: GridBase$1, clickData: any): void;
    onGridBaseCellItemClicked(grid: GridBase$1, index: CellIndex, clickData: any): boolean | void;
    onGridBaseColumnCheckedChanged(grid: GridBase$1, column: GridColumn, checked: boolean): void;
    onGridBaseMenuItemClicked(grid: GridBase$1, menuItem: PopupMenuItem, clickData: any): void;
    onGridBaseContextMenuPopup(grid: GridBase$1, x: number, y: number, clickData: any): string | boolean | void;
    onGridBaseContextMenuItemClicked(grid: GridBase$1, menuItem: PopupMenuItem, clickData: any): void;
    onGridBaseCellButtonClicked(grid: GridBase$1, index: CellIndex): void;
    onGridBaseScrollToBottom(grid: GridBase$1): void;
    onGridBaseTopIndexChanged(grid: GridBase$1, itemIndex: number): void;
    onGridBaseTopIndexChanging(grid: GridBase$1, currentTop: number, delta: number, focusing: boolean, adjust: boolean): number | void;
    onGridBaseRowsDeleting(grid: GridBase$1, rows: number[]): boolean;
    onGridBaseRowInserting(grid: GridBase$1, itemIndex: number, dataRow: number): boolean;
    onGridBaseSelectionCleared(grid: GridBase$1): void;
    onGridBaseSelectionChanged(grid: GridBase$1, selection: Selection): void;
    onGridBaseSelectionAdded(grid: GridBase$1, selection: Selection): void;
    onGridBaseSelectionEnded(grid: GridBase$1, selection: Selection): void;
    onGridBaseShowEditor(grid: GridBase$1, index: CellIndex, props: any, attrs: any): boolean | void;
    onGridBaseHideEditor(grid: GridBase$1, index: CellIndex): void;
    onGridBaseEditChange(grid: GridBase$1, index: CellIndex, value: any): void;
    onGridBaseGetEditValue(grid: GridBase$1, index: CellIndex, editResult: any): void;
    onGridBaseEditCommit(grid: GridBase$1, index: CellIndex, oldValue: any, newValue: any): boolean;
    onGridBaseEditCanceled(grid: GridBase$1, index: CellIndex): void;
    onGridBaseItemEditCanceled(grid: GridBase$1, item: GridItem): void;
    onGridBaseItemEditCancel(grid: GridBase$1, item: GridItem): boolean;
    onGridBaseEditSearch(grid: GridBase$1, index: CellIndex, text: string): void;
    onGridBaseSearchCellButtonClick(grid: GridBase$1, index: CellIndex, text: string): void;
    onGridBaseCellEdited(grid: GridBase$1, item: GridItem, field: number): void;
    onGridBaseEditRowChanged(grid: GridBase$1, item: GridItem, field: number, oldValue: any, newValue: any): void;
    onGridBaseEditRowPasted(grid: GridBase$1, item: GridItem, fields: number[], oldValues: any[], newValues: any[]): void;
    onGridBaseRowsPasted(grid: GridBase$1, items: number[]): void;
    onGridBaseCellPasting(grid: GridBase$1, index: CellIndex, value: any): boolean | void;
    onGridBaseItemChecked(grid: GridBase$1, item: GridItem, checked: boolean): void;
    onGridBaseItemsChecked(grid: GridBase$1, items: GridItem[], checked: boolean): void;
    onGridBaseItemAllChecked(grid: GridBase$1, checked: boolean): void;
    onGridBaseErrorClicked(grid: GridBase$1, error: string): void;
    onGridBaseSorting(grid: GridBase$1, fields: number[], directions: SortDirection[]): boolean | void;
    onGridBaseSortingChanged(grid: GridBase$1): void;
    onGridBaseFiltering(grid: GridBase$1): boolean | void;
    onGridBaseFilteringChanged(grid: GridBase$1, filterCollection: ColumnFilterCollection, filter: ColumnFilter): void;
    onGridBaseKeyDown(grid: GridBase$1, event: KeyboardEvent): boolean | void;
    onGridBaseKeyPress(grid: GridBase$1, event: KeyboardEvent): void;
    onGridBaseKeyUp(grid: GridBase$1, event: KeyboardEvent): void;
    onGridBaseShowTooltip(grid: GridBase$1, index: CellIndex, value: any): any;
    onGridBaseShowHeaderTooltip(grid: GridBase$1, column: GridColumn, value: any): any;
    onGridBaseColumnPropertyChanged(grid: GridBase$1, column: GridColumn, property: string, value: any, oldValue: any): void;
    onGridBaseLayoutPropertyChanged(grid: GridBase$1, layout: CellLayoutItem$1, property: string, value: any, oldValue: any): void;
    onGridBaseGridActivated(grid: GridBase$1): void;
    onGridBasePaste(grid: GridBase$1, index: CellIndex, e: any): boolean;
    onGridBaseCopy(grid: GridBase$1, selection: SelectionItem | SelectionItem[], e: any): boolean;
    onGridBasePasted(grid: GridBase$1): void;
    onGridBaseCommandStackChanged(grid: GridBase$1, undoable: boolean, redoable: boolean): void;
    onGridBaseDataLoadComplated(grid: GridBase$1): void;
}
/** @internal */
declare class GridViewListener extends GridBaseListener {
    protected _del: GridView;
    protected _view: GridView$1;
    constructor(del: GridView, view: GridView$1);
    dispose(): void;
    onGridViewPageChanging(grid: GridView$1, newPage: number): boolean;
    onGridViewPageChanged(grid: GridView$1, page: number): void;
    onGridViewPageCountChanged(grid: GridView$1, pageCount: number): void;
    onGridViewGrouping(grid: GridView$1, fields: number[]): boolean;
    onGridViewGrouped(grid: GridView$1): void;
    onGridViewExpanding(grid: GridView$1, group: GroupItem): boolean;
    onGridViewExpanded(grid: GridView$1, group: GroupItem): void;
    onGridViewCollapsing(grid: GridView$1, group: GroupItem): boolean;
    onGridViewCollapsed(grid: GridView$1, group: GroupItem): void;
}
/** @internal */
declare class TreeViewListener extends GridBaseListener {
    protected _del: TreeView;
    protected _view: TreeView$1;
    constructor(del: TreeView, view: TreeView$1);
    dispose(): void;
    onTreeViewExpanding(tree: TreeView$1, item: TreeItem): boolean;
    onTreeViewExpanded(tree: TreeView$1, item: TreeItem): void;
    onTreeViewCollapsing(tree: TreeView$1, item: TreeItem): true | void;
    onTreeViewCollapsed(tree: TreeView$1, item: TreeItem): void;
    onTreeViewChanged(tree: TreeView$1, item: TreeItem): void;
}

declare type ErrorParams = {
    code: number;
    stop: boolean;
    msg?: string;
};

/**
 * ReportViewer base class
 */
declare abstract class ReportViewBase {
    protected _options: ReportOptions;
    protected _cm: boolean;
    protected _container: PrintContainer | undefined;
    protected _currentPage: number;
    protected _containerId: string;
    constructor(container: string | HTMLDivElement, options?: ReportOptions);
    abstract preview(options: PreviewOptions): void;
    abstract exportPdf(options: PDFExportOptions): Promise<void>;
    abstract exportImage(imageOptions: ImageExportOptions): void;
    abstract exportDocument(documentOptions: DocExportOptions): void;
    /**
     * 컨테이너의 상태를 체크하기 위한 조건과 조건에 맞을 경우의 에러 처리코드를 넘겨 줍니다.
     * checker.is 가 true이면 errorParams로 error() 를 실행 합니다.
     *
     * @param checkers 에러 조건 및 error() 함수 인자
     */
    protected _checkPrintContainer(checkers?: {
        is: boolean;
        errorParams: ErrorParams;
    }[]): void;
    protected _checkPrintContainerZoom(): void;
    get containerId(): string;
    set containerId(container: string | HTMLDivElement);
    get version(): string;
    get zoom(): number;
    set zoom(v: number);
    get pageCount(): number;
    get page(): number;
    set page(v: number);
    get reportHtml(): string;
    getHtml(): string;
    first(): void;
    prev(): void;
    next(): void;
    last(): void;
    zoomIn(scale?: number): void;
    zoomOut(scale?: number): void;
    fitToHeight(): void;
    fitToPage(): void;
    fitToWidth(): void;
    private $_checkL;
}

/**
 * RealReport Viewer
 */
declare class ReportViewer extends ReportViewBase {
    private _reportForm?;
    private _dataSet?;
    protected _report: Report;
    private _reportDataProvider;
    constructor(container: string | HTMLDivElement, reportForm?: ReportForm, dataSet?: ReportDataSet, options?: ReportOptions);
    get reportForm(): ReportForm;
    set reportForm(v: ReportForm);
    get dataSet(): ReportDataSet;
    set dataSet(v: any);
    /**
     * container에 리포트를 preview로 렌더링 합니다.
     */
    preview(options?: PreviewOptions): void;
    /**
     * 리포트를 PDF파일로 다운로드 합니다.
     * @param options PDFExportOptions
     */
    exportPdf(options: PDFExportOptions): Promise<void>;
    /**
     * 이미지 내보내기 함수
     * @param imageOptions
     */
    exportImage(imageOptions?: ImageExportOptions): void;
    /**
     * 문서 내보내기 함수
     * @param documentOptions
     */
    exportDocument(documentOptions?: DocExportOptions): void;
    private _checkReport;
}

/** REPORT CORE */

interface GridReportHeader {
    items: TextItem[];
}
interface GridReportTitle extends TextItem {
}
interface GridReportOptions extends ReportOptions {
    paper?: PaperOptions;
    title?: GridReportTitle;
    subTitle?: GridReportTitle;
    gridHeader?: GridReportHeader;
    pageHeader?: PageHeader;
    pageFooter?: PageFooter;
    layout: GridReportLayout;
}
/**
 * GridreportViewer
 */
declare class GridReportViewer extends ReportViewer {
    private _grid;
    private _gridValues;
    protected _options: GridReportOptions;
    constructor(container: string | HTMLDivElement, grid: GridView, options?: GridReportOptions);
    /**
     * 컨테이너에 미리보기 랜더링
     */
    preview(options?: PreviewOptions): void;
    /**
     * 타이틀 또는 서브 타이틀 추가
     * @param title GridReportTitle 객체
     * @returns
     */
    private _addTitle;
    /**
     * 그리드 윗쪽 헤더 추가
     * @param header GridReportHeader 객체
     * @returns
     */
    private _addGridHeader;
    /**
     * 페이지 헤더 추가.
     * @param header PageHeader 객체
     * @returns
     */
    private _addPageHeader;
    /**
     * Layout 정보
     *   - visibleCount: number
     *   - getDataColumns(): DataColumn[]
     *   - headerRows: number
     */
    private _addGridTable;
    private _prepare;
}

/**
 * RealReport Composite Viewer
 */
declare class ReportCompositeViewer extends ReportViewBase {
    private _reportFormSets?;
    private _reports;
    constructor(container: string | HTMLDivElement, formSets: ReportFormSets, options?: ReportOptions);
    /**
     * container에 formsset을 preview로 렌더링 합니다.
     * 매핑 정보
     *   - form -> report
     */
    preview(options?: PreviewOptions): void;
    exportPdf(options: PDFExportOptions): Promise<void>;
    exportImage(imageOptions: ImageExportOptions): void;
    exportDocument(documentOptions: DocExportOptions): void;
    private _checkReportFormSet;
}

interface ReportOptions {
    zoom: number;
}
declare type ReportForm = Record<string, any>;
declare type ReportData = Record<string, any>;
declare type ReportDataSet = Record<string, ReportData>;
declare type ReportFormSet = {
    form: ReportForm;
    dataSet?: ReportDataSet;
};
declare type ReportFormSets = ReportFormSet[];

/**
 * 컬럼 이름
 */
declare type ColumnName = string;
/**
* 그리드 리포트 레이아웃 정보
*/
declare type GridReportLayout = {
    exclude?: ColumnName[];
    autoWidth: boolean;
};
/**
 * 리포트 프리뷰 옵션
 */
declare type PreviewOptions = {
    /**
     * 비동기 출력 여부
     * default: false;
     */
    async?: boolean;
    /**
     * 비동기 출력시 출력 페이지 마커 표시 여부
     * default: false;
     */
    pageMark?: boolean;
    /**
     * 비동기 출력시 출력 페이지마다 스크롤 이동 여부
     * default: true;
     */
    noScroll?: boolean;
    /**
     * 미리보기가 시작될때 호출되는 콜백함수
     */
    callback?: PrintPageCallback;
    /**
     * 미리보기 끝날때 호출되는 콜백함수
     */
    endCallback?: PrintEndCallback;
};
/**
 * PDF내보내기시 인자로 사용되는 옵션
 */
declare type PDFExportOptions = {
    /**
     * pdf 문서에서 사용할 폰트의 목록 입니다.
     */
    fonts: PdfFont[];
    /**
     * download할 때 사용할 filename
     * filename이 없으면 다운로드 되지 않습니다.
     */
    filename?: string;
    /**
     * 새로운 창을 열어 PDF문서를 미리보기 할 수 있습니다.
     * 지원되는 브라우저가 제한될 수 있습니다.
     */
    preview?: boolean;
};

export { GridReportLayout, GridReportViewer, PDFExportOptions, PreviewOptions, ReportCompositeViewer, ReportData, ReportDataSet, ReportForm, ReportFormSet, ReportFormSets, ReportOptions, ReportViewer };
